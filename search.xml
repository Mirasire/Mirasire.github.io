<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>scheme-notes</title>
    <url>/2020/11/24/scheme-note/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Notes</category>
        <category>Lisp</category>
      </categories>
      <tags>
        <tag>lisp</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>cool_review</title>
    <url>/2020/11/13/cool-review/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux笔记-如何使用GDB进行调试</title>
    <url>/2020/11/11/gdb/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>Linux</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU/Flex 入门手册</title>
    <url>/2020/11/01/fireFLEX/</url>
    <content><![CDATA[<blockquote>
<p>GNU/flex Version: 2.5.35<br>前置条件: <strong>C语言基础</strong> | <strong>正则表达式知识</strong></p>
</blockquote>
<a id="more"></a>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
  </entry>
  <entry>
    <title>📑 - 数据库系统原理</title>
    <url>/2020/06/03/tkkmssql/</url>
    <content><![CDATA[<p>『 期末复习 』- 🔍 数据库系统原理</p>
<blockquote>
<p>厦门大学嘉庚学院(TKK)专业课 - 数据库系统原理</p>
</blockquote>
<a id="more"></a>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>TKK学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Mirasire&#39;s Emacs Notes」- Ph1.1</title>
    <url>/2020/05/22/emacs-00/</url>
    <content><![CDATA[<ul>
<li>Evil = 让他不那么令人讨厌</li>
<li>Melp = 让它变得<code>不可思议</code><br><del>Emacs + Elisp = Everything  You want!</del><br>TODO</li>
</ul>
<a id="more"></a>
]]></content>
      <categories>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
        <tag>学习历程</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#613 题解报告</title>
    <url>/2020/05/18/CodeForceR613/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p>CodeForces-Round#613 | <a href="http://codeforces.com/contest/1285" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="http://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Mezo-Playing-Zoma"><a href="#A-Mezo-Playing-Zoma" class="headerlink" title="A. Mezo Playing Zoma"></a>A. Mezo Playing Zoma</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>发送一串含L、R字符的字符串，<code>L=1</code>，<code>R=-1</code>，在发送的时候可能会丢失一部分。</p>
<p>问：对方接到数值数据(即将字符串的值都加起来)最多又集中不同的数值？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然这个问题的答案是能接收到的数值的$\text{Max - Min + 1}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> l,r,n;</span><br><span class="line">    l=r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'R'</span>) r++;</span><br><span class="line">        <span class="keyword">else</span> l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Just-Eat-It"><a href="#B-Just-Eat-It" class="headerlink" title="B. Just Eat It!"></a>B. Just Eat It!</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll arr[maxn];</span><br><span class="line">    </span><br><span class="line"><span class="function">ll <span class="title">getAdeMax</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ll maxAde=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp+arr[i]&lt;<span class="number">0</span>) tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp+=arr[i];</span><br><span class="line">            maxAde=max(tmp,maxAde);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAde;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    ll yas,ade,mmade;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        yas=ade=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">            yas+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ade=max(getAdeMax(<span class="number">1</span>,n),getAdeMax(<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ade&gt;=yas? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Date: 2020-05-07</span></span><br><span class="line"><span class="comment">    * Sign: Mirasire -&gt; archlinux</span></span><br><span class="line"><span class="comment">    * github repo. -&gt; Mirasire/icpc-train </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">    </span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b? gcd(b,a%b) : a ; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll x,a,b,mid,n;</span><br><span class="line">    ll ta,tb;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    a=<span class="number">1</span>; b=mid=x;</span><br><span class="line">    n=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        ta=i,tb=x/i;</span><br><span class="line">        <span class="keyword">if</span>(!(x%ta) &amp;&amp; gcd(ta,tb)==<span class="number">1</span> &amp;&amp; tb &lt; mid) &#123;</span><br><span class="line">            a=ta;</span><br><span class="line">            b=tb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>  &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Date: 2020-05-07</span></span><br><span class="line"><span class="comment">    * Sign: Mirasire -&gt; archlinux</span></span><br><span class="line"><span class="comment">    * github repo. -&gt; Mirasire/icpc-train </span></span><br><span class="line"><span class="comment">    * steal form bilibili</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pb push_back</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.size()==<span class="number">0</span> || k&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p1,p0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: p) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&gt;&gt;k)&amp;<span class="number">1</span>) p1._pb(i-(<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">        <span class="keyword">else</span> p0._pb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p0.size() == <span class="number">0</span>) <span class="keyword">return</span> slove(p1,k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p1.size() == <span class="number">0</span>) <span class="keyword">return</span> slove(p0,k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;k)+min(slove(p1,k<span class="number">-1</span>),slove(p0,k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBits</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k,Smax=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        a._pb(tmp);</span><br><span class="line">        Smax=max(Smax,getBits(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; slove(a,Smax<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h1 id="F"><a href="#F" class="headerlink" title="F."></a>F.</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>orgbsic</title>
    <url>/2020/05/15/orgBsc/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>orggtd</title>
    <url>/2020/05/15/orgGtd/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>gtd1</title>
    <url>/2020/05/15/Gtd/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>数据结构学习 - 并查集及其拓展</title>
    <url>/2020/05/01/dsu-ds/</url>
    <content><![CDATA[<p>TODO</p>
<p><del>dsu学习笔记指北</del></p>
<p><strong>并查集(dsu)学习笔记指南</strong></p>
<a id="more"></a>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="结构目的"><a href="#结构目的" class="headerlink" title="结构目的"></a>结构目的</h3><p>快速合并多个集合并查询元素是否处于同一集合中的数据结构。</p>
<blockquote>
<p>下述是普通集合和并查集合并的区别。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/img/dsu1.jpg" alt="normal set unite"></th>
<th style="text-align:center"><img src="/img/dsu2.jpg" alt="union set unite"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通集合</td>
<td style="text-align:center">并查集</td>
</tr>
</tbody>
</table>
</div>
<h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dsu[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=u,tp;</span><br><span class="line">    <span class="keyword">while</span>(dsu[u]!=u) u=dsu[u];</span><br><span class="line">    <span class="keyword">while</span>(dsu[a]!=u) &#123;</span><br><span class="line">        tp=dsu[a];</span><br><span class="line">        dsu[a]=u;</span><br><span class="line">        a=tp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb) dsu[fa]=fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="带权并查询集"><a href="#带权并查询集" class="headerlink" title="带权并查询集"></a>带权并查询集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">100</span>,MOD=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> dsu[maxn],val[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dsu[u]!=u) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=dsu[u];</span><br><span class="line">        dsu[u]=find(dsu[u]);</span><br><span class="line">        val[u]=(val[t]+val[u])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dsu[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展域并查询集"><a href="#扩展域并查询集" class="headerlink" title="扩展域并查询集"></a>扩展域并查询集</h3><h2 id="例题-食物链"><a href="#例题-食物链" class="headerlink" title="例题-食物链"></a>例题-食物链</h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法-1"></a>解法-1</h3><p><strong><em>带权并查询集</em></strong></p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法-2"></a>解法-2</h3><p><strong><em>扩展域并查询集</em></strong></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title>📑 - 计算机科学图形学</title>
    <url>/2020/04/21/tkkcgra/</url>
    <content><![CDATA[<p>与其说更像笔记，不如说是上课一些零碎东西的速记和堆叠。</p>
<blockquote>
<p>厦门大学嘉庚学院(TKK)选修课 - 计算机图形学</p>
</blockquote>
<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>TKK学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>💤 · 关于失眠的困扰和我的解决 · 💤</title>
    <url>/2020/04/17/BBCSleep10/</url>
    <content><![CDATA[<p>🛌谁不想有个美美的睡眠呢？<br><del>都是因为失去了珍贵的睡眠啊QWQ</del></p>
<a id="more"></a>
<h1 id="为啥-¿"><a href="#为啥-¿" class="headerlink" title="为啥 ¿"></a>为啥 ¿</h1><p><del>这个显然是因为再也无法忍受到早上疯狂赖床，和醒来很难受后…</del><br>哈？当人是累死个人啦QWQ，真的那种无敌无敌累，醒来也不舒服，而且上课的时候还无法集中注意力，懒懒散散的。</p>
<h1 id="过程-◰"><a href="#过程-◰" class="headerlink" title="过程 ◰"></a>过程 ◰</h1><blockquote>
<p>4-21-2020 ~ 5-11-2020</p>
</blockquote>
<h2 id="BBC睡眠十率"><a href="#BBC睡眠十率" class="headerlink" title="BBC睡眠十率"></a>BBC睡眠十率</h2><h3 id="视频总结"><a href="#视频总结" class="headerlink" title="视频总结"></a>视频总结</h3><blockquote>
<p>按照视频方法出现时间排序</p>
</blockquote>
<ol>
<li>睡觉前一小时洗个澡，出来后，当体温下降到最低的时候，就是最容易入睡的时候。<ul>
<li>标签：低温 ⇨ 困倦</li>
</ul>
</li>
<li>固定只能在卧室待上6个小时，其余时间都不能在卧室。<ul>
<li>标签：限时 ⇨ 卧室</li>
</ul>
</li>
<li>脚步用力，放松，循环几次。<ul>
<li>标签：脚步 ⇨ 抓放</li>
</ul>
</li>
</ol>
<h3 id="个人实验"><a href="#个人实验" class="headerlink" title="个人实验"></a>个人实验</h3><h2 id="冥想"><a href="#冥想" class="headerlink" title="冥想"></a>冥想</h2><h3 id="冥想方法"><a href="#冥想方法" class="headerlink" title="冥想方法"></a>冥想方法</h3><h3 id="个人实验-1"><a href="#个人实验-1" class="headerlink" title="个人实验"></a>个人实验</h3><h1 id="总结-◲"><a href="#总结-◲" class="headerlink" title="总结 ◲"></a>总结 ◲</h1><p><br/></p>
<blockquote>
<p>4-21-2020<br>真的会很难受，特别是醒来时候，而且睡的也不舒服。</p>
</blockquote>
<ul>
<li>永远，永远，永远不要拆分一个睡眠。</li>
<li>永远不要将躺在床上休息，然后莫名奇妙的睡着。</li>
</ul>
<blockquote>
<p>4-22-2020<br>尝试了5小时睡眠。</p>
</blockquote>
<ul>
<li>5小时睡眠，在早上起床的时候，会很累，没有神清气爽的感觉。</li>
<li>在醒来之后再依靠着困意入眠，再次醒来的感觉更加让人难受。</li>
</ul>
<blockquote>
<p>4-24-2020<br>尝试7~8小时睡眠法。</p>
</blockquote>
<h1 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h1><p><a href="https://www.bilibili.com/video/BV1qs411h7RQ" target="_blank" rel="noopener"><strong>Bilibili-睡眠十律</strong></a><br><a href="https://www.bilibili.com/video/BV1R7411E7KS" target="_blank" rel="noopener"><strong>Bilibili-什么是冥想?</strong></a></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
        <tag>睡觉</tag>
        <tag>失眠</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式笔记-快速快速数论变换</title>
    <url>/2020/04/13/NTT/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式笔记-快速傅里叶变换</title>
    <url>/2020/04/13/FFT/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>其他树学习笔记-线段树</title>
    <url>/2020/04/12/SegmentTree/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>『LeetCode』--&amp;nbsp 每日一题</title>
    <url>/2020/04/10/LctOne/</url>
    <content><![CDATA[<p>XXX <strong>- · - 连载中 - · -</strong> XXX</p>
<p><strong>Mirasire的LeetCode每日一题</strong></p>
<blockquote>
<p>日积月累 • 💧水滴石穿。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="『Lct151』Reverse-Words-in-a-String"><a href="#『Lct151』Reverse-Words-in-a-String" class="headerlink" title="『Lct151』Reverse Words in a String"></a>『Lct151』Reverse Words in a String</h1><blockquote>
<p>2020-4-10<br>链接地址 | <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener"><strong>Lct151</strong></a></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time:  xxxms</span></span><br><span class="line"><span class="comment">/*...code...*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="『Lct887』Super-Egg-Drop"><a href="#『Lct887』Super-Egg-Drop" class="headerlink" title="『Lct887』Super Egg Drop"></a>『Lct887』Super Egg Drop</h1><blockquote>
<p>2020-4-11<br>链接地址 | <a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener"><strong>Lct887</strong></a></p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time:  xxxms</span></span><br><span class="line"><span class="comment">/*...code...*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="『Lct16-03』Intersection-LCCI"><a href="#『Lct16-03』Intersection-LCCI" class="headerlink" title="『Lct16.03』Intersection LCCI"></a>『Lct16.03』Intersection LCCI</h1><blockquote>
<p>2020-4-12<br>链接地址 | <a href="https://leetcode-cn.com/problems/intersection-lcci/" target="_blank" rel="noopener"><strong>Lct16.03</strong></a></p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h3 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time:  xxxms</span></span><br><span class="line"><span class="comment">/*...code...*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="『Lct355』Design-Twitter"><a href="#『Lct355』Design-Twitter" class="headerlink" title="『Lct355』Design Twitter"></a>『Lct355』Design Twitter</h1><blockquote>
<p>2020-4-13<br>链接地址 | <a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener"><strong>Lct355</strong></a></p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time:  xxxms</span></span><br><span class="line"><span class="comment">/*...code...*/</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>『LeetCode』--&amp;nbsp 数据库</title>
    <url>/2020/04/10/LctSql/</url>
    <content><![CDATA[<p>XXX <strong>- · - 连载中 - · -</strong> XXX</p>
<p><strong>LeetCode 数据库刷题笔记。</strong></p>
<blockquote>
<p>选择语言: <strong>T-SQL</strong><br>题目连接 | <a href="https://leetcode-cn.com/problemset/database/" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="『Lct182』Duplicate-Emails"><a href="#『Lct182』Duplicate-Emails" class="headerlink" title="『Lct182』Duplicate Emails"></a>『Lct182』Duplicate Emails</h1><p><strong>Label: <font color=green>&nbsp;&nbsp;Easy</font></strong></p>
<blockquote>
<p>链接地址 | <a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener"><strong>Lct182</strong></a></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分组，然后使用函数查找邮箱出现次数&gt;1次的即可。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--time: 1245ms | memory: 0B</span></span><br><span class="line"><span class="comment">/* Write your T-SQL query statement below */</span></span><br><span class="line"><span class="keyword">SELECT</span> Email <span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Email</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(Email)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在T-SQL中，WHERE不能和count这类聚合函数一起使用，所以当是哟这类函数作为筛选条件的时候要使用<strong>HAVING</strong>语句。<br>然而关于<strong>HAVING语句通常和GROUP BY语句连用的原因</strong>。</p>
<p>这边引用<a href="https://docs.microsoft.com/zh-cn/sql/t-sql/queries/select-having-transact-sql?view=sql-server-ver15" target="_blank" rel="noopener"><strong>MS文档</strong></a>作为解释：</p>
<blockquote>
<p>指定组或聚合的搜索条件。 HAVING 只能与 SELECT 语句一起使用。 HAVING 通常与 GROUP BY 子句一起使用。 如果未使用 GROUP BY，则会有隐式的单一、聚合组。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配-AC自动机</title>
    <url>/2020/04/10/aca-ds/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>随机化算法-拉斯维加斯(Las Vegas)算法</title>
    <url>/2020/04/09/LASVEGAS/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
<h1 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h1><h1 id="N-Queens-Problem"><a href="#N-Queens-Problem" class="headerlink" title="N-Queens Problem"></a>N-Queens Problem</h1><blockquote>
<p>问题描述</p>
</blockquote>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><h3 id="伪代码描述"><a href="#伪代码描述" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h2 id="Las-Vegas方法"><a href="#Las-Vegas方法" class="headerlink" title="Las Vegas方法"></a>Las Vegas方法</h2><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><h3 id="伪代码描述-1"><a href="#伪代码描述-1" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h2 id="回溯法-Las-Vegas算法"><a href="#回溯法-Las-Vegas算法" class="headerlink" title="回溯法+Las Vegas算法"></a>回溯法+Las Vegas算法</h2><h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><h3 id="伪代码描述-2"><a href="#伪代码描述-2" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h2 id="关于Las-Vegas算法的总结"><a href="#关于Las-Vegas算法的总结" class="headerlink" title="关于Las Vegas算法的总结"></a>关于Las Vegas算法的总结</h2>]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>随机化算法</category>
      </categories>
      <tags>
        <tag>随机化算法</tag>
        <tag>Las Vegas</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划-单纯形算法</title>
    <url>/2020/04/06/lp-al/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p>当事人现在就是就很后悔，十分后悔。</p>
</blockquote>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h1 id="单纯形算法"><a href="#单纯形算法" class="headerlink" title="单纯形算法"></a>单纯形算法</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://item.jd.com/11144230.html" target="_blank" rel="noopener"><strong>《算法导论（原书第三版）》</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>数学</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配-KMP算法和Z函数</title>
    <url>/2020/04/06/KMP-1/</url>
    <content><![CDATA[<p><del>KMP算法学习指南（个虾球</del><br>基础 <strong><code>KMP算法和Z函数</code></strong> 的学习与刷题指南。</p>
<blockquote>
<p>模板地址 | <a href="https://github.com/Mirasire/icpc-train/tree/master/Mirasire&#39;s%20Template/Else" target="_blank" rel="noopener"><strong>LINK</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h1><p>在字符串$T$中找字符串$P$，如果找到即返回$T$中所有出现$P$的位置，这样的问题称为字符串匹配问题。<br>字符串$T$称为文本串($\textrm{Text}$)，字符串$P$称为模式串($\textrm{Pattern}$)。</p>
<blockquote>
<p>在<strong>算法导论中的严格定义</strong>如下：</p>
<p>假设文本是一个长度为$n$的数组$T[1..n]$，而模式是一个长度为$m$的数组$P[1..m]$，<br>其中$m\leqslant n$，进一步假设$P$和$T$的元素都是来自一个有限字母集$\sum$的字符。<br>如果$0\leqslant s \leqslant n-m$，并且$T[s+1..s+m] = P[1..m]$，那么称模式$P$在文本$T$中出现，且偏移为$s$。<br>如果模式$P$在文本$T$中以偏移$s$出现，那么称$s$是有效偏移，否则，称为无效偏移。<br>字符串匹配问题就是找到所有的有效偏移。</p>
</blockquote>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法经常和暴力算法一起提及，是应为KMP算法中多多少少有点暴力的影子，不过其实直接学KMP算法也没什么关系，KMP的主要思想就是减少不必要的操作，优化情况下，其让$P$串匹配的时候，可以保证$T$串只用从头看到后面，不用回去看$T$串中的字符，也就是说对于$T$串只需要每个字符访问一次即可。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>假设我们使用暴力算法找到了部分匹配，即两条<font color=blue>蓝线</font>之间的字符串都是相等的，但是在蓝线后的第一个字符就出现了匹配失败的情况，假设使用暴力算法，那么应该是，$P$串后退一个字符，然后接着从头开始判断。但是这种操作是否最优呢？</p>
<p><img src="/img/kmps1.jpg" alt="kmp_step1"></p>
<p>学习了KMP算法可以得知，<strong>$P$串后退一个字符，然后从头开始判断</strong>，显然<strong>不是最优的</strong>，其实在后退的时候可以一步后退到位，然后继续比较，关于如何后退的思想就是<strong>KMP算法的中心思想</strong>。</p>
<p>进一步思考，就是应该如何确定$P$串<strong>最大后退的个数</strong>?</p>
<ol>
<li>关于匹配问题，首先我们要保证移动后的$P$串在<font color=blue><strong>后面那条蓝线</strong></font>前的字符和$T$串是匹配的。</li>
<li>并且发现移动前的$P$串中也存在匹配的字符<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</li>
<li>于是可以得知在移动前对$P$串的必定存在这样一种状态，<del>从第一个字符开始的一串字符和从最后一个匹配的字符向前的一串字符相等，当然两串的长度都严格小于已匹配的长度</del>，使得<font color=red><strong>两个红色色块</strong></font><sup><a href="#fn_2" id="reffn_2">2</a></sup>相等，并且其长度最长<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</li>
<li>那么就可以得知移动的长度 = 匹配长度 - 最大相等红色块长度，不过实际在KMP算法中只要改变$P$串的比较指针即可<del>，相对运动，指针前移</del>，这样方便的多。</li>
</ol>
<p><img src="/img/kmps2.jpg" alt="kmp_step2"></p>
<p>有了上面的思考，即可发现对$P$串的每一个位置来说，都应该保存失配后移动的下一个位置[4]，通常用一个名为$\ next \ $的数组来保存它们，之后如何求$next$数组也成了实现KMP算法的核心。</p>
<h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><blockquote>
<p>这是具体的算法演示（上面是<strong>文本串</strong>，下面是<strong>模式串</strong>）</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Step. 1</th>
<th style="text-align:center">Step. 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/kmp1.jpg" alt="kmp1"></td>
<td style="text-align:center"><img src="/img/kmp2.jpg" alt="kmp2"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Step. 3</strong></td>
<td style="text-align:center"><strong>Step. 4</strong></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/kmp3.jpg" alt="kmp3"></td>
<td style="text-align:center"><img src="/img/kmp4.jpg" alt="kmp4"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Step. 5</strong></td>
<td style="text-align:center"><strong>Step. 6</strong></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/kmp5.jpg" alt="kmp5"></td>
<td style="text-align:center"><img src="/img/kmp6.jpg" alt="kmp6"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Step. 7</strong></td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/kmp7.jpg" alt="kmp7"></td>
<td style="text-align:center">none</td>
</tr>
</tbody>
</table>
</div>
<h3 id="求-next-数组"><a href="#求-next-数组" class="headerlink" title="求$ \ next \ $数组"></a>求$ \ next \ $数组</h3><p>TODO</p>
<h2 id="KMP模板"><a href="#KMP模板" class="headerlink" title="KMP模板"></a>KMP模板</h2><blockquote>
<p>需要根据题目而改变</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Autor: Mirasire </span></span><br><span class="line"><span class="comment"> * GithubRepo: https://github.com/Mirasire/icpc-train/</span></span><br><span class="line"><span class="comment"> * Tag: KMP</span></span><br><span class="line"><span class="comment"> *----------------------</span></span><br><span class="line"><span class="comment"> * Repetend = n-nxt[n];</span></span><br><span class="line"><span class="comment"> * Repetend's Num = n%Repetend? 1 : n/Repetend;</span></span><br><span class="line"><span class="comment"> * minNum = Repetend-(n%Repetend);</span></span><br><span class="line"><span class="comment"> * --add minNum char to be a Repetended String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,nxt[maxn];</span><br><span class="line"><span class="keyword">char</span> p[maxn],s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNxt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">    nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||p[i]==p[j]) &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            nxt[i]=j;</span><br><span class="line">            <span class="comment">//optimization</span></span><br><span class="line">            <span class="comment">//nxt[i]= (p[i]==p[j])? nxt[j] : j;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    getNxt(m);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    whlie(i&lt;n&amp;&amp;j&lt;m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||t[i]==p[j]) i++,j++;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (j==m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Z函数（extended-KMP）"><a href="#Z函数（extended-KMP）" class="headerlink" title="Z函数（extended-KMP）"></a>Z函数（extended-KMP）</h1><blockquote>
<p>扩展KMP</p>
</blockquote>
<h2 id="Z函数的定义"><a href="#Z函数的定义" class="headerlink" title="Z函数的定义"></a>Z函数的定义</h2><p>对于一个字符串$S$长度为$n$，使得$z[i] \ = \ max(\ z[\textbf{0}..k]=z[i..i+k] \quad k \in [0,n-i] \ )。$</p>
<h2 id="求Z函数的方法"><a href="#求Z函数的方法" class="headerlink" title="求Z函数的方法"></a>求Z函数的方法</h2><blockquote>
<p>求解Z函数的方法是在暴力求解上的改进。<del>虽然我也不知道求解这个有毛用。。。</del></p>
</blockquote>
<h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p><del>暴力就是极致的暴力，17台超算你能秒我？？</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个写法是学习OI-Wiki上的写法，比两个For循环优美了很多。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getZFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;n&amp;&amp;s[i+z[i]]==s[z[i]]) z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力算法就是每次从头开始，开始寻找当前位置($i_{th}$)的$z$函数值，十分显然这个算法的时间复杂度是十分高的$O(n^2)$。</p>
<h3 id="对暴力的优化"><a href="#对暴力的优化" class="headerlink" title="对暴力的优化"></a>对暴力的优化</h3><h2 id="ExKMP模板"><a href="#ExKMP模板" class="headerlink" title="ExKMP模板"></a>ExKMP模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Autor: Mirasire </span></span><br><span class="line"><span class="comment"> * GithubRepo: https://github.com/Mirasire/icpc-train/</span></span><br><span class="line"><span class="comment"> * Tag: Z Algorithm (Extended KMP) </span></span><br><span class="line"><span class="comment"> * ----------------------</span></span><br><span class="line"><span class="comment"> * Example: LuoGu P5410</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e7</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> z[maxn],extd[maxn];</span><br><span class="line"><span class="keyword">char</span> p[maxn],t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getZFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    z[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) z[i]=min(r-i+<span class="number">1</span>,z[i-l]);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;n&amp;&amp;p[z[i]]==p[i+z[i]]) z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r) l=i,r=z[i]+i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getExtd</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    getZFunc(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="comment">//!important! if i&lt;=r will Wrong</span></span><br><span class="line">        <span class="comment">//becase if i&lt;=r when i = 0 it will be not correct</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;r) extd[i]=min(r-i+<span class="number">1</span>,z[i-l]);</span><br><span class="line">        <span class="keyword">while</span>(extd[i]&lt;n&amp;&amp;i+extd[i]&lt;m&amp;&amp;p[extd[i]]==t[i+extd[i]]) extd[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+extd[i]<span class="number">-1</span>&gt;r) l=i,r=extd[i]+i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1kJ411u7pt?from=search&amp;seid=16935681534220022208" target="_blank" rel="noopener"><strong>KMP算法思想讲解</strong></a><br><a href="https://oi-wiki.org/string/z-func/" target="_blank" rel="noopener"><strong>Z函数-OIWiki</strong></a><br><a href="https://item.jd.com/11144230.html" target="_blank" rel="noopener"><strong>《算法导论（原书第三版）》</strong></a></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote>
<p>题目连接 | <a href="https://vjudge.net/article/888" target="_blank" rel="noopener"><strong>HERE</strong></a><br><code>专题十六</code> <strong>HDU171~FZU1901</strong></p>
</blockquote>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><blockquote id="fn_1">
<sup>1</sup>. 即1中$P$串移动后从头到尾匹配的字符。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 两个<font color=red>红色</font>色块可以交叉，并且后面的色块不包括第一个字符串，前面的色块不包含最后一个匹配的字符。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 不是最长的话，会错过一些匹配，因为移动的长度=匹配长度-红色色块长度，不是最长的话移动长度会大大增加，即移过头了。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. 前面一个红色色块的后面的第一个字符的下标。<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>exKMP</tag>
      </tags>
  </entry>
  <entry>
    <title>漫评 - &#39;Charlotte&#39; </title>
    <url>/2020/03/14/CHARLOTTE/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p><strong><em>第一次关于动漫的碎碎念。</em></strong></p>
</blockquote>
<a id="more"></a>
<h1 id="Charlotte"><a href="#Charlotte" class="headerlink" title="Charlotte"></a>Charlotte</h1><p>nihao,shij</p>
<h1 id="最初的嘟哝"><a href="#最初的嘟哝" class="headerlink" title="最初的嘟哝"></a>最初的嘟哝</h1><h1 id="观看地址"><a href="#观看地址" class="headerlink" title="观看地址"></a>观看地址</h1><blockquote>
<p><strong>B站</strong> | <a href="https://www.bilibili.com/bangumi/media/md2572/?from=search&amp;seid=12543069270568003884" target="_blank" rel="noopener"><strong>Charlotte</strong></a></p>
</blockquote>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>关于存在的意义</title>
    <url>/2020/03/12/TK1/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p><strong>我思故我在。</strong></p>
</blockquote>
<a id="more"></a>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>堆学习笔记 - 左式堆</title>
    <url>/2020/01/19/leftListHeap/</url>
    <content><![CDATA[<p>TODO</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag> 左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#607 题解报告</title>
    <url>/2020/01/15/CodeForceR607/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p>CodeForces-Round#607 | <a href="https://codeforces.com/contest/1281/problems" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href=""><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Suffix-Three"><a href="#A-Suffix-Three" class="headerlink" title="A. Suffix Three"></a>A. Suffix Three</h1><p>按照最后一个字母判断，然后输出即可。</p>
<h1 id="B-Azamon-Web-Services"><a href="#B-Azamon-Web-Services" class="headerlink" title="B. Azamon Web Services"></a>B. Azamon Web Services</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有两个字符串$s$和$c$，问能否只交换$s$的一对字符(任意)，使得$s$字典序<strong>严格小于</strong>$c$?</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记 - 3</title>
    <url>/2020/01/13/GIT3/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>Git 学习笔记 - 2</title>
    <url>/2020/01/13/GIT2/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>CodeForces - Hello 2020</title>
    <url>/2019/12/30/Hello2020_CF/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>CodeForces - Good Bye 2019</title>
    <url>/2019/12/30/GoodBye2019_CF/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>CodeForceR610</title>
    <url>/2019/12/30/CodeForceR610/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>CodeForceR608</title>
    <url>/2019/12/30/CodeForceR608/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>CodeForces-Round#606 题解报告</title>
    <url>/2019/12/28/CodeForceR606/</url>
    <content><![CDATA[<p>TODO</p>
<blockquote>
<p>CodeForces-Round#606 | <a href="http://codeforces.com/contest/1277" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Happy-Birthday-Polycarp"><a href="#A-Happy-Birthday-Polycarp" class="headerlink" title="A. Happy Birthday, Polycarp!"></a>A. Happy Birthday, Polycarp!</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h1 id="B-Make-Them-Odd"><a href="#B-Make-Them-Odd" class="headerlink" title="B. Make Them Odd"></a>B. Make Them Odd</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h1 id="C-As-Simple-as-One-and-Two"><a href="#C-As-Simple-as-One-and-Two" class="headerlink" title="C. As Simple as One and Two"></a>C. As Simple as One and Two</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h1 id="D-Let’s-Play-the-Words"><a href="#D-Let’s-Play-the-Words" class="headerlink" title="D. Let’s Play the Words?"></a>D. Let’s Play the Words?</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h1 id="E-Two-Fairs"><a href="#E-Two-Fairs" class="headerlink" title="E. Two Fairs"></a>E. Two Fairs</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational DP Contest</title>
    <url>/2019/12/15/AEDP/</url>
    <content><![CDATA[<p>XXX—连载中—XXX</p>
<p><strong><em>AtCoder DP 教育场</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://atcoder.jp/contests/dp/tasks" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Frog-1"><a href="#A-Frog-1" class="headerlink" title="A. Frog 1"></a>A. Frog 1</h1><p>假设$dp[i]$代表到$i$的最小花费,所以转移状态方程为: </p>
<script type="math/tex; mode=display">
dp[i] = min\{dp[i-1]+|h_i-h_{i-1}|,dp[i-2]+|h_i-h_{i-2}|\}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> h[maxn],dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>,dp[<span class="number">2</span>] = <span class="built_in">abs</span>(h[<span class="number">2</span>]-h[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=N; i++) dp[i] = min(dp[i<span class="number">-2</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-2</span>]),dp[i<span class="number">-1</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-1</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Frog-2"><a href="#B-Frog-2" class="headerlink" title="B. Frog 2"></a>B. Frog 2</h1><p>假设$dp[i]$代表到$i$的最小花费,所以转移状态方程为: </p>
<script type="math/tex; mode=display">
dp[i] = min\{dp[i-k]+|h_i-h_{i-k}|\} \quad k \in [1,K]</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> N,K;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        dp[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=N; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min(k<span class="number">-1</span>,K); i&gt;<span class="number">0</span>; i--) dp[k] = min(dp[k],dp[k-i]+<span class="built_in">abs</span>(arr[k]-arr[k-i]));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Vacation"><a href="#C-Vacation" class="headerlink" title="C. Vacation"></a>C. Vacation</h1><p>$dp[i][j]$ 表示在第$i$天选择$j$的最大收益,所以转移状态方程为:</p>
<script type="math/tex; mode=display">
dp[i][j] = max(arr[i][j] + dp[i-1][k]) \quad k \not= j</script><p>最后输出dp[n][j]中最大的即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn][<span class="number">4</span>],dp[maxn][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,a,b,c,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">1</span>] &gt;&gt; arr[i][<span class="number">2</span>] &gt;&gt; arr[i][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">3</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==j) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][k] = max(dp[i<span class="number">-1</span>][j]+arr[i][k],dp[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(max(dp[n][<span class="number">1</span>],dp[n][<span class="number">2</span>]),dp[n][<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Knapsack-1"><a href="#D-Knapsack-1" class="headerlink" title="D. Knapsack 1"></a>D. Knapsack 1</h1><p>这个是基础的01背包问题。</p>
<p>$dp[j]$表示在背包容量为$j$下的最大收益,因此转移状态方层为:</p>
<script type="math/tex; mode=display">
dp[j] = max(dp[j],dp[j-w[i]]+v[i])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line">ll dp[maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=w[i]; j--) dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Knapsack-2"><a href="#E-Knapsack-2" class="headerlink" title="E. Knapsack 2"></a>E. Knapsack 2</h1><p>01背包的优化，由于$w_i$的范围很大而$v_i$的范围很小，所以考虑取将价值作为$dp$范围。</p>
<p>$dp[j]$表示在价值$j$下所需要的最小背包容量,因此转移转状态方程为:</p>
<script type="math/tex; mode=display">
dp[j] = max(dp[j],dp[j-v[i]]+w[i])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">120</span>;</span><br><span class="line">ll dp[maxn],v[<span class="number">120</span>],w[<span class="number">120</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll N,W,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; W; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++) dp[i] = W+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++) <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=N; i++) &#123;</span><br><span class="line">        <span class="comment">//1e3*100</span></span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1e5</span>+<span class="number">100</span>; j&gt;=v[i]; j--) &#123;</span><br><span class="line">            dp[j] = min(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &lt;= W) ans = max(ans,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-LCS"><a href="#F-LCS" class="headerlink" title="F. LCS"></a>F. LCS</h1><p><strong>最长公共子序列问题 + 打印最长公共子序列</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn],str2[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> len1,len2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][y<span class="number">-1</span>] == dp[x][y]) &#123;</span><br><span class="line">        print(x,y<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp[x<span class="number">-1</span>][y] != dp[x][y]) &#123;</span><br><span class="line">        print(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str2[y<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> print(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %s"</span>,str2);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(len1,len2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G-Longest-Path"><a href="#G-Longest-Path" class="headerlink" title="G. Longest Path"></a>G. Longest Path</h1><p>DAG上的dp，按照<strong>拓扑序列</strong>进行dp即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn],dp[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        head[u].push_back(v);</span><br><span class="line">        in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i]) <span class="built_in">list</span>.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">        now = <span class="built_in">list</span>.front();</span><br><span class="line">        <span class="built_in">list</span>.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;head[now].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = head[now][i];</span><br><span class="line">            <span class="keyword">if</span>(in[u]) &#123;</span><br><span class="line">                dp[u] = max(dp[u],dp[now]+<span class="number">1</span>);</span><br><span class="line">                in[u]--;</span><br><span class="line">                <span class="keyword">if</span>(!in[u]) <span class="built_in">list</span>.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans = max(ans,dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Educational</tag>
        <tag>DP</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>BBTree-Splay</title>
    <url>/2019/12/11/bbtree-splay-ds/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>BBTree-fhqtreap</title>
    <url>/2019/12/11/bbtree-fhqtreap-ds/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>BBTree-avl</title>
    <url>/2019/12/11/bbtree-avl-ds/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>BBTree-tzy</title>
    <url>/2019/12/11/bbtree-tzy/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>动态规划学习笔记-背包问题</title>
    <url>/2019/12/11/PCK-1/</url>
    <content><![CDATA[<blockquote>
<p><strong>背包九讲.pdf</strong> | <a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有$N$个物品，第$i$个物品的价值为$v_i$，体积为$c_i$，每个物品只有一个，选择$k$个物品放到体积为$V$的背包中。</p>
<p><strong>问: 背包的最大价值是多少 ?</strong></p>
<h3 id="解法阐述"><a href="#解法阐述" class="headerlink" title="解法阐述"></a>解法阐述</h3><blockquote>
<p>假设编号从 $1$ 开始</p>
</blockquote>
<p>假设$dp[i][j]$表示 $1 \sim i$ 个物品放入体积为$j$的背包中能得到的最大价值。</p>
<p>考虑$dp[i+1][j]$的由来，可以发现$dp[i+1][j]$实际上就是考虑放和不放第$i+1$个物品，由于要求放入后背包容量为$j$，并且放入$i+1$物品后要求价值要最大，所以我们放入的背包容量为 $j-c_i$ 内，于是得到转移状态方程为:</p>
<script type="math/tex; mode=display">
dp[i+1][j] = max(dp[i][j],dp[i][j-c_i] + v_i)</script><p><strong><em>伪代码如下:</em></strong></p>
<hr>
<script type="math/tex; mode=display">
\begin{aligned}
&\text{01-PACK(N, V)}\\
&1 \quad for \ i \gets 1 \ to \ N \\
&2 \quad  \qquad for \ j \gets c_i \ to \ V \\
&3 \quad  \qquad\qquad dp[i][j] \gets max\{dp[i-1][j],dp[i-1][j-c_i]+v_i\} \\
\end{aligned}</script><hr>
<p>观察上面代码，我们发现每次的 $dp[i][j]$ 的转移只需要用到 $dp[i-1][j]$ 之前的部分，因此我们只要每次从后向前遍历就可以对此的空间复杂度进行优化。</p>
<p><strong><em>优化后的伪代码为:</em></strong></p>
<hr>
<script type="math/tex; mode=display">
\begin{aligned}
&\text{01-PACK(N, V)} \\
&1 \quad for \ i \gets 1 \ to \ N \\
&2 \quad \qquad for \ j \gets V \ to \ c_i \\
&3 \quad \qquad\qquad dp[j] \gets max\{dp[j],dp[j-c_i]+v_i\} \\
\end{aligned}</script><hr>
<p>TODO</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>我们十分容易的发现时间复杂度为 $O(NV)$</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>AtCoder</strong></td>
<td style="text-align:left"><a href="https://atcoder.jp/contests/dp/tasks/dp_a" target="_blank" rel="noopener"><code>Frog 1</code></a> · <a href="https://atcoder.jp/contests/abc147/tasks/abc147_e" target="_blank" rel="noopener"><code>Blanced Path</code></a> · <a href="https://atcoder.jp/contests/dp/tasks/dp_b" target="_blank" rel="noopener"><code>Frog 2</code></a> · <a href="https://atcoder.jp/contests/dp/tasks/dp_c" target="_blank" rel="noopener"><code>Vacation</code></a> · <a href="https://atcoder.jp/contests/dp/tasks/dp_d" target="_blank" rel="noopener"><code>Knapsack 1</code></a></td>
</tr>
<tr>
<td style="text-align:left"><strong>Kuangbin</strong></td>
<td style="text-align:left"><a href=""><code>...</code></a></td>
</tr>
<tr>
<td style="text-align:left"><strong>LuoGu</strong></td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P1048" target="_blank" rel="noopener"><code>P1048</code></a> · <a href=""><code>...</code></a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener"><strong>背包九讲-崔添翼</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>DP</tag>
        <tag>Algorithm</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1542</title>
    <url>/2019/11/15/HDU1542/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HDU1255</title>
    <url>/2019/11/15/HDU1255/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
  <entry>
    <title>POJ1177</title>
    <url>/2019/11/15/POJ1177/</url>
    <content><![CDATA[<p>TODO</p>]]></content>
  </entry>
</search>
