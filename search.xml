<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「CSAPP学习笔记」 Data Lab</title>
    <url>/2020/10/24/csappdatalab/</url>
    <content><![CDATA[<p>观看《深入了解计算机系统》(CSAPP) 和 CMU15213 后的笔记，与做$\text{Data Lab}$时遇到的困难与解答。</p>
<a id="more"></a>
<blockquote>
<p>书本 |《深入了解计算机系统》<br>网课地址<sup><a href="#fn_0" id="reffn_0">0</a></sup> | <a href="https://www.bilibili.com/video/av12977597" target="_blank" rel="noopener"><strong>Here</strong></a><br>Labs地址<sup><a href="#fn_1" id="reffn_1">1</a></sup> | <a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<h1 id="text-Bits-ints-and-float"><a href="#text-Bits-ints-and-float" class="headerlink" title="$\text{Bits, ints and float}$"></a>$\text{Bits, ints and float}$</h1><p>$\text{Data Lab}$ 主要用于加深了我对数字 在计算机中的<strong>编码($\text{encoding}$)表示</strong> 的印象，以及一些位($\text{bit}$)级别的转换和计算操作，帮助我更好的理解了，二进制中数字的表示和处理，所以笔记侧重记录于 <strong>二进制编码</strong> 与 <strong>用二进制的方式看待计算</strong>。</p>
<h2 id="text-Bits-amp-Ints"><a href="#text-Bits-amp-Ints" class="headerlink" title="$\text{Bits &amp; Ints}$"></a>$\text{Bits &amp; Ints}$</h2><h3 id="无符号编码"><a href="#无符号编码" class="headerlink" title="无符号编码"></a>无符号编码</h3><blockquote>
<p>$\text{Unsigned Encoding}$</p>
</blockquote>
<p>$\text{B2U(X) = } \sum_{i \leq 0}^{n}{X_i * 2^i}$</p>
<h3 id="二进制补码编码"><a href="#二进制补码编码" class="headerlink" title="二进制补码编码"></a>二进制补码编码</h3><blockquote>
<p>$\text{Two’s-Complement Encoding}$</p>
</blockquote>
<p>$\text{B2T(X) = } -X_w * 2^n + \sum_{i \leq 0}^{n-1}{X_i} \qquad (X_w = \text{sign bit})$</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\text{And}$</th>
<th style="text-align:center">$\text{Or}$</th>
<th style="text-align:center">$\text{Not}$</th>
<th style="text-align:center">$\text{Xor}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_14.png" alt="and_ba"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_15.png" alt="or_ba"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_16.png" alt="Not_ba"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_17.png" alt="xor_ba"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>实例如下</p>
</blockquote>
<p><img src="/img/csapp_datalab_19.png" alt="tmp_ba"></p>
<h3 id="一些杂记"><a href="#一些杂记" class="headerlink" title="一些杂记"></a>一些杂记</h3><ul>
<li>$\text{Unsigned}$<ul>
<li>$U_{max} = \text{0xFFFFFFFF} = 2^{32}-1$</li>
<li>$U_{min} = 0$</li>
</ul>
</li>
<li>$\text{Two’s-Complement}$<ul>
<li>$T_{min} = 10000… = \text{0x80000000}$</li>
<li>$T_{max} = 01111… = \text{0x7FFFFFFF}$</li>
<li>$T_{min} = -T_{max}-1$</li>
<li>$abs(T_{min}) = T_{min}$ <code>overflow</code> </li>
<li>$\text{0xFFFFFFFF} = -1$</li>
</ul>
</li>
<li>$\text{U2T  &amp;  T2U}$<ul>
<li>$U_{max} = T_{max} \ll 1 + 1$</li>
</ul>
</li>
<li>位扩展($\text{Sign Extension}$)<ul>
<li>扩展k位 = 向右<strong>复制k位符号位</strong></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">理论公式</th>
<th style="text-align:center">正数位扩展</th>
<th style="text-align:center">负数位扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_11.png" alt="sign extension"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_12.png" alt="po_sex"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_13.png" alt="neg_sex"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>&gt;&gt;</code> 右移 ($\text{Right shift}$)<ul>
<li>逻辑右移($\text{Logical shift}$)<ul>
<li><strong>特点：左侧都填充 <code>0</code></strong></li>
</ul>
</li>
<li>算数右移($\text{Arithmetic shift}$)<ul>
<li><strong>特点：左侧都填充的为 <code>符号位</code></strong></li>
<li><strong>C语言默认为算数右移</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="text-Float-2"><a href="#text-Float-2" class="headerlink" title="$\text{Float}$2"></a>$\text{Float}$<sup><a href="#fn_2" id="reffn_2">2</a></sup></h2><h3 id="用二进制表示小数"><a href="#用二进制表示小数" class="headerlink" title="用二进制表示小数"></a>用二进制表示小数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表示</th>
<th style="text-align:center">$b_i$</th>
<th style="text-align:center">$b_{i-1}$</th>
<th style="text-align:center">…</th>
<th style="text-align:center">$b_2$</th>
<th style="text-align:center">$b_1$</th>
<th style="text-align:center">$b_0$</th>
<th style="text-align:center"><strong>.</strong></th>
<th style="text-align:center">$b_{-1}$</th>
<th style="text-align:center">$b_{-2}$</th>
<th style="text-align:center">$b_{-3}$</th>
<th style="text-align:center">…</th>
<th style="text-align:center">$b_{-j}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">权值</td>
<td style="text-align:center">$2^{i}$</td>
<td style="text-align:center">$2^{i-1}$</td>
<td style="text-align:center">…</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">.</td>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">$\frac{1}{4}$</td>
<td style="text-align:center">$\frac{1}{8}$</td>
<td style="text-align:center">…</td>
<td style="text-align:center">$2^{-j}$</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>例子:</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
(10.101)_2 &= 1 \times 2^1 + 1 \times 2^{-1} + 1 \times 2^{-3} \\
&= 2+0.5+0.125 \\
&= (2.625)_{10}
\end{aligned}</script><h3 id="text-IEEE-Standard-754"><a href="#text-IEEE-Standard-754" class="headerlink" title="$\text{IEEE  Standard  754}$"></a>$\text{IEEE  Standard  754}$</h3><blockquote>
<p><strong><u>有意思</u></strong> 的是使用IEEE754标准，来编码的时候会出现 <code>+0</code> 和 <code>-0</code></p>
</blockquote>
<p>由于直接使用二进制表示小数的范围十分有限，所以 <code>C语言</code> 采用了 IEE754 标准来对浮点数($\text{Float}$)进行编码，来表示小数。</p>
<p>浮点数的数学表示形式为 $\text{Float} = {(-1)^s}{M}{2^E}$，其中$M$表示尾数($Mantissa$)<sup><a href="#fn_4" id="reffn_4">4</a></sup>，$E$表示指数($Exponent$)，$s$表示符号，含义同二进制补码中的符号位($sign \ bit$)。</p>
<blockquote>
<p>二进制例子:</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
(1011.11111)_2 &= {(-1)^0}*{1.01111111}*{2^3} \\
(-11011.11111)_2 &= {(-1)^1}*{1.101111111}*{2^4}
\end{aligned}</script><p><strong>编码($\text{Encoding}$)</strong></p>
<ul>
<li>$\text{s = S}$</li>
<li>$\text{E = exp - bias or 1 - bias}$<sup><a href="#fn_5" id="reffn_5">5</a></sup><ul>
<li>$\text{bias}$<sup><a href="#fn_6" id="reffn_6">6</a></sup> $ \ = 2^{sizeof(exp)-1}-1$ </li>
<li>32位的 $\text{bias}$ 为 127</li>
<li>64位的 $\text{bias}$ 为 1023</li>
</ul>
</li>
<li>$\text{frac = M}$</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">32位</th>
<th style="text-align:center">64位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_04.png" alt="32_fencoding"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_05.png" alt="64_fencoding"></td>
</tr>
</tbody>
</table>
</div>
<hr>
<blockquote>
<p>根据 <strong>exp</strong> 的不同，我们被编码的值分为 <strong>三种</strong> 情况。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">exp</th>
<th style="text-align:center">皆为0</th>
<th style="text-align:center">既有0，又有1</th>
<th style="text-align:center">皆为1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\text{Values}$</td>
<td style="text-align:center">$\text{Denormalized}$</td>
<td style="text-align:center">$\text{Normalized}$</td>
<td style="text-align:center">$\text{Special}$</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<ul>
<li>$\text{s}$ 的计算方法<ul>
<li><strong>正数</strong> = 0</li>
<li><strong>负数</strong> = 1</li>
</ul>
</li>
</ul>
<h4 id="规格化-text-Normalized"><a href="#规格化-text-Normalized" class="headerlink" title="规格化($\text{Normalized}$)"></a>规格化($\text{Normalized}$)</h4><ul>
<li>$\text{frac}$ 的 计算方法。<ul>
<li><strong>即</strong> 需要将 $(11111.11011)_{2} \rightarrow {(1.111111011)_{2}}*{2^4}$，即将 $\text{1xxxx.xxxx} \rightarrow \text{1.xxxxxxx}*{2^n}$。</li>
<li>$\text{frac = xxxxxx…} \leftarrow$ 指 <code>1.xxxxx</code> 中的 <code>.xxxxx</code>。</li>
<li><strong>当然，只取 23/54 位数。</strong> 这就是为什么 浮点数不准的原因(并不是所有十进制小数都能 <code>完美/有限</code> 转化为二进制)。</li>
</ul>
</li>
<li>$\text{E = exp - bias}$</li>
<li>值 $ = (-1)^s*{1. \text{frac}}*{2^{exp-127}}$</li>
</ul>
<h4 id="非规格化-text-Denormalized"><a href="#非规格化-text-Denormalized" class="headerlink" title="非规格化($\text{Denormalized}$)"></a>非规格化($\text{Denormalized}$)</h4><blockquote>
<p>$\text{exp}$ 全都为 0 的情况<br>非规格化即为对 $\text{0.xxxxxx}$ 进行编码</p>
</blockquote>
<ul>
<li>$\text{E = 1 - bias = 127}$</li>
<li>$\text{frac = xxxxxx…} \leftarrow$ 指 <code>0.xxxxx</code> 中的 <code>.xxxxx</code>。</li>
<li>$\text{exp = 0}$</li>
<li>值 $= (-1)^s*{0. \text{frac}}*{2^{-126}}$</li>
</ul>
<h4 id="特殊值-text-Special"><a href="#特殊值-text-Special" class="headerlink" title="特殊值($\text{Special}$)"></a>特殊值($\text{Special}$)</h4><blockquote>
<p>$\text{exp}$ <strong>全为0</strong></p>
</blockquote>
<ul>
<li>$\infty \text{(Infinity)}$<ul>
<li>$\text{frac}$ 全为0</li>
<li>$\text{s = 0} \rightarrow +\infty$</li>
<li>$\text{s = 1} \rightarrow -\infty$</li>
</ul>
</li>
<li>$\text{Not-a-Number(NAN)}$<ul>
<li>$\text{frac}$ 不全为0</li>
</ul>
</li>
</ul>
<h3 id="舍入-text-Rounding"><a href="#舍入-text-Rounding" class="headerlink" title="舍入($\text{Rounding}$)"></a>舍入($\text{Rounding}$)</h3><blockquote>
<p>其他舍入方法详见 《CSAPP》 <del>其余舍入方式都很好理解</del></p>
</blockquote>
<p>IEEE754标准的默认取舍方式是 <em>向偶数舍入</em>($\text{round to even}$)，也称 <em>向最近舍入</em>($\text{round to the neartest}$)。<br>这种舍入方式的方式是 只有在被取舍部分为，当前的 <strong>中间值</strong> 时，向保留位的最近偶数位舍入，其余状况按照正常的’四舍五入’。</p>
<blockquote>
<p><strong>举个例子</strong><sup><a href="#fn_3" id="reffn_3">3</a></sup></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_03.png" alt="d_nround"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_02.png" alt="b_nround"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="一些杂记-1"><a href="#一些杂记-1" class="headerlink" title="一些杂记"></a>一些杂记</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">乘法($\text{Multipcation}$)</th>
<th style="text-align:center">加法($\text{Addition}$)</th>
<th style="text-align:center">加法的解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_20.png" alt="mul_fl"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_21.png" alt="add_fl"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_22.png" alt="add2_fl"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="text-Data-Lab"><a href="#text-Data-Lab" class="headerlink" title="$\text{Data Lab}$"></a>$\text{Data Lab}$</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><img src="/img/csapp_datalab_01.png" alt="The Puzzles"></p>
<h3 id="text-datalab-handout"><a href="#text-datalab-handout" class="headerlink" title="$\text{datalab-handout}$"></a>$\text{datalab-handout}$</h3><blockquote>
<p>右上角带星号(*) 的 为可执行文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Makefile	- Makes btest, fshow, and ishow</span><br><span class="line">README		- Data Lab的介绍和使用</span><br><span class="line">bits.c		- 所有Puzzels所在的文件，即要补全的文件</span><br><span class="line">bits.h		- 头文件</span><br><span class="line">btest.c		- btest* 的源文件，详情可见Makefile</span><br><span class="line">  btest.h	- 用于编译btest</span><br><span class="line">  decl.c	- 用于编译btest</span><br><span class="line">  tests.c       - 用于编译btest</span><br><span class="line">  tests-header.c- 用于编译btest</span><br><span class="line">dlc*		- 用于检查 bits.c 是否规则 (注意: btest 不会检查规则)</span><br><span class="line">driver.pl*	- 用于自动打分，调用了 dlc+btest</span><br><span class="line">Driverhdrs.pm   - &quot;Beat the Prof&quot; 模式的头文件(可选，详见REAME)</span><br><span class="line">fshow.c		- 查看 Float 表示的工具的源代码</span><br><span class="line">ishow.c		- 查看 Int 表示的工具的源代码</span><br></pre></td></tr></table></figure>
<h3 id="自测-使用工具"><a href="#自测-使用工具" class="headerlink" title="自测/使用工具"></a>自测/使用工具</h3><h4 id="text-dlc-btest-driver-pl"><a href="#text-dlc-btest-driver-pl" class="headerlink" title="$\text{dlc/btest/driver.pl}$"></a>$\text{dlc/btest/driver.pl}$</h4><blockquote>
<p>温馨提示: 若 <code>drivel.pl</code> 和 <code>btest</code> 结果不符，可以调用 <code>dlc</code> 来检测是否 <code>bits.c</code> 合规。</p>
</blockquote>
<p><strong>$\text{dlc}$使用指南</strong></p>
<p><code>dlc</code> 用于检测 <code>bits.c</code> 是否符合 规则限制，若不符合规则，则会报错。<del>一切合规的话，就什么不会返回。</del> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检测是否符合规则</span></span><br><span class="line">./dlc bit.c</span><br></pre></td></tr></table></figure>
<p>也可以添加 <code>-e</code> 选项，来显示每个函数所用的 <strong>操作符的个数</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示操作符个数</span></span><br><span class="line">./dlc -e bits.c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用例子</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">合规</th>
<th style="text-align:center">不合规</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_06.png" alt="dlc_ok"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_07.png" alt="dlc_nok"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>$\text{btest}$使用指南</strong></p>
<blockquote>
<p>注: <code>btest</code> 并不会检测 <code>bits.c</code> 是否符合规则。</p>
</blockquote>
<p>使用<code>make</code> 来编译 <code>btest*</code>，详情的编译命令，在同目录下的 <code>Makefile</code> 中。编译成功后生成<code>btest*</code>，运行<code>btest*</code>即可测试函数正确性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译 btest*</span></span><br><span class="line">make btest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 bits.c</span></span><br><span class="line">./btest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 btest 帮助</span></span><br><span class="line">./btest -h</span><br></pre></td></tr></table></figure>
<p>由于 <code>btest*</code> 不会随着 <code>bits.c</code> 文件的更改而自动更改，所以当你修改了<code>bits.c</code>时，需要对<code>btest*</code>进行重新编译，来使得更改生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理之前编译产生的中间文件</span></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新编译</span></span><br><span class="line">make btest</span><br></pre></td></tr></table></figure>
<p><strong>$\text{drivel.pl}$使用指南</strong></p>
<p><code>drivel.pl</code> 的作用，约等于是 <code>dlc</code> + <code>btest</code>，但是不会提示错误信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行自动打分程序</span></span><br><span class="line">./drivel.pl</span><br></pre></td></tr></table></figure>
<h4 id="text-ishow-fshow"><a href="#text-ishow-fshow" class="headerlink" title="$\text{ishow/fshow}$"></a>$\text{ishow/fshow}$</h4><blockquote>
<p><code>ishow</code> 和 <code>fshow</code> 是一个很好的辅助工具，用来帮助理解 <code>数字</code> 在 计算机中的 <strong>编码</strong>。</p>
</blockquote>
<p>可以使用<code>make</code>进行单独编译，也可以直接一次性全编译。(<code>btest</code>+<code>ishow</code>+<code>fshow</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一次性全编译 btest + ishow + fshow</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独编译 ishow (fshow同理)</span></span><br><span class="line">make ishow</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用案例:</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\text{ishow}$</th>
<th style="text-align:center">$\text{fshow}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/csapp_datalab_09.png" alt="ishow"></td>
<td style="text-align:center"><img src="/img/csapp_datalab_10.png" alt="fshow"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="规则描述8"><a href="#规则描述8" class="headerlink" title="规则描述8"></a>规则描述<sup><a href="#fn_8" id="reffn_8">8</a></sup></h3><blockquote>
<p>具体的函数会有具体的限定，此处只是综述。</p>
</blockquote>
<h4 id="text-Int-规则"><a href="#text-Int-规则" class="headerlink" title="$\text{Int}$ 规则"></a>$\text{Int}$ 规则</h4><p>你的代码风格，可以参考如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Funct</span><span class="params">(arg1, arg2, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* brief description of how your implementation works */</span></span><br><span class="line">    <span class="keyword">int</span> var1 = Expr1;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> varM = ExprM;</span><br><span class="line"></span><br><span class="line">    varJ = ExprJ;</span><br><span class="line">    ...</span><br><span class="line">    varN = ExprN;</span><br><span class="line">    <span class="keyword">return</span> ExprR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>Expr</code>表达式 <strong>仅允许使用：</strong></p>
<ol>
<li>0~255 (0xFF) 范围内的Int常量，包括0和255。(像 0xffffffff 此类的大常量不能使用)</li>
<li>函数所传入的变量，和函数内参数。(不能使用全局变量)</li>
<li>三元运算符 <code>~</code> 和 <code>!</code></li>
<li>位运算符 <code>&amp;</code>、<code>^</code>、<code>|</code>、<code>+</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code></li>
</ol>
<p><strong>禁止使用：</strong></p>
<ol>
<li>所有的控制结构，例 <code>if</code>, <code>do</code>, <code>while</code>….</li>
<li>定义任何 <strong>宏</strong>。 (即预处理)</li>
<li>在<code>bits.c</code> 中新增函数。（你只能填空，不能自定义新函数）</li>
<li>调用函数</li>
<li>使用其他运算符，例 <code>&amp;&amp;</code>，<code>||</code>，<code>-</code> 或者 <code>? :</code></li>
<li><strong>使用类型转化</strong> (隐式也不行)</li>
<li>使用除了 <code>int</code> 以外的其他数据结构，例 <code>arrays</code>，<code>structs</code>，<code>unions</code>….</li>
</ol>
<p><strong>检查你的机器：</strong></p>
<ol>
<li>确认你的机器使用 <code>补码</code> 来表示 32位的 <code>int</code>。</li>
<li><code>&gt;&gt;</code> 操作是使用 <strong>算术右移</strong>。</li>
<li>确认 <code>&lt;&lt;</code> 小于0 和 <code>&gt;&gt;</code>大于31 的行为是不可预测的。</li>
</ol>
<h4 id="text-Float-规则"><a href="#text-Float-规则" class="headerlink" title="$\text{Float}$ 规则"></a>$\text{Float}$ 规则</h4><p><strong>禁止使用：</strong></p>
<ol>
<li>定义任何 <strong>宏</strong>。 (即预处理)</li>
<li>在<code>bits.c</code> 中新增函数。（你只能填空，不能自定义新函数）</li>
<li>调用函数<br>4.<strong>使用类型转化</strong> (隐式也不行)</li>
<li>使用除了 <code>int</code>和<code>unsigned</code> 以外的其他数据结构，例 <code>arrays</code>，<code>structs</code>，<code>unions</code>….</li>
<li>使用任何浮点指针数据类型，运算符 或 常量。</li>
</ol>
<hr>
<h2 id="text-Puzzles-笔记"><a href="#text-Puzzles-笔记" class="headerlink" title="$\text{Puzzles}$ 笔记"></a>$\text{Puzzles}$ 笔记</h2><h3 id="text-bitXor"><a href="#text-bitXor" class="headerlink" title="$\text{bitXor}$"></a>$\text{bitXor}$</h3><p><strong>思路：</strong></p>
<p>$\textbf{xor}$ 为 <code>同0，异1</code>，<code>a&amp;b</code>只会保留 <strong>全为1</strong> 的，而 <code>(~a)&amp;b</code> 只会保留 <code>a0/b1</code> 的，所以答案是 <code>a0/b1 | a1/b0</code>，那么只要用 <code>&amp;</code> 和 <code>~</code> 来复现 <code>|</code> 即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = (~x) &amp; y;</span><br><span class="line">    <span class="keyword">int</span> var2 = x &amp; (~y);</span><br><span class="line">    <span class="keyword">return</span> ~((~var1)&amp;(~var2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-tmin"><a href="#text-tmin" class="headerlink" title="$\text{tmin}$"></a>$\text{tmin}$</h3><p><strong>思路：</strong></p>
<p>显然补码的 $T_{min} \text{ = 0x80000000}$</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-isTmax"><a href="#text-isTmax" class="headerlink" title="$\text{isTmax}$"></a>$\text{isTmax}$</h3><p><strong>思路：</strong></p>
<p>补码中有两个数很特殊, 0 和 $T_{min}$，这两个数的<code>~</code>后<code>+1</code>皆为本身(后者是溢出，前者是排除 $\pm$ 0)。<br>思路就是使用这个特性(利用<code>^</code>)，后排除<code>x=0</code>的可能情况即可。</p>
<p>$T_{min} \text{ = } \sim T_{max}$</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = ~x;</span><br><span class="line">    <span class="keyword">int</span> var2 = x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> !((var1^var2)|(!var1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-allOddbits"><a href="#text-allOddbits" class="headerlink" title="$\text{allOddbits}$"></a>$\text{allOddbits}$</h3><p><strong>思路：</strong></p>
<p>一直对半<code>|</code>即可，由于是偶数位，所以最后判断的是倒数第二位(即需要 <code>&gt;&gt;1</code>)。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = (x &gt;&gt; <span class="number">16</span>) &amp; x;</span><br><span class="line">    <span class="keyword">int</span> var2 = (var1 &gt;&gt; <span class="number">8</span>) &amp; var1;</span><br><span class="line">    <span class="keyword">int</span> var3 = (var2 &gt;&gt; <span class="number">4</span>) &amp; var2;</span><br><span class="line">    <span class="keyword">int</span> var4 = (var3 &gt;&gt; <span class="number">2</span>) &amp; var3;</span><br><span class="line">    <span class="keyword">return</span> (var4&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-negate"><a href="#text-negate" class="headerlink" title="$\text{negate}$"></a>$\text{negate}$</h3><p><strong>思路：</strong></p>
<p>在 CMU15213 的网课中有提及。</p>
<blockquote>
<p><del>负数的补码就是源码取反+1</del></p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-isAsciiDigit"><a href="#text-isAsciiDigit" class="headerlink" title="$\text{isAsciiDigit}$"></a>$\text{isAsciiDigit}$</h3><p><strong>思路：</strong></p>
<p>先判断是否是<code>0x30</code>，然后判断是否在 <code>0x0</code> ~ <code>0x9</code> 之间。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = !(x &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> var2 = (x + <span class="number">0x10</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> var3 = x &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> var4 = (x &gt;&gt; <span class="number">2</span>) | (x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    var2 = var1 &amp; var2;</span><br><span class="line">    var4 = var3 &amp; var4;</span><br><span class="line">	<span class="keyword">return</span> var2 &amp; (~var4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-conditional"><a href="#text-conditional" class="headerlink" title="$\text{conditional}$"></a>$\text{conditional}$</h3><p><strong>思路：</strong></p>
<p>利用 <code>xor</code> 中 $ x \oplus 0 = x$ 和 $x \oplus x = 0$ 的特性进行实现。</p>
<p>所以可以得到一个表达式 $\text{ans = exp1^y^x^exp2}$，和下述表格。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">exp1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">exp2</td>
<td style="text-align:center">y</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>用位运算实现上述表格中的 <code>exp</code> 即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = !x;</span><br><span class="line">    <span class="keyword">int</span> var2 = (~var1) + <span class="number">1</span>;</span><br><span class="line">    var1 = ~var2;</span><br><span class="line">    <span class="keyword">return</span> (var2&amp;y)^y^z^(var1&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-isLessOrEqual"><a href="#text-isLessOrEqual" class="headerlink" title="$\text{isLessOrEqual}$"></a>$\text{isLessOrEqual}$</h3><p><strong>思路：</strong></p>
<p>分类讨论三种情况，分别为<code>同号</code>，<code>异号</code>，<code>相等</code>。<br>如果不考虑溢出(即<code>同号</code>情况)，显然$x-y \leq 0$。</p>
<blockquote>
<p>小提示：由于当 y = $T_{min}$ 时，转化为 -y 会溢出，但是如果限定为同号，则不会对判断造成影响。</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> var2 = y&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> var3 = !(x^y); <span class="comment">//x == y</span></span><br><span class="line">    <span class="keyword">int</span> var4 = (~y)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> var5 = ((x+var4)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>; <span class="comment">//x-y &lt; 0</span></span><br><span class="line">    <span class="keyword">int</span> var7 = (var1^var2)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> var8 = var7&amp;var1; <span class="comment">//1 when x&lt;0 + y&gt;0</span></span><br><span class="line">    <span class="keyword">int</span> var9 = !(var7&amp;var2); <span class="comment">//0 when x&gt;0 + y&lt;0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (var8|var3|var5)&amp;var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-logicalNeg"><a href="#text-logicalNeg" class="headerlink" title="$\text{logicalNeg}$"></a>$\text{logicalNeg}$</h3><p><strong>思路：</strong></p>
<p>思路和 <code>isTmax</code> 相同，只有0的补码<code>^</code>源码 <code>= 0</code>，其余 <strong>最高位</strong> 都为<code>1</code>。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = (~x)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> var2 = ((x&gt;&gt;<span class="number">31</span>)|(var1&gt;&gt;<span class="number">31</span>))&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (~var2)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-howManyBits"><a href="#text-howManyBits" class="headerlink" title="$\text{howManyBits}$"></a>$\text{howManyBits}$</h3><p><strong>思路：</strong></p>
<blockquote>
<p>这边使用<code>^</code>是一个很有意思的小技巧。</p>
</blockquote>
<p>只有<code>0/1</code>所需要的位数是1位，其余答案是<code>n+1</code>，<code>n</code>指从右向左第<code>n</code>位，从左向右第一个 <code>1或0</code><sup><a href="#fn_7" id="reffn_7">7</a></sup> 的数字。</p>
<p><strong>二分</strong>寻找第一次出现的位置，<strong>每次二分移动的长度，刚好为需要加入答案的长度。</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = x^(x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> s16 = (!!(var&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b16 = var &gt;&gt; s16;</span><br><span class="line">    <span class="keyword">int</span> s8 = (!!(b16&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b8 = b16 &gt;&gt; s8 &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> s4 = (!!(b8&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b4 = b8 &gt;&gt; s4 &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">int</span> s2 = (!!(b4&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b2 = b4 &gt;&gt; s2 &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> s1 = !!(b2&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s16 + s8 + s4 + s2 + s1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-floatScale2"><a href="#text-floatScale2" class="headerlink" title="$\text{floatScale2}$"></a>$\text{floatScale2}$</h3><p><strong>思路：</strong></p>
<blockquote>
<p>对 $\text{uf}$ 进行分类讨论操作。</p>
</blockquote>
<ul>
<li>如果是 $\text{uf = NAN}$ 就直接返回 $\text{uf}$。</li>
<li>如果是 $\text{Denormalized}$，直接将$\text{frac}$ 向右移1即可，因为$\text{Denormalized}$和$\text{Normalized}$之间有完美的过度。</li>
<li>如果是 $\text{Normalized}$。<ul>
<li>若溢出，则返回 $\text{inf}$ (注意符号)</li>
<li>否，则正常编码返回即可。</li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> uf_s = uf&amp;<span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> uf_exp = (uf&gt;&gt;<span class="number">23</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> uf_frac = uf&amp;<span class="number">0x007fffff</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> res;</span><br><span class="line">    <span class="keyword">if</span>(uf_exp == <span class="number">0xff</span> &amp;&amp; uf_frac != <span class="number">0</span>) res = uf^uf_s;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(uf_exp == <span class="number">0</span>) res = uf&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> res_exp = uf_exp+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res_exp &gt; <span class="number">0xff</span>) res = <span class="number">0x7f800000</span>; </span><br><span class="line">        <span class="keyword">else</span> res = (res_exp &lt;&lt; <span class="number">23</span>)|uf_frac;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res^uf_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-floatFloat2int"><a href="#text-floatFloat2int" class="headerlink" title="$\text{floatFloat2int}$"></a>$\text{floatFloat2int}$</h3><p><strong>思路：</strong></p>
<p>按照 $\text{IEEE754}$ 标准来解码即可。</p>
<ul>
<li>$\text{Denormalized}$ 情况下即返回 <strong>0</strong>。</li>
<li>$\text{Nan &amp;&amp; Inf}$ 返回 <code>0x80000000</code> (即$T_{min}$)。</li>
<li>$\text{Normalized}$  情况下。<ul>
<li>超出 $\text{Int}$ 表示范围，返回<code>0x80000000</code>。</li>
<li>其余正常返回即可。</li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uf_s = !!(uf&gt;&gt;<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> uf_E = ((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) - <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> uf_frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x008fffff</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(uf_E &lt; <span class="number">0</span>) res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> right_shift = -(<span class="number">23</span>-uf_E);</span><br><span class="line">        <span class="keyword">if</span>(right_shift &gt; <span class="number">7</span>) res = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right_shift &lt; <span class="number">0</span>) res = uf_frac &gt;&gt; (-right_shift);</span><br><span class="line">        <span class="keyword">else</span> res = uf_frac &lt;&lt; right_shift;</span><br><span class="line">        <span class="keyword">if</span>(uf_s) res = (~res)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="text-floatPower2"><a href="#text-floatPower2" class="headerlink" title="$\text{floatPower2}$"></a>$\text{floatPower2}$</h3><script type="math/tex; mode=display">
{(2)_{10}}^x = {(-1)^0}*{(1)_2}*{2^{1+x}}</script><p>按照$\text{IEEE754}$标准编码即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> inf = <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">255</span>) res = inf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &lt; <span class="number">0</span>) res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> res = <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="text-Self-Evaluate"><a href="#text-Self-Evaluate" class="headerlink" title="$\text{Self Evaluate}$"></a>$\text{Self Evaluate}$</h2><blockquote>
<p>以下为使用 drivel.pl 对上述解答的打分截图</p>
</blockquote>
<p><img src="/img/csapp_datalab_done.png" alt="done"></p>
<hr>
<blockquote id="fn_0">
<sup>0</sup>. 课程为CMU15213，来源 Bilibili<a href="#reffn_0" title="Jump back to footnote [0] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_1">
<sup>1</sup>. CSAPP书本官网，此次为 Data Lab<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. IEE754标准，并不是所有CPU都支持，例如 Cell BE<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. CMU15213课件 “04-float.pdf”<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. 尾数的范围 $[1.0 ,2.0)$<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. 当exp全为0时，E = 1 - bias<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. bias 即 偏移量<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. 负数为0，正数为1<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. 详细可见 <code>datalab-handout/bits.c</code><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>CMU CS:APP</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>notes</tag>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>进行Hexo博客的迁移</title>
    <url>/2020/04/07/HEXO2/</url>
    <content><![CDATA[<p>对<strong>Hexo</strong>的博客进行<strong>迁移</strong>。</p>
<a id="more"></a>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一不小心把Ubuntu系统给⛏崩了…..，<del>这边不是指没了图形界面，是真的开机直接卡死，切换不了tty…</del>，然后重装的U盘在宿舍，因为该死的COVID19，最近也回不去，<strong>重装也就暂时不可行了</strong>。开始十分的自闭，就完全不想在win下写博客，有点不太习惯，<del>之前用vim，所有snippets都丢了，十分不适应</del>，后来发现vscode也蛮赞的，而且之前我瞎搞乱搞的时候，给博客整了个大备份，于是就又在win上试了试，看看能不能部署成功，不过也踩了一些坑，于是便记录下，以便后续的博客迁移操作。</p>
<h1 id="迁移后的结果展示"><a href="#迁移后的结果展示" class="headerlink" title="迁移后的结果展示"></a>迁移后的结果展示</h1><p><img src="/img/hexo2show.jpg" alt="show"></p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><blockquote>
<p>以下仅代表个人解决办法，并非最优解。</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote>
<p>迁移前的环境 → 迁移后的环境<br>系统: Ubuntu 18.04.3 LTS → Windows 10<br>Node.js版本: v12.12.0 → v12.16.1<br>npm版本: 6.11.3 → 6.13.4</p>
</blockquote>
<h2 id="在前一个环境的准备"><a href="#在前一个环境的准备" class="headerlink" title="在前一个环境的准备"></a>在前一个环境的准备</h2><p>在github中新建一个仓库，clone到本地，之后在原来目录中删除所有与git配置相关的文件并将所有文件复制到clone下来的仓库中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除所有与git相关的文件。</span></span><br><span class="line">find . -name <span class="string">".git*"</span> -<span class="built_in">exec</span> rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>之后push到github即可这就完成了备份。</p>
<h2 id="在Win10下的环境配置"><a href="#在Win10下的环境配置" class="headerlink" title="在Win10下的环境配置"></a>在Win10下的环境配置</h2><h3 id="下载Node-js"><a href="#下载Node-js" class="headerlink" title="下载Node.js"></a>下载Node.js</h3><p>官网下载安装即可 | <a href="https://nodejs.org/en/" target="_blank" rel="noopener"><strong>LINK</strong></a>。</p>
<h3 id="途中出现的github的问题"><a href="#途中出现的github的问题" class="headerlink" title="途中出现的github的问题"></a>途中出现的github的问题</h3><blockquote>
<p>使用的是WSL中的git</p>
</blockquote>
<p>在WSL建立了一个软链接，指向Win系统中一个空间比较大的盘，win系统的目录在WSL中是在<code>\mnt\&#39;盘符&#39;</code>下。<br>在所有配置完成后，在用git clone远程仓库的时候，却显示<code>ssh: connect to host github.com port 22: Connection refused</code>。<br>排除了与github的验证问题以后，发现可能是端口被占用的问题。<br>于是在<code>~/.ssh/</code>下新建了一个<code>config</code>文件，这里需要注意<code>config</code>文件的权限为<strong>600</strong>。<br>在<code>config</code>文件中黏贴以下文本后，与github的链接就十分稳定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User &apos;在git配置的邮箱&apos;</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
<h3 id="部署的时候出现的问题"><a href="#部署的时候出现的问题" class="headerlink" title="部署的时候出现的问题"></a>部署的时候出现的问题</h3><p>这个也蛮玄学的，莫名奇妙的部署不了，然后看了下提示，把<code>Next</code>主题<code>languages</code>文件夹下的<code>default.yml</code>删除即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/mbuger/article/details/70226712?%3E" target="_blank" rel="noopener"><strong>解决github端口22拒绝访问</strong></a></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1860 Currency Exchange</title>
    <url>/2020/04/06/POJ1860/</url>
    <content><![CDATA[<p><strong><em> 知识点: 判断正环</em></strong></p>
<blockquote>
<p>题目地址 | <a href="https://vjudge.net/problem/POJ-1860" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>我们的城市有<strong>M</strong>个货币兑换点，<strong>N</strong>种货币。让我们假设每一个点都只能兑换专门的两种货币。可以有几个点，专门从事相同货币兑换。<br>例如，如果你想换100美元到俄罗斯卢布兑换点，那里的汇率是29.75，而佣金是0.39，你会得到（100 - 0.39）×29.75＝2963.3975卢布。 </p>
<p><strong>问:</strong>  nick有<strong>V</strong>块<strong>S</strong>国的货币，他希望能通过一些操作（在不同的兑换点兑换），增加他的资本。当然，他想在最后手中的钱仍然是<strong>S</strong>国的。帮他解答这个难题，看他能不能完成这个愿望。 </p>
<blockquote>
<p>输入</p>
</blockquote>
<p><strong>!!! 单组输入 !!!</strong></p>
<p>先输入N(钟货币)、M(个兑换点)、S(当前持有货币类型)、V(持有金额)<br>然后输入M行，每行输入5个数字分别为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a国货币   b国货币   从a-&gt;b的佣金    从a-&gt;b的手续费  从b-&gt;a的佣金    从b-&gt;a的手续费</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">20.0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1.10</span> <span class="number">1.00</span> <span class="number">1.10</span> <span class="number">1.00</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>假设钱<strong>可以变多</strong>，就输出<strong>YES</strong>，否则输出<strong>NO</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>其实只要在图中找一个环，这个环可以使得金额变多即可。因为有了’正’环，就可增长到无限多，兑换回原来的货币就不用考虑，亏损了。</p>
<p>至于如何判断是否存在一个’正’环？用bellmanford来判断即可，虽然之前是求最短路，但是改变松弛条件后，遇到正环也会无限循环，即超过最大松弛次数 $n-1$次，即存在’正’环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">float</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],ct[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">    <span class="comment">//r是汇率,c是佣金</span></span><br><span class="line">    <span class="keyword">float</span> r,c;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">def</span><span class="params">(<span class="keyword">float</span> _r,<span class="keyword">float</span> _c)</span> </span>&#123; r=_r,c=_c; &#125;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) head[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">float</span> r,<span class="keyword">float</span> c)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].to=b; e[cnt].nxt=head[a]; e[cnt].def(r,c);</span><br><span class="line">    head[a]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">float</span> tmp,old=d[s];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">        now = <span class="built_in">list</span>.front();</span><br><span class="line">        <span class="built_in">list</span>.pop();</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now]; i!=<span class="number">-1</span>; i=e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span>((!vis[e[i].to]&amp;&amp;(tmp=(d[now]-e[i].c)*e[i].r)&gt;d[e[i].to])) &#123;</span><br><span class="line">                d[e[i].to]=tmp;</span><br><span class="line">                vis[e[i].to]=<span class="number">1</span>;</span><br><span class="line">                ct[e[i].to]++;  <span class="comment">//判断正环的部分</span></span><br><span class="line">                <span class="built_in">list</span>.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span>(ct[e[i].to]&gt;=n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">int</span> n,m,s;</span><br><span class="line">    <span class="keyword">float</span> v;</span><br><span class="line">    <span class="keyword">float</span> rab,rba;</span><br><span class="line">    <span class="keyword">float</span> cab,cba;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%f"</span>,&amp;n,&amp;m,&amp;s,&amp;v);</span><br><span class="line">    init(n);</span><br><span class="line">    d[s]=v;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%f%f%f%f"</span>,&amp;a,&amp;b,&amp;rab,&amp;cab,&amp;rba,&amp;cba);</span><br><span class="line">        addEdge(a,b,rab,cab);</span><br><span class="line">        addEdge(b,a,rba,cba);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,spfa(s,n)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3080 Blue Jeans</title>
    <url>/2020/03/14/POJ3080/</url>
    <content><![CDATA[<p><strong><em>知识点： KMP+枚举</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-3080#author=0" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>最长公共子串问题，子串必须连续。</p>
<p>问: 最长的公共子串是什么?</p>
<p>每个字符串固定由<strong>60</strong>个字符组成，且<strong>最多有10个</strong>字符串。</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>先输入$t$表示有$t$组案例。<br>每组案例先输入一个$n$，表示有$n$个字符串<br>之后输入$n$行字符串，每个字符串的字符个数为<strong>60</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line"><span class="number">3</span></span><br><span class="line">GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA</span><br><span class="line">GATACTAGATACTAGATACTAGATACTAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA</span><br><span class="line">GATACCAGATACCAGATACCAGATACCAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA</span><br><span class="line"><span class="number">3</span></span><br><span class="line">CATCATCATCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">ACATCATCATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AACATCATCATTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<ul>
<li>若不存在输出<strong>no significant commonalities</strong></li>
<li>否则输出字典序最小的最长子串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">no significant commonalities</span><br><span class="line">AGATAC</span><br><span class="line">CATCATCAT</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>无脑暴力肯定会<strong>TLE</strong>，所以使用<strong>KMP</strong>加速在后续找匹配的速度。</p>
<p>因此只要在第一行中暴力找出所有可能的情况$\binom{2}{60}$，并使用KMP算法在接下来的几行中暴力匹配即可。</p>
<p><del>KMP复杂度太优秀了只要O(n+m)!!!</del></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> p;</span><br><span class="line"><span class="built_in">string</span> t[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNxt</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">    nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;l) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||p[i]==p[j]) &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            nxt[i]=(p[i]==p[j])? nxt[j] : j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j=nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">60</span>&amp;&amp;j&lt;l) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || t[k][i]==p[j]) i++,j++;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    getNxt(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!kmp(i,l)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find substr</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">60</span>; i++) &#123;</span><br><span class="line">        len=<span class="number">60</span>-i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">3</span>; j&lt;=len; j++) &#123;</span><br><span class="line">            p = t[<span class="number">0</span>].substr(i,j);</span><br><span class="line">            <span class="keyword">if</span>(check(j)) &#123;</span><br><span class="line">                flg=<span class="number">1</span>;</span><br><span class="line">                ans = (p.size()&gt;ans.size() || (p.size()==ans.size()&amp;&amp;p&lt;ans))? p : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no significant commonalities\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span> &gt;&gt; t[i];</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>字符串</tag>
        <tag>枚举</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记 - 1</title>
    <url>/2020/02/20/GIT1/</url>
    <content><![CDATA[<p>$Git$分布式管理系统学习指<del>北</del>南。</p>
<p>本文主要介绍$Git$的<strong>基本使用方法</strong>，未涉及关于$Github$的内容。</p>
<p><strong>!!本文写于Linux环境下，若是window环境需自己酌情更改。!!</strong></p>
<a id="more"></a>
<h1 id="Step-0-Git-是什么"><a href="#Step-0-Git-是什么" class="headerlink" title="Step 0. $Git$是什么?"></a>Step 0. $Git$是什么?</h1><p>对于我来说$Git$就是一个文件管理系统，只不过记录了我所有的更改的文件管理系统，不过按照官方语言来说。<br>$Git$是一个分布式版本控制系统(Distributed Version Control System，简称<strong>DVCS</strong>)，关于什么是分布式版本控制系统? 可以<a href="https://Git-scm.com/book/en/v2/Getting-Started-About-Version-Control" target="_blank" rel="noopener">详见此文章</a>。</p>
<p>关于$Git$的一些特性</p>
<ul>
<li><strong>直接记录快照，而非差异比较</strong></li>
<li><strong>近乎所有操作都是本地执行</strong></li>
<li><strong>Git 保证完整性</strong></li>
<li><strong>Git 一般只添加数据</strong></li>
</ul>
<p>这边重点是$Git$有<strong>三个工作区的</strong>概念，这个对理解$Git$的大致运行很有帮助。</p>
<p>三个工作区分为:<code>工作目录</code>，<code>暂存区域</code>，<code>Git仓库</code>，这三个工作区之间的关系如下。</p>
<p><img src="/img/git1_rela.webp" alt="rela"></p>
<p>对于工作目录有<strong>三种状态</strong>:</p>
<ul>
<li>已修改 (modified): 已修改，但是未保存到数据库中。</li>
<li>已暂存(staged): 已经做了标记(add)，但是还没有提交(commit)。</li>
<li>已提交(committed): 已经保存到了本地数据库中。</li>
</ul>
<p>对于工作区中的文件则有四种状态，分别为<code>untracked</code>、<code>unmodified</code>、<code>modified</code>、<code>staged</code>，其中<strong>后三种</strong>通称<code>已追踪</code>状态，因此大方向看也分为两种状态<strong>已追踪</strong>和<strong>未追踪</strong>状态，具体就留到命令的时候再同时进行解释。</p>
<p>基本的$Git$工作流程如下:</p>
<ol>
<li><p>在工作目录中修改文件。</p>
</li>
<li><p>暂存文件，将文件的快照放入暂存区域。</p>
</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 $Git$ 仓库目录。</li>
</ol>
<p>由于学习GUI的$Git$就失去了，原本的$Git$的味道了，所以选择学习的为命令行模式。</p>
<h1 id="Step-1-如何配置-Git"><a href="#Step-1-如何配置-Git" class="headerlink" title="Step 1. 如何配置$Git$?"></a>Step 1. 如何配置$Git$?</h1><p>关于$Git$配置变量存放的默认位置。</p>
<p>在当前用户的家目录(<code>~/</code>)下会有一个<strong>.Gitconifg</strong>文件或者是<code>~/.config/Git/</code>里面的<strong>config</strong>文件，这个就是针对当前用户的配置。</p>
<p>在使用仓库(<code>.Git/</code>)里面的<strong>config</strong>文件是针对仓库的配置。</p>
<p>使用配置的优先级是 <code>.Git/config</code> <strong>&gt;</strong> <code>~/.Gitconfig</code> <strong>=</strong> <code>~/.config/Git/config</code> <strong>&gt;</strong> <code>系统Git配置变量</code>。</p>
<p>当然$Git$也提供<code>git config</code>命令来帮助设置配置变量。</p>
<h2 id="设置与检查的命令"><a href="#设置与检查的命令" class="headerlink" title="设置与检查的命令"></a>设置与检查的命令</h2><p>在每次安装完毕后我们都要对<strong>用户名</strong>和<strong>邮箱</strong>进行设置，因为每次提交都会作为身份来使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --golbal 表示全局配置</span></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">git config --global user.name <span class="string">'XXXX'</span></span><br><span class="line"><span class="comment"># 设置邮箱</span></span><br><span class="line">git config --global user.email XXX@XXX.com</span><br><span class="line"><span class="comment"># 设置编辑方式为vim</span></span><br><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>
<p>当然也可以直接在配置文件中书写配置，不过显然用命令会方便很多。</p>
<p>在配置完毕后，我们可以使用<code>git config --list</code>对<strong>检查配置</strong>。</p>
<p>也可以使用<code>git config &lt;key&gt;</code>来检<strong>单项配置</strong>，如<code>git config core.editor</code></p>
<h2 id="内置查询手册"><a href="#内置查询手册" class="headerlink" title="内置查询手册"></a>内置查询手册</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于Git命令的内置手册</span></span><br><span class="line">git <span class="built_in">help</span></span><br><span class="line"><span class="comment"># 关于Git初始化设置的内置手册</span></span><br><span class="line">git <span class="built_in">help</span> config</span><br></pre></td></tr></table></figure>
<h1 id="step-2-关于-Git-的基本命令"><a href="#step-2-关于-Git-的基本命令" class="headerlink" title="step 2. 关于$Git$的基本命令"></a>step 2. 关于$Git$的基本命令</h1><p>如果将本地整理比喻做<strong>‘家’</strong>，这一段的别名就成了<strong>整理家的艺术</strong>。</p>
<h2 id="本地初始化和获取远程仓库"><a href="#本地初始化和获取远程仓库" class="headerlink" title="本地初始化和获取远程仓库"></a>本地初始化和获取远程仓库</h2><p>初始化有两种方法<strong>从零开始</strong>和<strong>接着干</strong>。</p>
<h3 id="本地目录初始化仓库"><a href="#本地目录初始化仓库" class="headerlink" title="本地目录初始化仓库"></a>本地目录初始化仓库</h3><p><strong>初始化命令如下:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地目录初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment">#将当前目录的所有文件加入追踪</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#将文件保存到本地仓库中</span></span><br><span class="line">git commit -m <span class="string">'initial the repo'</span></span><br></pre></td></tr></table></figure>
<p>在运行命令之后查看当前目录<strong>所有文件</strong>，会发现一个<code>.git/</code>的子目录，这个是上述命令创建的，里面包含了所有$Git$需要重要信息。<br><code>.git</code>的存在表示了仓库初始化的完成，但是此时目录中的文件都是<code>untracked</code>状态，此时我们需要使用<code>add</code>命令将所有文件加入追踪，<strong>即工作目录变为(modified)。</strong><br>最后则是使用<code>commit</code>命令将<strong>已更改(modified)</strong>变为<strong>已提交(submitted)</strong>。</p>
<h3 id="克隆获取远程仓库"><a href="#克隆获取远程仓库" class="headerlink" title="克隆获取远程仓库"></a>克隆获取远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#克隆获取远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> [URL]</span><br></pre></td></tr></table></figure>
<p>这个方法是从远程仓库获取，获取下来后所有的文件已经处于可追踪(<code>unmodified</code>)状态。</p>
<h2 id="追踪和提交文件"><a href="#追踪和提交文件" class="headerlink" title="追踪和提交文件"></a>追踪和提交文件</h2><p>追踪和提交文件会对文件的状态进行更改，因此先解释关于文件的状态。</p>
<p>对于<strong>文件</strong>细致来说总共有<strong>四种状态</strong>关系如下:</p>
<p><img src="/img/git_rele2.jpg" alt="rela2"></p>
<p>$Git$提供了<code>git status</code>查询命令使得可以对目前仓库下文件的状态进行查询，但是<strong>需要注意</strong><code>unmodified</code>的状态$git$不会给出，同时命令行中，文件会显示<strong>两种颜色</strong>，红色代表<strong>未追踪</strong>或<strong>未暂存</strong>，<strong>绿色代表已暂存</strong>。</p>
<p>下面是对于每个状态的命令行返回示例。</p>
<h3 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a><strong>untracked</strong></h3><p><code>➜  learn-git git:(master) ✗</code> 后面表示命令行输入。</p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> echo &apos;Try a Try&apos; &gt; README
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    <font color="#DC322F">README</font>

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</pre>

<p>命令行的提示也给出了此文件是一个未追踪文件<code>Untracked file:</code>，在这一行下面的文件均为未追踪文件。</p>
<p>由于没有加入追踪，此时文件是处于$Git$管理外的，因此我们将文件纳入追踪，即直接将文件变未暂存状态。</p>
<h3 id="staged-git-add"><a href="#staged-git-add" class="headerlink" title="staged [git add]"></a><strong>staged</strong> <code>[git add]</code></h3><p><strong>untracked to staged/tracked</strong></p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git add README
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    <font color="#859900">new file:   README</font>

</pre>

<h3 id="unmodified-git-commit"><a href="#unmodified-git-commit" class="headerlink" title="unmodified [git commit]"></a><strong>unmodified</strong> <code>[git commit]</code></h3><p><strong>staged to unmodified</strong></p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git commit -m &apos;add README File&apos;
[master 2f0d641] add README File
 1 file changed, 1 insertion(+)
 create mode 100644 README
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git status
On branch master
nothing to commit, working tree clean
</pre>

<h3 id="modified"><a href="#modified" class="headerlink" title="modified"></a><strong>modified</strong></h3><p><strong>unmodified to modified</strong></p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> echo &apos;editor agian&apos; &gt;&gt; README
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    <font color="#DC322F">modified:   README</font>

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</pre>

<p>对于修改状态，命令行会在前面提示<code>modified</code>，十分清晰。</p>
<h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><p>当让我们也可以使用’git status -s’来简单查看文件的状态。</p>
<p>同时有时候我们使用<code>git add .</code>，但可能不需要将所有的文件加入暂存，比如生成的应用文件，由此我们可以在仓库中创建<code>.gitignore</code>文件来告诉$Git$哪些文件不需要纳入管理。</p>
<p>关于<code>.gitignore</code>的详细写法可以查看<a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring" target="_blank" rel="noopener">Git pro</a>。</p>
<h2 id="撤销仓库中的操作"><a href="#撤销仓库中的操作" class="headerlink" title="撤销仓库中的操作"></a>撤销仓库中的操作</h2><p>关于这里的部分详情可以查看书籍 | <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener"><strong>Here</strong></a><br>个人建议使用<code>git checkout -b</code>和<code>git merge</code>命令回退修改并合并。</p>
<h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><p>可以使用以下命令来查看提交日志。</p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git log
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>learn-git</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>) </b></font><font color="#657B83"><b>✗</b></font> git log --oneline 
</pre>

<p>其中第一行是查看详细的提交信息，而第二行只是简略信息。</p>
<h2 id="·-打标签"><a href="#·-打标签" class="headerlink" title="· 打标签"></a>· 打标签</h2><p>假设正在写项目，通常需要发布版本号，或者标记工作已经完成一个部分的标志，这个时候就可以使用$GIT$中的打标记的命令，十分方便。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">案例</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>➜ git tag</code></td>
<td style="text-align:left"><code>➜ ~ git tag</code></td>
<td style="text-align:center">查看所有的<code>tag</code></td>
</tr>
<tr>
<td style="text-align:left"><code>➜ git show &lt;tag&gt;</code></td>
<td style="text-align:left"><code>➜ ~ git show v1.4</code></td>
<td style="text-align:center">查看<code>tag: v1.4</code>在本地仓库的具体信息</td>
</tr>
<tr>
<td style="text-align:left"><code>➜ git tag -l &lt;option&gt;</code></td>
<td style="text-align:left"><code>➜ ~ git tag -l &quot;v1.*&quot;</code></td>
<td style="text-align:center">查找所有<code>tag</code>中符合<code>option</code>条件的<code>tag</code></td>
</tr>
<tr>
<td style="text-align:left"><code>➜ git tag -a &lt;tag&gt; -m &lt;else&gt;</code></td>
<td style="text-align:left"><code>➜ ~ git tag -a v1.2 -m &quot;lol&quot;</code></td>
<td style="text-align:center">创建附注标签</td>
</tr>
<tr>
<td style="text-align:left"><code>➜ git tag &lt;tag&gt; -lw</code></td>
<td style="text-align:left"><code>➜ ~ git tag v2.12 -lw</code></td>
<td style="text-align:center">打轻量标签</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>详细可以查询 | <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git-Book</a></p>
</blockquote>
<h2 id="·-使用远程仓库"><a href="#·-使用远程仓库" class="headerlink" title="· 使用远程仓库"></a>· 使用远程仓库</h2><h3 id="获取远程仓库和查看仓库配置的远程服务器"><a href="#获取远程仓库和查看仓库配置的远程服务器" class="headerlink" title="获取远程仓库和查看仓库配置的远程服务器"></a>获取远程仓库和查看仓库配置的远程服务器</h3><ul>
<li>使用<code>➜  ~ git clone &lt;url/git&gt;</code>获取远程服务器</li>
<li>使用<code>➜  ~ git remote</code>查看远程服务器的简写<ul>
<li>使用<code>➜  ~ git remote -v</code>查看远程服务器的简写和对应的url</li>
</ul>
</li>
</ul>
<p><strong>实践如下:</strong></p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>Documents</b></font> git clone https://github.com/schacon/ticgit
Cloning into &apos;ticgit&apos;...
remote: Enumerating objects: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857
Receiving objects: 100% (1857/1857), 334.06 KiB | 3.00 KiB/s, done.
Resolving deltas: 100% (837/837), done.
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>Documents</b></font> cd ticgit 
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote 
origin
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote -v     
origin    https://github.com/schacon/ticgit (fetch)
origin    https://github.com/schacon/ticgit (push)
</pre>

<h3 id="添加-改名和删除远程仓库和详细查询"><a href="#添加-改名和删除远程仓库和详细查询" class="headerlink" title="添加,改名和删除远程仓库和详细查询"></a>添加,改名和删除远程仓库和详细查询</h3><ul>
<li>使用<code>➜  ~ git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程仓库</li>
</ul>
<p><strong>实践如下:</strong></p>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote add pb https://github.com/paulboone/ticgit
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote -v                                        
origin    https://github.com/schacon/ticgit (fetch)
origin    https://github.com/schacon/ticgit (push)
pb    https://github.com/paulboone/ticgit (fetch)
pb    https://github.com/paulboone/ticgit (push)
</pre>

<hr>
<ul>
<li>使用<code>➜  ~ git remote rename &lt;oldname&gt; &lt;newname&gt;</code> 仔细查询远程仓库的信息</li>
<li>使用<code>➜  ~ git remote show &lt;shortname&gt;</code> 仔细查询远程仓库的信息</li>
<li>使用<code>➜  ~ git remote remove &lt;shortname&gt;</code> 删除一个远程仓库</li>
</ul>
<p><strong>实践如下:</strong></p>
<pre>
<font color="#CB4B16"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote rename pb paul
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote
origin
paul
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote show paul
* remote paul
  Fetch URL: https://github.com/paulboone/ticgit
  Push  URL: https://github.com/paulboone/ticgit
  HEAD branch: master
  Remote branches:
    master new (next fetch will store in remotes/paul)
    ticgit new (next fetch will store in remotes/paul)
  Local ref configured for &apos;git push&apos;:
    master pushes to master (local out of date)
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote remove paul
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>ticgit</b></font> <font color="#839496"><b>git:(</b></font><font color="#CB4B16"><b>master</b></font><font color="#839496"><b>)</b></font> git remote
origin
</pre>


<h2 id="·-使用自定义命令"><a href="#·-使用自定义命令" class="headerlink" title="· 使用自定义命令"></a>· 使用自定义命令</h2><p>有时候我们需要经常使用相同的一连串的命令，或者使用自己喜欢的符号来表示莫种命令，这时候就需要使用$GIT$的自定义命令功能来简便操作了。</p>
<ul>
<li><strong>直接在命令行中设置别名</strong></li>
</ul>
<pre>
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>~</b></font> git config --global alias.new &apos;checkout -b&apos;
<font color="#586E75"><b>➜  </b></font><font color="#93A1A1"><b>~</b></font> git config --global alias.co checkout
</pre>

<ul>
<li><strong>在<code>~/.gitconfig</code>中设置别名</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">[alias]</span><br><span class="line">	co = checkout	</span><br><span class="line">	new = checkout -b</span><br></pre></td></tr></table></figure>
<h1 id="Step-3-我与-Git-的故事"><a href="#Step-3-我与-Git-的故事" class="headerlink" title="Step 3. 我与$Git$的故事"></a>Step 3. 我与$Git$的故事</h1><p>关于我与$Git$的故事，那时候是刚上大学的时候，憨憨的使用着人工管理文件，那时候还不会使用$Github$这种有意思的东西，<del>虽然现在也不会使用2333</del>，却也还是在发呆的日子里，绑定了$Github$上面自己的$repo$开始了远程仓库之旅，那时候蛮傻的，只会$push$和$pull$这些操作，就连每次最基本的配置都要上网，寻找资料，才能完美的将$Github$和自己的机子慢慢的绑定，就这样过了一些日子(<strong>两年</strong>)。终于接触到了提交更改，为开源社区做贡献(修改错别字)的时候，那时候只能上网寻找教程的自己，意识到了自己关于理解$Git$的浅显，完全就如同一个阿三一样，只知道嗷嗷呜呜，呜呜嗷嗷。</p>
<p>然后就在暑假真正向着门里面的世界开始慢慢前行了。</p>
<h1 id="Else-参考书籍"><a href="#Else-参考书籍" class="headerlink" title="Else. 参考书籍"></a>Else. 参考书籍</h1><p><strong>Git - Book</strong> | <a href="https://Git-scm.com/book/zh/v2" target="_blank" rel="noopener"><strong>Here</strong></a></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2912 Rochambeau </title>
    <url>/2020/02/17/POJ2912/</url>
    <content><![CDATA[<p><strong><em>Tag: 带权并查集,枚举</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-2912#author=0" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong>author: shuri001</strong></p>
<p>$n$个小伙伴进行猜拳游戏，除了一个比较聪明的家伙以外，其他人只会出单一的一种，给出$m$种猜拳的结果，要求找出那个比较聪明的小伙伴序号，并且输出在第几次猜拳可以确定?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p><strong>多组案例输入。</strong></p>
<p>先输入$n$个人(编号从0开始)，$m$种结果，然后输出一行字符串代表结果。$( 1 \leq N \leq 500 \quad 0 \leq M \leq 2000 )$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span>&lt;<span class="number">1</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span>&lt;<span class="number">1</span></span><br><span class="line"><span class="number">0</span>&gt;<span class="number">1</span></span><br><span class="line"><span class="number">1</span>&lt;<span class="number">2</span></span><br><span class="line"><span class="number">1</span>&gt;<span class="number">2</span></span><br><span class="line"><span class="number">0</span>&lt;<span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span>&lt;<span class="number">1</span></span><br><span class="line"><span class="number">0</span>&gt;<span class="number">1</span></span><br><span class="line"><span class="number">2</span>&lt;<span class="number">3</span></span><br><span class="line"><span class="number">2</span>&gt;<span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Can <span class="keyword">not</span> determine</span><br><span class="line">Player <span class="number">1</span> can be determined to be the judge after <span class="number">4</span> lines</span><br><span class="line">Impossible</span><br><span class="line">Player <span class="number">0</span> can be determined to be the judge after <span class="number">0</span> lines</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>观察发现直接判断裁判个数较为困难，并且数据规模较小(2e3*5e3)，因此可以使用对枚举每个人并判断是否是裁判来求解。</p>
<p>假设要判断第$i$人是否为裁判，只要合并与不含此人的结果，如果没有冲突，则此人可能为裁判。</p>
<p>由于题目给定只能存在一个裁判因此不可能出现多裁判的情况，所以枚举出来个数为<strong>0</strong>为不可能情况，而当个数<strong>&gt;0</strong>，则为无法分辨。</p>
<p>当个数为<strong>1</strong>的时候，我们显然知道这个就是裁判，但最小发现的行数如何寻找呢？起始只要仔细发现，我们在排除枚举时候，其他矛盾才能确定当前枚举的人不是裁判。</p>
<p>所以我们只要选择枚举中所有出现矛盾的行数的(位置)最靠后一行即可。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dsu[maxn],val[maxn];</span><br><span class="line"><span class="keyword">int</span> u[<span class="number">2200</span>],v[<span class="number">2200</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n*<span class="number">3</span>; i++) dsu[i]=i,val[i]=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dsu[u]!=u) &#123; <span class="keyword">int</span> k=dsu[u]; dsu[u]=find(k); val[u]=(val[u]+val[k])%<span class="number">3</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> dsu[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa==fb) <span class="keyword">return</span> ((val[fa]+val[a]-val[b])%<span class="number">3</span>+<span class="number">3</span>)%<span class="number">3</span>!=k;</span><br><span class="line">    dsu[fa]=fb;</span><br><span class="line">    val[fa]=((val[b]+k-val[a])%<span class="number">3</span>+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k,pos,idx,n,m,cnt;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Player 0 can be determined to be the judge after 0 lines\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos=idx=cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) <span class="built_in">cin</span> &gt;&gt; u[i] &gt;&gt; op[i] &gt;&gt; v[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            init(n);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(u[j]==i || v[j]==i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(op[j]==<span class="string">'&lt;'</span>) k=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(op[j]==<span class="string">'&gt;'</span>) k=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> k=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(merge(u[j],v[j],k)) &#123;</span><br><span class="line">                    pos=max(pos,j);</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                idx=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not determine\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Player "</span> &lt;&lt; idx &lt;&lt; <span class="string">" can be determined to be the judge after "</span> &lt;&lt; (pos+<span class="number">1</span>) &lt;&lt; <span class="string">" lines\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>dsu</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1984 Navigation Nightmare</title>
    <url>/2020/02/15/POJ1984/</url>
    <content><![CDATA[<p><strong><em>Tag: 带权并查集</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-1984#author=0" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个网格状的农田，每个农田之间有距离，会依次给出关系，在给出关系后询问两个农田之间的曼哈顿距离是多少？若无法判断则输出<strong>-1</strong></p>
<blockquote>
<p>输入</p>
</blockquote>
<p><strong>!!多组案例输入!!</strong></p>
<p>对于每组案例:<br>首先输入两个数字$n$和$m$，表示有$n$块农田，农田从<strong>1</strong>开始编号。<br>接下来$m$行，每行给出$a,b,l,d$，$a$和$b$表示农田的编号，$l$表示之间的距离，$d$表示$b$在$a$的$d$侧(只有四种,北-$N$,南-$S$,西-$W$,东-$E$)。<br>然后输入一个数字$k$，代表询问次数。<br>之后输入$k$行，每行有三个数字$a,b,c$，表示在$c$行后询问$a,b$间的曼哈顿距离是多少?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">13</span> E</span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">9</span> E</span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span> S</span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> N</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">20</span> W</span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">2</span> S</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p><strong>!!!多组输出，需要在每两组输出间空一行!!!</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于询问不是实时给出，所以显然需要<strong>离线</strong>处理。选取$N,E$作为正方向，接下来只要按照带权并查集，合并即可，由于是有两个参数，所以将$x,y$分开维护。</p>
<p>但是要注意在维护$x,y$需要同时维护，当维护$x$的差值时候，需要注意此时维护的$y$的差值为<strong>0</strong>，之后使用套用常规带权并查集即可。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dsu[maxn],x[maxn],y[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt; qry;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; rela[maxn];</span><br><span class="line"><span class="keyword">int</span> wgt[maxn];</span><br><span class="line"><span class="keyword">char</span> dir[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) dsu[i]=i; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dsu[u] != u) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = dsu[u];</span><br><span class="line">        dsu[u]=find(dsu[u]);</span><br><span class="line">        x[u]+=x[k]; y[u]+=y[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dsu[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeX</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    dsu[fa]=fb;</span><br><span class="line">    x[fa] = k-x[a]+x[b];</span><br><span class="line">    y[fa] = -y[a]+y[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeY</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    dsu[fa]=fb;</span><br><span class="line">    y[fa] = k-y[a]+y[b];</span><br><span class="line">    x[fa] = -x[a]+x[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> u,v,idx;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">cin</span> &gt;&gt; rela[i].fi &gt;&gt; rela[i].se &gt;&gt; wgt[i] &gt;&gt; dir[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; idx;</span><br><span class="line">        qry[idx].pbk(mkp(u,v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dir[i]==<span class="string">'W'</span> || dir[i]==<span class="string">'E'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dir[i]==<span class="string">'W'</span>) mergeX(rela[i].fi,rela[i].se,-wgt[i]);</span><br><span class="line">            <span class="keyword">else</span> mergeX(rela[i].fi,rela[i].se,wgt[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dir[i]==<span class="string">'S'</span>) mergeY(rela[i].fi,rela[i].se,-wgt[i]);</span><br><span class="line">            <span class="keyword">else</span> mergeY(rela[i].fi,rela[i].se,wgt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!qry[i].empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size=qry[i].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;size; j++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; query(qry[i][j].fi,qry[i][j].se) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>带权并查集</tag>
        <tag>POJ</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1733 Parity game</title>
    <url>/2020/02/10/POJ1733/</url>
    <content><![CDATA[<p><strong><em>Tag: 离散化+带权并查集,dsu,Kuangbin</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-1733#author=zuodiedai" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出$k$条信息，每条信息表示一个区间内($[l,r]$)的$1$的个数为奇数($odd$)或是偶数($even$)。问从$1$开始，连续正确的信息为几条？</p>
<p><strong><em>tips:</em></strong> $1 \leq l \leq r \leq 1e9 \quad 1 \leq k \leq 5000$</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>第一行给出$n$代表区间的总长度为$[1,n]$<br>第二行给出$k$代表有$k$条信息<br>接下来$k$行，每行给出$l,r$代表区间，后面一个字符串代表一的个数是奇数($odd$)还是偶数($even$)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>		<span class="comment">//n</span></span><br><span class="line"><span class="number">5</span>		<span class="comment">//k</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> even	<span class="comment">//l=1 r=2 even</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> odd</span><br><span class="line"><span class="number">5</span> <span class="number">6</span> even</span><br><span class="line"><span class="number">1</span> <span class="number">6</span> even</span><br><span class="line"><span class="number">7</span> <span class="number">10</span> odd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于区间的范围很大，不能直接开这么大的数组进行对应，而询问较小，所以我们需要对输入的区间范围进行<strong>离散化</strong>，之后使用<strong>带权并查集</strong>求解即可。</p>
<p>这边令<strong>奇数</strong>权为$1$，<strong>偶数</strong>权为$0$即可。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pir pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) v.begin(),v.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; idx;</span><br><span class="line">pir p[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn&lt;&lt;<span class="number">1</span>],v[maxn&lt;&lt;<span class="number">1</span>],k[maxn&lt;&lt;<span class="number">1</span>],arr[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[u] != u) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=f[u];</span><br><span class="line">        f[u] = find(f[u]);</span><br><span class="line">        v[u] = (v[u]+v[t])%<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb) &#123;</span><br><span class="line">        f[fa] = fb;</span><br><span class="line">        v[fa] = ((v[b]+w-v[a])%<span class="number">2</span>+<span class="number">2</span>)%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (((v[a]+v[fa]-v[b])%<span class="number">2</span>+<span class="number">2</span>)%<span class="number">2</span>==w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m,a,b,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; str;</span><br><span class="line">        a--;</span><br><span class="line">        arr[cnt++] = a; arr[cnt++] = b;</span><br><span class="line">        p[i].fi = a; p[i].se = b;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">"even"</span>) k[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> k[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*=============discretization===============*/</span></span><br><span class="line">    sort(arr,arr+cnt);</span><br><span class="line">    cnt = unique(arr,arr+cnt)-arr;</span><br><span class="line">    init(cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++) idx[arr[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*=============dsu===============*/</span></span><br><span class="line">    <span class="keyword">int</span> ans=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!merge(idx[p[i].fi],idx[p[i].se],k[i])) &#123;</span><br><span class="line">            ans=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>带权并查集</tag>
        <tag>dsu</tag>
        <tag>离散化</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>P1057 传球游戏</title>
    <url>/2020/02/05/P1057/</url>
    <content><![CDATA[<p><strong><em>Tag: dp</em></strong> $ \quad $ <strong>| Level: yellow</strong></p>
<blockquote>
<p>题目链接 | <a href="https://www.luogu.com.cn/problem/P1057" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个人排成圆环传球，球从小李开始，每次只能向左，或者向右边传，总共能传$m$次，问<strong>有几种传法</strong>最终回到小李手中？</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>$ 3 \leq n \leq 30 \ , \quad 1 \leq m \leq 30$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span>	<span class="comment">//n m</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>	<span class="comment">//1-&gt;2-&gt;3-&gt;1 或 1-&gt;3-&gt;2-&gt;1</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑使用搜索，但是循环次数最多为$2^{30}$，所以抛弃，之后查询题解发现是使用$dp$<del>或者打表实现。</del></p>
<p>$dp[i][j]$代表经过$i$次传球后传到$j$的方案数，因此可以轻易的发现，此时方案数由<strong>上一轮</strong>的<strong>左边或者右边</strong>传球得来。</p>
<p>因此<strong>转移状态方程</strong>为:</p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i][j-1] + dp[i][j+1]</script><p>只需对边界($1,n$)进行特殊处理便可。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll dp[<span class="number">35</span>][<span class="number">35</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>) dp[i][j]=dp[i<span class="number">-1</span>][n]+dp[i<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==n) dp[i][j]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>LuoGu</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>LuoGu</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P1653 猴子</title>
    <url>/2020/02/01/P1653/</url>
    <content><![CDATA[<p><strong><em>Tag: 反向并查集。</em></strong></p>
<blockquote>
<p>题目链接 | <a href="https://www.luogu.org/problem/P1653" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote>
<p><a href="https://www.luogu.org/problem/P1653" target="_blank" rel="noopener"><strong>Click Here</strong></a></p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pir pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],ans[maxn],n,m,ccnt,ttm;</span><br><span class="line">pir p[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],uni[maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a]) <span class="keyword">return</span>;</span><br><span class="line">    vis[a]=<span class="number">1</span>; ans[a]=ttm; ccnt++;</span><br><span class="line">    <span class="keyword">int</span> end=e[a].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; b=e[a][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[b]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=a,tp;</span><br><span class="line">    <span class="keyword">while</span>(f[a]!=a) a=f[a];</span><br><span class="line">    <span class="keyword">while</span>(f[r]!=a) &#123;</span><br><span class="line">        tp=f[r];</span><br><span class="line">        f[r]=a;</span><br><span class="line">        r=tp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a),fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa==fb) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(fa==<span class="number">1</span>) &#123;</span><br><span class="line">        f[fb]=fa;</span><br><span class="line">        dfs(fb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fb==<span class="number">1</span>) &#123;</span><br><span class="line">        f[fa]=fb;</span><br><span class="line">        dfs(fa);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f[fb]=fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pir&gt; tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ccnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) f[i]=i,ans[i]=<span class="number">-1</span>,uni[i][<span class="number">1</span>]=uni[i][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].fi &gt;&gt; p[i].se;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        uni[a][b]=<span class="number">0</span>;</span><br><span class="line">        tmp.pbk(mkp(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    ttm=<span class="number">-1</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">-1</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;j1 = p[i].fi;</span><br><span class="line">        <span class="keyword">int</span> &amp;j2 = p[i].se;</span><br><span class="line">        <span class="keyword">if</span>(uni[i][<span class="number">1</span>]&amp;&amp;j1!=<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i="&lt;&lt; i &lt;&lt; " " &lt;&lt; "j1=" &lt;&lt; j1&lt;&lt; endl;</span></span><br><span class="line">            merge(i,j1);</span><br><span class="line">            e[i].pbk(j1); e[j1].pbk(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uni[i][<span class="number">2</span>]&amp;&amp;j2!=<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i="&lt;&lt; i &lt;&lt; " " &lt;&lt; "j2=" &lt;&lt; j2&lt;&lt; endl;</span></span><br><span class="line">            merge(i,j2);</span><br><span class="line">            e[i].pbk(j2); e[j2].pbk(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u,v,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ttm=i;</span><br><span class="line">        u = tmp[i].fi,k = tmp[i].se;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) &#123;</span><br><span class="line">            v=p[u].fi;</span><br><span class="line">            e[u].pbk(v); e[v].pbk(u);</span><br><span class="line">            merge(u,v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v=p[u].se;</span><br><span class="line">            e[u].pbk(v); e[v].pbk(u);</span><br><span class="line">            merge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>LuoGu</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>dsu,bfs</tag>
        <tag>spfa</tag>
        <tag>LuoGu</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-EducationRound#78 题解报告</title>
    <url>/2020/01/16/CodeForceER78/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-EducationalRound#78 | <a href="https://codeforces.com/contest/1278" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href=""><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Shuffle-Hashing"><a href="#A-Shuffle-Hashing" class="headerlink" title="A. Shuffle Hashing"></a>A. Shuffle Hashing</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个字符串$s1,s2$，问是否能在$s2$中找到一串连续的字符串，使得与$s1$相似?</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于数据范围很小所以可以使用$O(n^2)$的算法，从头开始暴力匹配去解决问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) v.begin(),v.end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">string</span> str1,str2;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">if</span>(str1.size() &gt; str2.size()) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(all(str1));</span><br><span class="line">    <span class="keyword">int</span> size2= str2.size();</span><br><span class="line">    <span class="keyword">int</span> size1= str1.size();</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size2; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i+size1<span class="number">-1</span> &gt;= size2) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">string</span> tmp = str2.substr(i,size1);</span><br><span class="line">      sort(all(tmp));</span><br><span class="line">      <span class="keyword">if</span>(tmp==str1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-A-and-B"><a href="#B-A-and-B" class="headerlink" title="B. A and B"></a>B. A and B</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出两个数字$a,b$，问最少经过多少轮可以使得$a=b$?</p>
<p>第$k$轮可以选择对$a$ 或 $b$加$k$，每一轮都不可跳过。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>仔细发现操作即将$1,2,3,4,5,…,n$，这个数列分成两部分，使得两部分之差的绝对值与$a-b$的绝对值(下文称之为$diff$)相等。</p>
<script type="math/tex; mode=display">
\begin{aligned}
sum &= (1+n)*n/2  \quad  &x_0 + x_1 &= sum \quad  (x_0 > x_1 >= 0) \\
& \quad &x_0 - x_1 &= diff \\
\Rightarrow
2x_1 &= sum+diff \\
4x_1 &= (1+n)*n - 2diff \\
\end{aligned}</script><p>因此只要保证$[(1+n)*n + 2diff] \mod 4 = 0$ 即可，由于$x_0&gt;x_1&gt;=0$，因此$sum&gt;diff$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  ll a,b,diff;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    diff = <span class="built_in">abs</span>(a-b);</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    diff &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    a = <span class="built_in">sqrt</span>(diff); b = a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a*b&lt;diff) a++,b++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(a*b-diff)%<span class="number">4</span>!=<span class="number">0</span>) a++,b++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Berry-Jam"><a href="#C-Berry-Jam" class="headerlink" title="C. Berry Jam"></a>C. Berry Jam</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>中间有一个楼梯，楼梯左右都放着$n$个果酱，果酱只有两种分别标记为$1，2$，通道很狭隘，每次只能从楼梯处搬出一个果酱(即<strong>左/右</strong>边最靠近楼梯的)。</p>
<p><strong>问:</strong> 最少搬出多少能，让通道内的$1$号果酱个数=$2$号果酱个数？</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>数据范围是$1e5$，所以做法的时间复杂度必为$O(n\log{n})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> tp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; lft;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">int</span> t,n,tmp;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    lft.clear();</span><br><span class="line">    <span class="comment">//input arr1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123; </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; tp[i]; </span><br><span class="line">      <span class="keyword">if</span>(tp[i]==<span class="number">1</span>) arr[i] = arr[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span> arr[i] = arr[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//input arr2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--) &#123; <span class="built_in">cin</span> &gt;&gt; tp[i]; &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tp[i]==<span class="number">1</span>) now--;</span><br><span class="line">      <span class="keyword">else</span> now++;</span><br><span class="line">      lft[now] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = lft[<span class="number">-1</span>*arr[i]];</span><br><span class="line">      <span class="keyword">if</span>(idx) mx = max(mx,i+idx);</span><br><span class="line">      <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) mx = max(mx,i);</span><br><span class="line">    &#125;</span><br><span class="line">    mx = max(mx,lft[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (n*<span class="number">2</span>-mx) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Segment-Tree"><a href="#D-Segment-Tree" class="headerlink" title="D. Segment Tree"></a>D. Segment Tree</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p><strong>重要点:</strong> 如何在$O(1)$的时间复法杂度内完成合并的判断操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pir pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) v.begin(),v.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],n;</span><br><span class="line"><span class="built_in">vector</span>&lt;pir&gt; grp;</span><br><span class="line">pir p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFa</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tp,fa = a;</span><br><span class="line">  <span class="keyword">while</span>(f[a] != a) a = f[a];</span><br><span class="line">  <span class="keyword">while</span>(f[fa] != a) &#123;</span><br><span class="line">    tp = f[fa];</span><br><span class="line">    f[fa] = a;</span><br><span class="line">    fa = tp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;pir&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t=n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> i,j,r,fa,fb;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> now: grp) &#123;</span><br><span class="line">    <span class="keyword">if</span>(st.count(now)) &#123;</span><br><span class="line">      st.erase(now);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i = now.second;</span><br><span class="line">      r = p[i].second;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> gp: st) &#123;</span><br><span class="line">        <span class="keyword">if</span>(gp.first &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        t--;</span><br><span class="line">        j = gp.second;</span><br><span class="line">        fa = getFa(j);</span><br><span class="line">        fb = getFa(i);</span><br><span class="line">        <span class="keyword">if</span>(fa==fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[fa] = fb;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(t&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      st.insert(mkp(r,i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">int</span> a,b;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  init(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">    grp.push_back(mkp(p[i].first,i));</span><br><span class="line">    grp.push_back(mkp(p[i].second,i));</span><br><span class="line">  &#125;</span><br><span class="line">  sort(all(grp));</span><br><span class="line">  <span class="keyword">if</span>(check()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本题总结"><a href="#本题总结" class="headerlink" title="本题总结"></a>本题总结</h2><p>在本题中遭遇了<strong>TLE</strong>，主要是在线段间的合并时，寻找可连接边的复杂度到达了$O(n)$，而题解中寻找可合并线段的复杂度为$O(1)$，因此使用前者的总时间复杂度为$O(n^2)$，主要花费在寻找可连接边上了，看似优化，实际木大木大，嗐….</p>
<h1 id="E-Tests-for-problem-D"><a href="#E-Tests-for-problem-D" class="headerlink" title="E. Tests for problem D"></a>E. Tests for problem D</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p><strong>即构造D题的数据。</strong></p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>用包含的关系来防止构造出相交，因此在构造的时候为反向构造，即先构造的后收尾，后构造的先收尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=a[u].size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = a[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    l[v]=cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  r[u]=cnt++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a[u].size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = a[u][i];</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">int</span> u,v;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    a[u].pbk(v);</span><br><span class="line">    a[v].pbk(u);</span><br><span class="line">  &#125;</span><br><span class="line">  cnt = <span class="number">1</span>; l[<span class="number">1</span>]=cnt++;</span><br><span class="line">  dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Rated for Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>堆学习笔记 - 配对堆</title>
    <url>/2020/01/12/pairheap/</url>
    <content><![CDATA[<p>本文是配对堆的学习笔记，其中没有包括$decrease-key$操作</p>
<blockquote>
<p>配对堆的基础介绍 | <strong>不包含</strong>$decrease-key$操作</p>
<p>模板代码 | <a href="https://github.com/Mirasire/icpc-train/blob/master/Algorithms/DS/pairheap.cpp" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>本文主要介绍最小配对堆，当然也有最大配对堆。</p>
</blockquote>
<p>配对堆是一个<strong>带权多叉树</strong>(如图)，它一个可并堆，满足下述性质的即为最小配对堆。</p>
<ol>
<li>空堆是一个最小配对堆。</li>
<li>所有节点的权值都小于其子树的权值。</li>
</ol>
<blockquote>
<p>如下图即为一个<strong>最小配对堆</strong></p>
</blockquote>
<p><img src="/img/ph.jpg" alt="pairing-heap"></p>
<h2 id="配对堆的表示"><a href="#配对堆的表示" class="headerlink" title="配对堆的表示"></a>配对堆的表示</h2><p>由于<strong>配对堆</strong>是一棵多叉树，假设使用孩子表示法，对于每次新加入孩子，就需要动态开孩子节点，过程有点繁琐，所以我们使用兄弟孩子表示法来存储配对堆。</p>
<blockquote>
<p>孩子表示法 -&gt; 孩子兄弟表示法如下图所示</p>
</blockquote>
<p><img src="/img/phs.jpg" alt="pairing-heap-b/s"></p>
<p><strong>具体单个节点结构和代码实现如下图所示:</strong></p>
<p><img src="/img/pairnode+code.jpg" alt="pairing-node"></p>
<h2 id="可支持的操作"><a href="#可支持的操作" class="headerlink" title="可支持的操作"></a>可支持的操作</h2><p><strong>优秀的时间复杂度汇总</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">合并($merge$)</th>
<th style="text-align:center">删除最小值($delete-min$)</th>
<th style="text-align:center">插入($insert$)</th>
<th style="text-align:center">减小一个数的值($decrease-key$)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"><strong>TODO</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="合并-merge"><a href="#合并-merge" class="headerlink" title="合并($merge$)"></a>合并($merge$)</h3><blockquote>
<p>图片未使用<strong>兄弟 / 孩子</strong>表示法，为正常的多叉树画法。</p>
</blockquote>
<p>配对堆的合并的做法十分粗暴，假设合并如下两个配对堆，我们需要比较<strong>堆1</strong>和<strong>堆2</strong>的最小值(即为根)，将次小的那个堆插入到最小的堆的根下，即，将右边的堆插入到左边的堆的根下，这样就完成合并了，因此复杂度显然是$O(1)$。</p>
<p><img src="/img/pairmerge.jpg" alt="pairing-node"></p>
<p>合并操作<strong>结果如下</strong>，红色为插入的堆。</p>
<p><img src="/img/afmerge.jpg" alt="pairing-node"></p>
<h3 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入($insert$)"></a>插入($insert$)</h3><p>插入可以看为一元素个数为1的配对堆合并，注意特判原来元素不存在的情况即可。</p>
<h3 id="查询最小值-get-min"><a href="#查询最小值-get-min" class="headerlink" title="查询最小值($get-min$)"></a>查询最小值($get-min$)</h3><p>由定义可知，返回根节点的值即可。</p>
<h3 id="删除最小值-delete-min"><a href="#删除最小值-delete-min" class="headerlink" title="删除最小值($delete-min$)"></a>删除最小值($delete-min$)</h3><p>尽管我们可以从左向右两两合并，但是这样的话时间复杂度必为$O(n)$，而目标的均摊复杂度为$O(\log{n})$，因此我们使用<strong>两步合并</strong>，使得均摊复杂度为$O(\log{n})$。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>如下图所示，<strong>从左向右</strong>，两两合并根节点的子树。</p>
<p><img src="/img/pairpass1.jpg" alt="Pass#1"></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>如下图所示，第一步完成后，<strong>从右向左</strong>，将剩余的子树和最右边的子树合并。</p>
<p><img src="/img/pairpass2.jpg" alt="Pass#2"></p>
<h2 id="最小配对堆模板"><a href="#最小配对堆模板" class="headerlink" title="最小配对堆模板"></a><strong>最小配对堆</strong>模板</h2><blockquote>
<p>最小配对堆<br>模板代码 | <a href="https://github.com/Mirasire/icpc-train/blob/master/Algorithms/DS/pairheap.cpp" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>* <span class="title">PNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    PNode ch,br;</span><br><span class="line">    NODE() &#123;&#125;</span><br><span class="line">    NODE(<span class="keyword">int</span> _val):val(_val),ch(<span class="literal">nullptr</span>),br(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PAIRINGHEAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        PNode root;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        PAIRINGHEAP() &#123; root = <span class="keyword">new</span> NODE(); n = <span class="number">0</span>; &#125;</span><br><span class="line">        PAIRINGHEAP(<span class="keyword">int</span> arr[],<span class="keyword">int</span> _size) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!n) &#123;root = <span class="keyword">new</span> NODE(val);&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                PNode _add = <span class="keyword">new</span> NODE(val);</span><br><span class="line">                root = merge(root,_add);</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">PNode <span class="title">merge</span><span class="params">(PNode a,PNode b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="literal">nullptr</span>) <span class="keyword">return</span> b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val) swap(a,b);</span><br><span class="line">            b-&gt;br = a-&gt;ch;</span><br><span class="line">            a-&gt;ch = b;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">PNode <span class="title">mergeBro</span><span class="params">(PNode x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="literal">nullptr</span> || x-&gt;br == <span class="literal">nullptr</span>) <span class="keyword">return</span> x;</span><br><span class="line">            PNode n1,n2;</span><br><span class="line">            n1 = x-&gt;br; n2 = n1-&gt;br;</span><br><span class="line">            n1-&gt;br = x-&gt;br = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> merge(merge(x,n1),mergeBro(n2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">delMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PNode tmp = root;</span><br><span class="line">            root = mergeBro(root-&gt;ch);</span><br><span class="line">            <span class="keyword">delete</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root-&gt;val; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;PNode&gt; <span class="built_in">list</span>;</span><br><span class="line">            <span class="built_in">list</span>.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">                PNode tmp = <span class="built_in">list</span>.front();</span><br><span class="line">                <span class="built_in">list</span>.pop();</span><br><span class="line">                <span class="keyword">while</span>(tmp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    tmp-&gt;display();</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;ch != <span class="literal">nullptr</span>) <span class="built_in">list</span>.push(tmp-&gt;ch);</span><br><span class="line">                    tmp=tmp-&gt;br;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oi-wiki.org/ds/pairing-heap/" target="_blank" rel="noopener">配对堆 : <strong>OI-WIKI</strong></a><br><a href="https://brilliant.org/wiki/pairing-heap/" target="_blank" rel="noopener">Pairing Heap : <strong>brilliant</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>配对堆</tag>
      </tags>
  </entry>
  <entry>
    <title>如何的优雅展示代码?</title>
    <url>/2020/01/07/VisualGitHistory/</url>
    <content><![CDATA[<p>本文主要介绍<strong>git-history</strong>的安装和使用方法。</p>
<blockquote>
<p>作者：<strong>Rodrigo Pombo</strong><br><strong>Github</strong>项目地址 | <a href="https://github.com/pomber/git-history" target="_blank" rel="noopener"><strong>git-history</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>昨天突发想，如何<strong>优雅的展示自己的代码</strong>和其<strong>git历史修改</strong>呢？</p>
<p>寻找了许久终于在<strong>github</strong>上面找到一个的工具(<strong>git-history</strong>)，该工具可以<strong>十分酷炫</strong>的展示自己代码和查看自己的历史修改，而且正巧也在使用途中遇到了些小插曲，嘛~，废话不多说开始正片。</p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/img/show.gif" alt="show"></p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="在github上查看"><a href="#在github上查看" class="headerlink" title="在github上查看"></a>在github上查看</h2><p>在github上直接使用较为简单，只需要两个步骤。</p>
<ol>
<li>将原来的 URL 中的 <strong>github.com</strong> 换为<strong>githistory.xyz</strong>，其他不变。</li>
<li>刷新即可加载到查看界面。</li>
</ol>
<p>当然也支持浏览器插件。</p>
<blockquote>
<p>Firefox的插件地址 | <a href="https://addons.mozilla.org/en-US/firefox/addon/github-history/" target="_blank" rel="noopener"><strong>Here</strong></a><br>Chrome的插件地址 | <a href="https://chrome.google.com/webstore/detail/github-history-browser-ex/laghnmifffncfonaoffcndocllegejnf" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<p>在安装插件完成后，原来github上文件的<strong>History</strong>右边会出现<strong>Open in Git History</strong>(如下图)，点击<strong>Open in Git History</strong>按钮即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/img/bp.PNG" alt="before"></th>
<th style="text-align:center"><img src="/img/ap.PNG" alt="after"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>安装插件前</em></td>
<td style="text-align:center"><em>安装插件后</em></td>
</tr>
</tbody>
</table>
</div>
<h2 id="在VsCode下查看"><a href="#在VsCode下查看" class="headerlink" title="在VsCode下查看"></a>在VsCode下查看</h2><p>在VsCode的插件中搜索Git File History，下载即可。</p>
<h2 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h2><p><strong>git-history</strong>也提供了<strong>cli</strong>来支持本地的查看。</p>
<h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><blockquote>
<ul>
<li>node.js | <strong>v12.12.0</strong></li>
<li>npm | <strong>6.11.3</strong></li>
<li>WSL | <strong>ubuntu 18.04 LTS</strong></li>
</ul>
</blockquote>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g git-file-history</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>假设当前目录下有一个heap.cpp，我们想要只需要在<strong>Terminal</strong> 中输入 <code>githistory heap.cpp</code>，之后会自动打开浏览器，显示heap.cpp的代码和其git的历史修改。</p>
<h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>由于我使用的是<strong>WSL</strong>所以不能自动打开浏览器，跳到目标的本地<strong>URL</strong>，而且十分不巧的是，<strong>git-history</strong>的<strong>Terminal</strong>提示十分笼统，假设按照提示打开浏览器，会都不显示，<del>因为这个原因我重装了好几遍，QWQ</del>，因此我们需要修改<strong>git-history</strong>的<strong>cli</strong>文件，来使得提示的<strong>URL</strong>更加具体。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis githistory</span><br><span class="line"><span class="comment"># githistory: /opt/node-v12.12.0-linux-x64/bin/githistory</span></span><br></pre></td></tr></table></figure>
<p>之后使用<strong>cd</strong>和<strong>ll</strong>命令移动到<strong>git-file-history</strong>所在的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/node-v12.12.0-linux-x64/bin/</span><br><span class="line">ll githistory</span><br><span class="line"><span class="comment"># [略...] githistory -&gt; ../lib/node_modules/git-file-history/cli.js*</span></span><br><span class="line"><span class="built_in">cd</span> ../lib/node_modules/git-file-history/</span><br></pre></td></tr></table></figure>
<p>修改目录下的<strong>server.js</strong>，将其中的倒数第三行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Running at http://localhost:"</span> + port);</span><br></pre></td></tr></table></figure>
<p>修改为如下，并保存退出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Running at http://localhost:"</span> + port + <span class="string">"/?path="</span> + <span class="built_in">encodeURIComponent</span>(path));</span><br></pre></td></tr></table></figure>
<p>此后再使用<strong>githistory</strong>时<strong>Terminal</strong>中的提示打开的URL，已经是精准的链接🔗，所以直接<code>C-c</code>和<code>C-v</code>到浏览器中，打开即可展示自己的代码，并查看自己git的历史修改。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是本文的全部了，感谢<strong>Rodrigo Pombo</strong>提供如此酷炫的工具，用来查看<strong>git</strong>的历史修改。</p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>git-history</tag>
      </tags>
  </entry>
  <entry>
    <title>堆学习笔记 - 堆简介</title>
    <url>/2020/01/06/HEAP1/</url>
    <content><![CDATA[<p>本文主要介绍了<strong>堆的基本知识</strong>和二叉堆中<strong>大根堆的具体实现</strong>。</p>
<blockquote>
<p><strong>堆</strong>是一种基础的数据，在寻找最大值或最小值的时候性能优秀，其中的斐波那契堆，最为出色。</p>
<p>模板代码 | <a href="https://github.com/Mirasire/icpc-train/blob/master/Algorithms/DS/heap.cpp" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆是一种基于<strong>完全二叉树</strong>的一种数据结构，通常堆可以分为以下两大类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">图片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">大根堆 ($Max \ Heap$)</td>
<td style="text-align:center">所有节点的键值<strong>大于</strong>其所有的子树元素的值。</td>
<td style="text-align:center"><img src="/img/MaxH.png" alt="Max Heap"></td>
</tr>
<tr>
<td style="text-align:center">小根堆 ($Min \ Heap$)</td>
<td style="text-align:center">所有节点的键值<strong>小于</strong>其所有的子树元素的值。</td>
<td style="text-align:center"><img src="/img/MinH.png" alt="Min Heap"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="性能汇总"><a href="#性能汇总" class="headerlink" title="性能汇总"></a>性能汇总</h2><blockquote>
<p><strong>施工中…..</strong></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">二叉堆</th>
<th style="text-align:center">配对堆</th>
<th style="text-align:center">左偏树</th>
<th style="text-align:center">二项堆</th>
<th style="text-align:center">斐波那契堆</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查询最小值($find \ min$)</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">删除最小值($delete \ min$)</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">插入($insert$)</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">合并($merger$)</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">减少一个元素的值($decrease \ key$)</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="大根堆-Max-Heap"><a href="#大根堆-Max-Heap" class="headerlink" title="大根堆(Max Heap)"></a>大根堆(Max Heap)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>所有节点的值大于其所有的子树元素的值，这样的堆称为大根堆($Max \ Heap$)。</p>
<blockquote>
<p>模板代码 | <a href="https://github.com/Mirasire/icpc-train/blob/master/Algorithms/DS/heap.cpp" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><blockquote>
<p>由于大根堆是一颗完全二叉树，因此我们可以使用完全二叉树的性质，用数组来实现二叉堆。</p>
</blockquote>
<p><strong>复杂度汇总</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">查询最大值($find \ max$)</th>
<th style="text-align:center">删除最大值($delete \ max$)</th>
<th style="text-align:center">插入一个值($insert$)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(\log{n})$</td>
<td style="text-align:center">$O(\log{n})$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="插入一个元素-insert"><a href="#插入一个元素-insert" class="headerlink" title="插入一个元素($insert$)"></a>插入一个元素($insert$)</h3><p>由于要保证二叉堆满足<strong>完全二叉树</strong>的性质，因此首先将元素插入到堆的最末尾，之后再进行<strong>向上调整</strong>。</p>
<ul>
<li><strong>具体操作如下：</strong><ul>
<li>假设父亲节点元素小于当前元素<ul>
<li>交换，继续向上调整</li>
</ul>
</li>
<li>假设父亲节点元素不小于当前元素<ul>
<li>退出操作，操作结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>显然可以证明的是，如此操作后的二叉树依旧满足堆的性质。</p>
<h3 id="删除最大值-delete-max"><a href="#删除最大值-delete-max" class="headerlink" title="删除最大值($delete \ max$)"></a>删除最大值($delete \ max$)</h3><p>由于要保证二叉堆满足<strong>完全二叉树</strong>的性质，因此首先将带删除与堆的最末尾交换，删除堆的最后一个元素，之后从根开始再进行<strong>向下调整</strong>。</p>
<ul>
<li><strong>具体操作如下：</strong><ul>
<li>假设儿子节点元素存在大于当前元素的<ul>
<li><strong>选择与儿子节点中最大</strong>的交换，继续向下调整</li>
</ul>
</li>
<li>假设儿子节点元素都不大于当前元素<ul>
<li>退出操作，操作结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>显然可以证明的是，如此操作后的二叉树依旧满足堆的性质。</p>
<blockquote>
<p>删除一个元素的思路和删除最大值相同，就不再赘述了。</p>
</blockquote>
<h3 id="堆的建立-construction-function"><a href="#堆的建立-construction-function" class="headerlink" title="堆的建立($construction \ function$)"></a>堆的建立($construction \ function$)</h3><p>先将所有的元素变成一个完全二叉树，然后<strong>进行调整</strong>，通过观察上面的$delete min$和$insert$操作，发现有两种方法可以将这个完全二叉树调整为一个堆，但是在实际操作中，这两种方式的时间复杂度是不同的。</p>
<ul>
<li>从根开始向上调整的时间复杂度为$O(n \log{n})$</li>
<li>从叶子开始向下调整的时间复杂度为$O(n)$</li>
</ul>
<blockquote>
<p>可以想一想为什么不可以从根开始向下调整，叶子同问？</p>
</blockquote>
<h2 id="Max-Heap-模板"><a href="#Max-Heap-模板" class="headerlink" title="$Max \ Heap$ 模板"></a>$Max \ Heap$ 模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元素个数容量池</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAXHEAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//_size equals to the number of the heap's element</span></span><br><span class="line">    <span class="keyword">int</span> data[maxn];</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    MAXHEAP() &#123; data[<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//===========建堆===========</span></span><br><span class="line">    MAXHEAP(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size) &#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++) data[i] = arr[i];</span><br><span class="line">        <span class="comment">//从叶子开始向下调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--) down(i);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从根开始向上调整: </span></span><br><span class="line"><span class="comment">        for(int i=1; i&lt;=n; i++) up(i);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===========向上调整===========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span> &amp;&amp; data[x] &gt; data[x/<span class="number">2</span>]) &#123;</span><br><span class="line">            swap(data[x],data[x/<span class="number">2</span>]);</span><br><span class="line">            x/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===========向下调整===========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>((x&lt;&lt;<span class="number">1</span>) &lt; n) &#123;</span><br><span class="line">            t = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t+<span class="number">1</span>&lt;n &amp;&amp; data[t]&lt;data[t+<span class="number">1</span>]) t++;</span><br><span class="line">            <span class="keyword">if</span>(data[t]&lt;data[x]) <span class="keyword">break</span>;</span><br><span class="line">            swap(data[x],data[t]);</span><br><span class="line">            x=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===========插入最大值===========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> _data)</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        data[n] = _data;</span><br><span class="line">        up(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===========返回最大值===========</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="comment">//===========删除最大值===========</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        swap(data[<span class="number">1</span>],data[n]);</span><br><span class="line">        <span class="comment">//data[n]=0</span></span><br><span class="line">        n--;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从根开始向上调整，类似插入排序里面将无序数组插入有序数组的含义，由于调整完前n个以后，1~n必为一个堆，此时调整n+1，类似于插入元素，所以是从根开始向上调整，必然正确。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>堆-OIWiKi</strong> | <a href="https://oi-wiki.org/ds/heap/" target="_blank" rel="noopener"><strong>LINK</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索树学习笔记-二叉搜索树</title>
    <url>/2020/01/04/BSTREE/</url>
    <content><![CDATA[<p>记录学习<strong>搜索树</strong>中最基础的<strong>二叉搜索树</strong>得到的收获。</p>
<blockquote>
<p><del><strong>BST模板</strong> | <a href="httpaddres://github.com/Mirasire/icpc-train/tree/master/Algorithms/DS/BST.cpp" target="_blank" rel="noopener"><strong>Here</strong></a></del></p>
</blockquote>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>假设没有重复元素</p>
</blockquote>
<p><strong>二叉搜索树</strong>($binary \ search \ tree$)是一棵二叉树。<br>空的二叉树是<strong>二叉搜索树</strong>(后简称为: <strong>BST</strong>)，如果<strong>BST</strong>不为空，那它满足必以下性质，反之满足这些性质的二叉树都为<strong>BST</strong>。</p>
<ul>
<li><strong>性质: </strong> <ol>
<li>每个元素都不同</li>
<li>在根节点的左子树中，所有元素的关键字都小于根节点的关键字。</li>
<li>在根节点的右子树中，所有元素的关键字都大于根节点的关键字。</li>
<li>根节点的左、右子树也都是二叉搜索树。</li>
</ol>
</li>
</ul>
<h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><p><strong>复杂度汇总</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">查找($find$)</th>
<th style="text-align:center">插入($insert$)</th>
<th style="text-align:center">删除($earse$)</th>
<th style="text-align:center">遍历($ascend$)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(n) \sim O(\log{n})$</td>
<td style="text-align:center">$O(n) \sim O(\log{n})$</td>
<td style="text-align:center">$O(n) \sim O(\log{n})$</td>
<td style="text-align:center">$O(n)$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 - $find$"></a>查找 - $find$</h3><p>我们可以很轻松的发现，在<strong>BST</strong>中，查找的时间和目标节点的深度有关，当为完全二叉树时，时间复杂度为$O(\log{n})$，而最坏时间复杂度的情况，是当二叉搜索树退化成链式结构时，这时我们需要花费和与链表一样的时间复杂度，这是很糟糕的。<br><del>当然也没有这么糟糕，毕竟大佬们发明了<strong>平衡二叉搜索树</strong>($BBST$)来防止BST的退化。</del></p>
<p><strong>代码思路</strong></p>
<blockquote>
<p>假设待查找的关键码为$data$</p>
</blockquote>
<ul>
<li>按照结构向下寻找<ul>
<li>如果查找大于当前关键码<ul>
<li>在当前节点的右子树寻找</li>
</ul>
</li>
<li>如果查找小于当前关键码<ul>
<li>在当前节点的左子树寻找</li>
</ul>
</li>
<li>如果查找等于当前关键码<ul>
<li>找得答案返回结果</li>
</ul>
</li>
</ul>
</li>
<li>若找到最后都没有寻找到，即返回未寻得</li>
</ul>
<h3 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 - $insert$"></a>插入 - $insert$</h3><p>插入和删除操作的时间复杂度分析与寻找操作相同，所以就不赘述了。</p>
<p>插入操作可以看作查找操作的延申，假设我们用插入值进行查找，显然返回结果会是<strong>NULL</strong>，但当我们关注于查找操作的倒数第二部时候，我们发现插入的值，必定为当前节点的儿子节点，于是我们只要在那时，新建节点，并且按照定义赋值给当前节点的<strong>左/右子树指针</strong>即可。</p>
<h3 id="删除-earse"><a href="#删除-earse" class="headerlink" title="删除 - $earse$"></a>删除 - $earse$</h3><p>删除要按照待删除节点的左、右子树<strong>分为三种</strong>情况，其中<strong>前两种</strong>情况的实现较为<strong>简单</strong>。</p>
<ul>
<li><strong>情况: </strong><ol>
<li>左、右子树都不存在，此时直接删除即可。</li>
<li>左、右子树只有一棵存在，此时直接删除，将存在的子树嫁接到上面即可。</li>
<li>左、右子树都存在，此时我们需要找到中序遍历中待删除节点的左或右节点(<strong>下文用左节点说明</strong>)，将左节点的赋值与现在的节点，之后删除左节点。</li>
</ol>
</li>
</ul>
<blockquote>
<p>关于第三种情况，我们可以发现，在我们删除左节点的时候，必为第一或者第二种情况，因此对时间复杂度无影响。</p>
</blockquote>
<h3 id="遍历-ascend"><a href="#遍历-ascend" class="headerlink" title="遍历 - $ascend$"></a>遍历 - $ascend$</h3><p>遍历即为二叉树的<strong>中序遍历</strong>($InOrder \ OutPut$)。</p>
<h2 id="BST模板"><a href="#BST模板" class="headerlink" title="BST模板"></a>BST模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>* <span class="title">PNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    PNode lc,rc;</span><br><span class="line">    NODE(<span class="keyword">int</span>&amp; val):val(val),lc(<span class="literal">NULL</span>),rc(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    NODE():val(INF),lc(<span class="literal">NULL</span>),rc(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bsTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//============插入操作============</span></span><br><span class="line">    <span class="function">PNode <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data,PNode _rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_rt == <span class="literal">NULL</span> || _rt-&gt;val == INF) &#123;</span><br><span class="line">            _rt = <span class="keyword">new</span> NODE(data);</span><br><span class="line">            <span class="keyword">return</span> _rt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; _rt-&gt;val) _rt-&gt;lc = insert(data,_rt-&gt;lc);</span><br><span class="line">        <span class="keyword">else</span> _rt-&gt;rc = insert(data,_rt-&gt;rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//============删除操作============</span></span><br><span class="line">    <span class="function">PNode <span class="title">earse</span><span class="params">(<span class="keyword">int</span> data,PNode _rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == _rt-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_rt-&gt;lc==<span class="literal">NULL</span> &amp;&amp; _rt-&gt;rc==<span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _rt;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(_rt-&gt;lc==<span class="literal">NULL</span> || _rt-&gt;rc==<span class="literal">NULL</span>) &#123;</span><br><span class="line">                PNode tmp = _rt-&gt;lc==<span class="literal">NULL</span>? _rt-&gt;rc : _rt-&gt;lc;</span><br><span class="line">                <span class="keyword">delete</span> _rt;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PNode tmp = findRightMin(_rt-&gt;rc);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; tmp-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                _rt-&gt;val = tmp-&gt;val;</span><br><span class="line">                _rt-&gt;rc = earse(tmp-&gt;val,_rt-&gt;rc);</span><br><span class="line">                <span class="keyword">return</span> _rt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; _rt-&gt;val) &#123;</span><br><span class="line">            _rt-&gt;lc = earse(data,_rt-&gt;lc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _rt-&gt;rc = earse(data,_rt-&gt;rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//============遍历操作============</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acend</span><span class="params">(PNode _now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_now == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Tree is Empty now"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_now-&gt;lc) acend(_now-&gt;lc);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _now-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(_now-&gt;rc) acend(_now-&gt;rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    PNode _root;</span><br><span class="line">    bsTree() &#123; _root = <span class="keyword">new</span> NODE(); &#125;</span><br><span class="line">    bsTree(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n) &#123;</span><br><span class="line">        _root=<span class="keyword">new</span> NODE();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) insert(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PNode <span class="title">findLeftMax</span><span class="params">(PNode _rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_rt-&gt;rc==<span class="literal">NULL</span>) <span class="keyword">return</span> _rt;</span><br><span class="line">        <span class="keyword">return</span> findLeftMax(_rt-&gt;rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PNode <span class="title">findRightMin</span><span class="params">(PNode _rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_rt-&gt;lc==<span class="literal">NULL</span>) <span class="keyword">return</span> _rt;</span><br><span class="line">        <span class="keyword">return</span> findRightMin(_rt-&gt;lc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//============查找操作============</span></span><br><span class="line">    <span class="function">PNode <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        PNode tmp = _root;</span><br><span class="line">        <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data &gt; tmp-&gt;val) tmp = tmp-&gt;rc;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; tmp-&gt;val) tmp = tmp-&gt;lc;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; _root = insert(data,_root); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">earse</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; _root = earse(data,_root); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acend</span><span class="params">()</span> </span>&#123; acend(_root); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>忆 2019</title>
    <url>/2019/12/31/2019-ALL/</url>
    <content><![CDATA[<blockquote>
<p>动笔于 2019-12-11 14:54:09</p>
</blockquote>
<p><strong><em>人的记忆总是不牢靠的，时常会忘记一些可有可无的事情，渐渐的，过去就成了过去，誓言就成了分别。</em></strong></p>
<p>——<em>莫名奇妙的题记</em></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次写年度总结，诚言上半年的日子，已经忘却的七七八八，着实也想不起来什么印象深刻的事情，遂只好慢慢的想想，想来了，便再在晚上时候静静的写下来，做成回忆。留给未来的自己。</p>
<h2 id="年初参赛"><a href="#年初参赛" class="headerlink" title="年初参赛"></a>年初参赛</h2><h3 id="迷迷糊糊的回忆"><a href="#迷迷糊糊的回忆" class="headerlink" title="迷迷糊糊的回忆"></a>迷迷糊糊的回忆</h3><p>回想年初时候，具体细节已经记不太清了，那时候还留在生化的十一楼干着自己喜欢的事情，寒假回来之后，勉勉强强的每天跑了下步，不过看着<code>Keep</code>里面留下的记录，也就坚持了三四天而已，那时候真是元气满满啊，刚刚转入软件工程，每天过着幸福的日子，似乎没什么烦恼，没什么忧愁，回忆起来也没什么目标，第一次参赛是在期中左右吧，依稀记得名字是叫做团体程序设计天梯赛，比赛可能算是枯燥，坦言积分制更让人觉得这仿佛是场考试难以忍受，不过着实还是感到快乐了。差点忘了，之前的校内线下赛真的，真的很有趣。这个不是谎言，校内线下赛的非黑即白的评判，处处透露着暴力比拼的优雅，纯储备的竞争，就似拳击手一般，在赛场上拳拳到肉的厮杀，不过对象就是过去的自己，这种看似残酷与枯燥的竞争，正是我好喜的无聊的浪漫。</p>
<h3 id="福建程序设计省赛"><a href="#福建程序设计省赛" class="headerlink" title="福建程序设计省赛"></a>福建程序设计省赛</h3><p>最后去了福建省程序设计的省赛，这也算是第一次正式参加比赛吧，感谢我可爱的两位队友带我躺了一个铜，主办方的精心招待，嗯真的，它很美，最后滚榜的时刻，也充分意识到了差距与他人之大，虽然其实在赛中就已经体会到了，第一次想要变强，<del>可是为什么有迷惘了呢,哎</del>，于是乎上半年的参赛就这样结束了。</p>
<h2 id="接触线上的成长"><a href="#接触线上的成长" class="headerlink" title="接触线上的成长"></a>接触线上的成长</h2><p>其实讲真莫得什么成长，只不过知道了以后除了学校之外可以刷题的网站罢了。</p>
<p><code>CodeForces</code>，<code>Vjudge</code>，<code>LuoGu</code>，<code>Atcoder</code>，<code>Nowcoder</code>，…..</p>
<h2 id="大一下的结束"><a href="#大一下的结束" class="headerlink" title="大一下的结束"></a>大一下的结束</h2><blockquote>
<p>写于 2019-12-15 10:23:33</p>
</blockquote>
<p>大一下的回忆着实记不太轻了，不过，周学长带我步入编程大门的回忆确实清楚的记得，不过那些满满的回忆这里也写不下来，遂搁笔留在心中罢。</p>
<h3 id="XUJCOJ-Bye"><a href="#XUJCOJ-Bye" class="headerlink" title="XUJCOJ Bye~"></a>XUJCOJ Bye~</h3><p>大一接近尾声的时候，在XUJC-OJ上刷题的动力也越来越少了，可能是懒了吧。早早的就没了之前充满鸡血，能刷一个通宵的热血了，在大一结束的时候，也算正式的向XUJC-OJ说了声再见，提交数量渐渐变少，也渐渐的不再登录了，但美好的回忆和一步一步从无比幼稚到幼稚的成长，依然清楚的记录在每一次的提交之中，有时候无聊的翻阅和回忆不经会，噗嗤的笑出声来。</p>
<h3 id="对于学业的思考"><a href="#对于学业的思考" class="headerlink" title="对于学业的思考"></a>对于学业的思考</h3><p>坦言，没啥好说的，毕竟大一下学期，我并没有好好的努力读书，也不知道是迷茫，还是怎么的，不过时间悄然溜走的事实倒是，留下了真切的印记。</p>
<h2 id="在家的闲适时光"><a href="#在家的闲适时光" class="headerlink" title="在家的闲适时光"></a>在家的闲适时光</h2><p>大一结束后就早早的回了家，不过之前学长也交待完暑假集训的事情，不知道是期待还是兴奋，总之在莫名奇妙的感觉中暑假，就这样开始了，在家的日子悠哉游哉，都忘记有没有出过家门了，不过印象里好似是没有的，现在回味起来，还是觉得好不闲适，如果时间能一直停滞在暑假，那是多么小小的美好啊。</p>
<p>不过可惜的是，无论想象如何美好，时间并不会为之留下脚步，一切都还是慢慢的在向前流动，无论是人，亦或是时间。<del>该死的体重也在慢慢增加 ( 怒摔</del></p>
<h3 id="慵懒的一天"><a href="#慵懒的一天" class="headerlink" title="慵懒的一天"></a>慵懒的一天</h3><p>在家的慵懒一天，记得快到三点多了，才慢慢悠悠的起了床，迷迷糊糊的洗完了漱，方才想抓点东西来填一填”咕噜咕噜的肚子，定睛一看发现桌面上空空如也，遂困意再次袭来，摇摇晃晃的走到床边，感到寒意，关空调，裹上被子，醒来已是下午六点了。着实没什么好描述的，不过起床时候，透过阳台看见的天边那缕紫色与橙色相交织的光景，竟有种还在梦中之感。</p>
<h2 id="暑期集训"><a href="#暑期集训" class="headerlink" title="暑期集训"></a>暑期集训</h2><p>暑假集训的记忆早已经忘记的七七八八了，依稀记得的是，厦大的宿舍离校区真的好远，每天的集训课是完全听不大懂的，每天的早出晚归着实感动了自己，但是也收获到了，这个舞台很大，强者很多，想要变强的种子也是在那一刻，被深深的埋入土壤的吧。</p>
<ul>
<li>关于内心</li>
</ul>
<p>想要变强，想要自己搞个<code>CodeForces</code>的教练账号!</p>
<ul>
<li>实力</li>
</ul>
<p>实力是完全没有进步的，就连一丝一毫都没有。</p>
<ul>
<li>失去与获得</li>
</ul>
<p>本就一无所有，所以也就没啥失去之说，获得的也许许多多，不过更重要的是，算是找寻到了内心的呼唤。</p>
<h3 id="牛客暑期训练和多校联合训练"><a href="#牛客暑期训练和多校联合训练" class="headerlink" title="牛客暑期训练和多校联合训练"></a>牛客暑期训练和多校联合训练</h3><p>关于这个就真的只有一句话了，<strong>白给425软妹币</strong>，QWQ</p>
<h3 id="广州游记"><a href="#广州游记" class="headerlink" title="广州游记"></a>广州游记</h3><p>暑期集训到了大概一半的时候，广州的Bilibili World之旅就开始了，其实早就大一下的时候就早早的计划了起来，起初是打算弥补高考以后颓废在家里的不堪，不过后来也就不知不觉的期待了起来，广州之行是开心的，虽然自己的身体上发生了许许多多有趣的事情，或是痛苦，或是难堪，不过在广州的旅途，却是的的确确的快乐，尤其是老友相聚的喜悦尤甚。<br>感觉好玩的也有，第一次被顺丰送了美团的诧异，两天几乎没有吃到热吞吞的米饭的油腻，和在场子中人满为患的左右为难，说实话，场馆的的确确是小了点，而且第一次的走错路更让人脑子有点头疼，不过vip票收获的提早入场，的的确确的让人着实小爽了一丢丢。<del>当然荷包也瘪掉了233</del><br>离开的时候，记得广州还是很热很热的，回到厦门的时候，厦门下着小雨，然后突然的就边大了，之后越来越大，越来越大，大到想回家冲个热水澡，却堪堪的想起，自己原来呆在厦门。对了不得不提的是，回来的第一顿还是金拱门，oh my god，这真的是让人难受至极了。<br>广州回来以后没多久，暑期集训也结束了，又回到了漳州的一个世外桃源中，在那里静静的等待着大二的开始。</p>
<h2 id="大二上的开始"><a href="#大二上的开始" class="headerlink" title="大二上的开始"></a>大二上的开始</h2><p>大二上的记忆依稀的模模糊糊，依稀记得那时候，学长已经从台湾交流完回来，一个学期的不见变得有些许生疏，或许是我实在过于拘谨。</p>
<h3 id="迷茫"><a href="#迷茫" class="headerlink" title="迷茫"></a>迷茫</h3><p>大二开始的时候，十分迷茫，回头看，当初的自己简直就像什么都没学到，却已经觉得自己无敌的小白鼠，开始寻找能施展自己的舞台，迷茫如何寻得施展自己舞台的途径，以及最适合通向自己理想未来的路径。虽然对于自己的人生思考的确越早越好，但是过于急躁和焦虑却使得自己更加迷茫，假设能回到过去，我会静静的走到原来的我面前，认真的说，慢慢来吧，不要太急躁，也不要什么都不思考，不如分开来，先慢慢读懂自己，然后再去默默追寻自己。<br>不过按照我对自己的了解，那个小屁孩估计也是不会听的吧，比较那玩意一直琢磨不透。</p>
<h3 id="四人间到二人间"><a href="#四人间到二人间" class="headerlink" title="四人间到二人间"></a>四人间到二人间</h3><p>没什么好说的，我喜欢单人间，二人间不过是退而求其次的选择，如果能在经济支撑范围内实现单人间，毫无疑问，单人间是首选。</p>
<h2 id="Blog-的正式上线"><a href="#Blog-的正式上线" class="headerlink" title="Blog 的正式上线"></a>Blog 的正式上线</h2><blockquote>
<p>已经莫得了</p>
</blockquote>
<ul>
<li>meskill.top </li>
</ul>
<blockquote>
<p>正在使用</p>
</blockquote>
<ul>
<li><a href="http://mirasire.xyz"><strong>mirasire.xyz</strong></a> </li>
</ul>
<h3 id="meskill-top"><a href="#meskill-top" class="headerlink" title="meskill.top"></a>meskill.top</h3><p>关于<strong>meskill.top</strong>的所有记忆都已经遗忘的差不多了，留下的只有无尽的失落，仅存的记忆是关于它的备案，那晚上我被舍友的鼾声醒了一宿，于是便寻思找些好玩的事情干干，便一直倒腾meskill.top到了天明。至于我抛弃meskill.top的原因我倒是依然清楚的记得，更准确的说应该是抛弃了meskill吧。</p>
<h3 id="mirasire-xyz"><a href="#mirasire-xyz" class="headerlink" title="mirasire.xyz"></a>mirasire.xyz</h3><p>不知道是为什么突然的就不想使用meskill了，莫名其妙的，不可理喻的，突然就不想使用了，如果硬是想说原因，可能就是不想再和原来一样了吧，想要找寻真的自己，亦或是重拾小时候被自己抛弃的自己，之后就慢慢的想要使用mirasire了，蛮奇奇怪怪的，mirasire是没什么特别含义的，当初也是找了两个很美丽的词语各切一半，给拼起来的，没记错的话是<strong>希望</strong>和<strong>奇迹</strong>，是有希望就有奇迹，还是其他什么莫名奇妙的原因也记不清了。</p>
<p>mirasire.xyz就这样成了新的域名，我也慢慢的喜欢上了这个名字，喜欢上了现在的我。</p>
<h2 id="ICPC-上海区域赛"><a href="#ICPC-上海区域赛" class="headerlink" title="ICPC 上海区域赛"></a>ICPC 上海区域赛</h2><blockquote>
<p><strong>回忆</strong> | <a href="http://mirasire.xyz/2019/11/28/19SHUICPC"><strong>Here</strong></a></p>
</blockquote>
<p>实话说来，明明是昨日发生，却依然觉得事情已经过去了很久的样子，基调应该是只有后悔罢，还有对自身实力的不齿，总感觉有着千言万语想要诉说，不过等着那些留到嘴边，就只剩下 “<strong>下次再来的话语了</strong>“</p>
<h2 id="慢悠悠的思考-静悄悄的总结"><a href="#慢悠悠的思考-静悄悄的总结" class="headerlink" title="慢悠悠的思考-静悄悄的总结"></a>慢悠悠的思考-静悄悄的总结</h2><p>想了很久也不知道该说什么，零碎着断断续续的，慢悠悠的浅尝辄止的，我的思考总是这样，思来想去最后也没有的到什么结果，留下的只有莫名奇妙的感情，间歇性的一腔热血，和一些不明所以的文字了，不过没有什么实质性的言论总是不好的，于是还是胡言乱语少许，当作自己的年终思考吧。要说思考，不如说是困扰吧，今年的困扰蛮多的，关于未来啊，关于职业啊，关于爱情，还有就是关于我如何存在，或者说我是谁？思考起来就没完没了了，所以啊思来想去，想去思来，也就随便的找了几个心安理得的答案，开始敷衍着自己开始了继续的生活。<br>关于未来和职业什么的，是没什么好的结论的，想着，想着，未来的目标姑且算是想要，躺着卡里的余额也能自动增长，拜托无聊的关于钱的烦恼，然后去干自己喜欢的事情，这大概就是我期望的未来吧，职业呢，不知道，听说写代码来钱蛮快的，欸嘿嘿嘿嘿。从小就不善于处理感情什么的东西，不过对于自己的长相还是有点自知之明的，虽然天天自恋，不过怎么说呢，也在慢慢的改变吧，希望以后能在早上看见自己就有愉快的心情的这样子的小小目标。所以啊，爱情这种东西，我还是选择等待，也不知道是等待准备完毕的自己，还是在等待处在迷雾里面的她，自己呢，我也不知道我是谁，如果说名字什么的，物种什么的，我倒是知晓的清清楚楚，不过呢那终究不是我，我到底是一个怎么样子的存在，这才是我想要探寻的，这种疑惑一直围绕在我脑中，挥之不去，低落时就迸发出来，感觉还蛮难受的，后来发现，其实我思故我在，我思故我在，便想留下什么东西，还想解析自己的存在什么的，就搭建了这个博客，记录下自己的莫名其妙，也方便更好的了解自己吧。</p>
<h2 id="关于2020"><a href="#关于2020" class="headerlink" title="关于2020"></a>关于2020</h2><p>我希望变得更加强大，变得更加智慧，变得更加寡言多思，变得更加的聪慧，变得有当面说出 <strong>“hi 好久不见啊”</strong> 的勇气。</p>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC#147 - F. Sum Difference</title>
    <url>/2019/12/17/ABC-147-F/</url>
    <content><![CDATA[<p>好题，一道很思维的好题目。<del>也可能因为是我太菜了,QWQ</del></p>
<blockquote>
<p>题目链接 | <a href="https://atcoder.jp/contests/abc147/tasks/abc147_f" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>数列一共有$N$项，每个数列满足$A_1 = X \ , \ A_{i+1} = A_{i} + D$。</p>
<p><strong>求这个等差数列的子集的和有几种不同结果？</strong> (可以选一个也可以选全部)</p>
<p><strong>限制</strong></p>
<ul>
<li>$ -10^8 \leq X,D \leq 10^8 $</li>
<li>$ 1 \leq N \leq 2 * 10^5 $</li>
<li>输入都是整数</li>
</ul>
<blockquote>
<p>输入</p>
</blockquote>
<p><strong><em>单组案例</em></strong></p>
<p>输入三个数字代表$N \ X \ D$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">14</span> <span class="number">20</span>	<span class="comment">//N X D</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">49805</span>		<span class="comment">//有49805种不同的结果</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$D$等于<strong>0</strong>，只要讨论$X=0$和$X \not= 0$的情况即可。</p>
<p>因此我们假设$D &gt; 0$，即设我们要选$k$个元素，求得的和为$T$，我们可以笼统的将$T$表示为$T = k*X + I*D$，之后我们思考$I$的取值范围。</p>
<script type="math/tex; mode=display">
\begin{aligned}
T &= k \times X + I \times D \ , \ \ k \in [0,N), k \in \mathbb{Z} \\

&\Rightarrow 1+2+3+4+5+....+(k-1) \leq I \leq (N-1)+(N-2)+(N-3)+...+(N-k) \\
&\Rightarrow \sum_{i=0}^{k-1}{i} \leq I \leq \sum_{i=1}^{k}{N-i} \\

\Longrightarrow & \\

T &= k \times X + I \times D \ , \ \ I \in [\sum_{i=0}^{k-1}{i} , \sum_{i=1}^{k}{N-i}] k \in [0,k), k \in \mathbb{Z} \\
  &= (k \times X) \bmod D + I \times D \ , \ \ I \in [\lfloor k \times X \rfloor + \sum_{i=0}^{k-1}{i} , \lfloor k \times X \rfloor + \sum_{i=1}^{k}{N-i}] k \in [0,k), k \in \mathbb{Z} \\

\end{aligned}</script><p>到这边发现，如果能证明当 $(k \times X ) \bmod D$ 不相等的情况下$T$的取值必然不相等，那么原来的问题就转化为了对有相同的$(k \times X) \bmod D$，求区间合并的问题。</p>
<p>对于这个证明我们可以使用反证法。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&m_1 = (k_1 \times X) \bmod D  &T_1 &= m_1 + I_1 \times D \\

&m_2 = (k_2 \times X) \bmod D  &T_2 &= m_2 + I_2 \times D \\

\\

&T_1 = T_2 \\ 
&\Rightarrow m_1 + I_1 \times D =  m_2 + I_2 \times D \\
&\Rightarrow m_1 - m_2 = (I_2-I_1) \times D
\end{aligned}
\\
\begin{aligned}
\\
&\because 0 \leq m_1,m_2 < D \ or \ -D < m_1,m_2 \leq 0 \\
&\therefore  m_1 - m_2 < D \\
&\because m_1 - m_2 \not= 0 \\
&\therefore  T_1 != T_2 \\
\end{aligned}</script><p>所以这题的解法为对$(k \times X) \bmod D$ 相等的区间合并，并加上所有的区间长度。这边说的区间长度指$I$的区间长度。</p>
<p>对于$D&lt;0$的情况我们只要将，$X,D$都乘上$-1$即可。</p>
<p>由于主要计算在于排序所以，所以时间复杂度为$O(NlogN)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span>	<span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SECTION</span> &#123;</span></span><br><span class="line">    ll l,r;</span><br><span class="line">    SECTION() &#123;&#125;</span><br><span class="line">    SECTION(ll l,ll r):l(l),r(r) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> SECTION&amp; oth) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l==oth.l) <span class="keyword">return</span> r &lt; oth.r;</span><br><span class="line">        <span class="keyword">return</span> l &lt; oth.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> SECTION&amp; oth) <span class="keyword">const</span> &#123; <span class="keyword">return</span> l==oth.l&amp;&amp;r==oth.r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt; idx;</span><br><span class="line"><span class="built_in">vector</span>&lt;SECTION&gt; sec[maxn];</span><br><span class="line">ll N,X,D;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    ll kl=<span class="number">0</span>,kr=<span class="number">0</span>,key,cnt = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; D;</span><br><span class="line">    <span class="keyword">if</span>(D==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!X) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; N+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D&lt;<span class="number">0</span>) &#123;	<span class="comment">//D &lt; 0 的情况</span></span><br><span class="line">        X*=<span class="number">-1</span>;</span><br><span class="line">        D*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=N; i++) &#123;</span><br><span class="line">        key = i*X;</span><br><span class="line">        ll bb = key%D;</span><br><span class="line">        l = r = key/D;</span><br><span class="line">        l+=kl; r+=kr;</span><br><span class="line">        <span class="keyword">if</span>(idx[bb]==<span class="number">0l</span>l) idx[bb] = ++cnt;</span><br><span class="line">        sec[idx[bb]].push_back(&#123;--l,r&#125;);</span><br><span class="line">        kl+=i,kr+=N-i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++) &#123;</span><br><span class="line">        SECTION tp;</span><br><span class="line">        sort(sec[i].begin(),sec[i].end());</span><br><span class="line">        tp = sec[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(SECTION now: sec[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(now.l &lt;= tp.r) tp.r = max(tp.r,now.r);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += tp.r-tp.l;</span><br><span class="line">                tp = now;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(now == sec[i].back()) &#123;</span><br><span class="line">                ans += tp.r-tp.l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>数学</tag>
        <tag>idea</tag>
        <tag>ABC</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC#147 - D. Xor Sum 4</title>
    <url>/2019/12/10/ABC-147-D/</url>
    <content><![CDATA[<p>关于数值和进制转换的深刻理解的题，无敌感谢qsc学姐的指点!!</p>
<blockquote>
<p>题目链接 | <a href="https://atcoder.jp/contests/abc147/tasks/abc147_d" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$N$个数，从$A_1,A_2,……,A_n$，<br>求 $\sum_{i=1}^{N-1}\sum_{j=i+1}^{N} (A_i \mbox{ XOR } A_j)$ % $(10^9+7)$ 的值</p>
<blockquote>
<p>输入</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>			<span class="comment">//N</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span>	<span class="comment">//A(1) ~ A(10)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">237</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个是一个有关<strong>进位理解</strong>的题目，假设我们取消对二进制每一位都是 $0/1$ 的限制, 那么我们发现二进制 $101$ 和 $21$ 的值是一样的。</p>
<p>即如果<strong>不考虑进位操作</strong>，那么我们可以用每一位的权相加最后再乘上相应的奇数来求得最后的答案。</p>
<p>这样我们每一位(只有0,1)进行<code>^</code>考虑，由于转化为二进制之后所有的<code>^</code>只有两种情况，即<code>相等^</code>和<code>不相等^</code>，由于<code>^</code>运算，所以只有<code>不相等^</code>才会得到值，并且<strong>值为1</strong>。</p>
<p>原题就等于 $\sum_{i=0}^{60} (第i位的0的个数 * 第i位的1的个数 {*} 2^i)$ % $(10e9+7)$。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">100</span>,MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll arr[maxn],bits[maxn][<span class="number">2</span>],tt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n,ans = <span class="number">0</span>;</span><br><span class="line">    tt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">60</span>; i++) &#123;</span><br><span class="line">        tt[i] = tt[i<span class="number">-1</span>]*<span class="number">2</span>%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//slove()</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;arr[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=<span class="number">60</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            bits[k][arr[i]%<span class="number">2</span>]++;</span><br><span class="line">            arr[i]/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans+bits[k][<span class="number">0</span>]*bits[k][<span class="number">1</span>]%MOD*tt[k]%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    ans %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>ABC</tag>
        <tag>AtCoder</tag>
        <tag>xor</tag>
        <tag>数位统计</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3279 Fliptile</title>
    <url>/2019/12/09/POJ3279/</url>
    <content><![CDATA[<p>这题虽然是在<strong>Kuangbin搜索专题</strong>，不过其实个人感觉更像<strong>枚举。</strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-3279#author=1701400204" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><em>引用了SWUN2018的翻译</em></p>
<p>给你一个<strong>0/1</strong>矩阵，矩阵大小为$M * N \quad (1 \leq M , N \leq 15 )$<br>每次操作选择一个格子(也可以不选)，使得<strong>该格子与上下左右四个格子</strong>的值翻转。即<strong>0变为1，1变为0</strong>。<br><strong>至少多少次操作</strong>可以使得矩阵中所有的值变为0？<br>请输出翻转方案，若没有方案，输出”<strong>IMPOSSIBLE</strong>” 。</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>第一行输入两个数$M$和$N$。<br>接下来$M$行，每行$N$个数，其值只为<strong>0或1</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>输出$M$行，每行$N$个数。<br>每个数代表该位置翻转次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>这里的状态，代表操作的状态</p>
</blockquote>
<p><strong>显然每个地方最多只翻一次，偶数效果等于0，奇数次效果等于1</strong></p>
<p>先考虑<strong>朴素暴力</strong>，即对每一层进行枚举，由于每一层的元素个数是$m$个，只有<strong>两种</strong>状态，所以<strong>每一层的状态数为$2^m$个</strong>，由于有$n$层，所以<strong>总的状态数为$2^{n*m}$次。</strong></p>
<p>这样子显然是<strong>超时的</strong>，我们发现，假设我们已经确定上一层的状态，那么下一层的操作只能并且<strong>必须</strong>是在<strong>1</strong>的棋子下面进行操作，换言之，就是<strong>只要上一层状态确定，下一层只有一种翻转方法</strong>。</p>
<p><strong>由此</strong>我们只要暴力<strong>枚举第一层的状态</strong>，这样<strong>状态数</strong>就下降到了$2^n$次，然后按照上面的操作进行翻转，全部操作完毕后，<strong>判断最后一行是否全为0即可</strong>。</p>
<p><em>小坑: 这题中的字典序是从右向左</em></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> mazz[maxn][maxn],grid[maxn][maxn],ans[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">5</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">legal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ans[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nx,ny;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(legal(nx,ny)) grid[nx][ny]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i][j],<span class="string">" \n"</span>[j==(m<span class="number">-1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mazz[i][j]);</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">1</span>&lt;&lt;m,bsk;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;end; i++) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        bsk = i;</span><br><span class="line">        <span class="built_in">memcpy</span>(grid,mazz,<span class="keyword">sizeof</span>(mazz));</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;m; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bsk%<span class="number">2</span>) filp(<span class="number">0</span>,k);</span><br><span class="line">            bsk/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;m; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[j<span class="number">-1</span>][k]) filp(j,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,j=n<span class="number">-1</span>; k&lt;m; k++) </span><br><span class="line">            <span class="keyword">if</span>(grid[j][k]) &#123;</span><br><span class="line">                ok = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">            slove();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ok) <span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p><strong>时隔一年才完结简单搜索专题，就记下此题为耻辱柱，鞭策前行</strong></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>POJ</tag>
        <tag>二进制枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3416 Marriage Match IV</title>
    <url>/2019/12/08/HDU3416/</url>
    <content><![CDATA[<p><strong><em>需要仔细的读题，真的真的很重要!!!</em></strong></p>
<ul>
<li><strong>有重复的边，并且是有向图</strong></li>
<li><strong>最短路+最大流</strong></li>
</ul>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/HDU-3416" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong>这是一张有向图，并且有重边 !!!</strong></p>
<p>有个人，就叫<strong>小王</strong>好了,<strong>小王</strong>从$A$到$B$，去找女朋友约会，由于小王想快点找到女朋友，所以小王总是走最短路，现在规定每条路径只能走一次。</p>
<p><strong>问:</strong> 小王<strong>最多能去几次</strong>?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>先输入一个$T$，代表有$T$组案例。<br>接下来输入$n，m$，代表有$n$个城市和$m$条有向边。<br>之后的$m$行，每行输入$u,v,w$，代表$dist \langle u,v \rangle  = w$<br>之后输入一行$s,t$，代表<strong>小王和他女朋友</strong>在的城市。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>每行代表小王<strong>最多能去几次</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果<strong>没有</strong>小王的要走最短路的<strong>限制</strong>，答案是所有边的<strong>容量为1的最大流</strong>。</p>
<p>由于在此题要求每次<strong>只走最短路</strong>，所以我们需要先跑个最短路算法，然后依照最短路得出的<strong>最短距离</strong>，建图跑最大流，得到的就是答案。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===For Dijkstra====</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DEdge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,w;</span><br><span class="line">    DEdge() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">def</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> wi)</span> </span>&#123; to=a; nxt=b; w=wi; &#125;</span><br><span class="line">&#125; de[<span class="number">200200</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STATUS</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx,td;</span><br><span class="line">    STATUS() &#123;&#125;</span><br><span class="line">    STATUS(<span class="keyword">int</span> idx,<span class="keyword">int</span> td):idx(idx),td(td) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> STATUS&amp; oth) <span class="keyword">const</span> &#123; <span class="keyword">return</span> td &gt; oth.td; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[maxn],dist[maxn],dcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    de[++dcnt].def(u,head[v],w); head[v] = dcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    STATUS now = &#123;s,<span class="number">0</span>&#125;;</span><br><span class="line">    priority_queue&lt;STATUS&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>.push(now);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">        now = <span class="built_in">list</span>.top();</span><br><span class="line">        <span class="built_in">list</span>.pop();</span><br><span class="line">        <span class="keyword">if</span>(dist[now.idx] &lt; now.td) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now.idx]; i!=<span class="number">-1</span>; i=de[i].nxt) &#123;</span><br><span class="line">            DEdge&amp; v = de[i];</span><br><span class="line">            <span class="keyword">if</span>(v.w+now.td &lt; dist[v.to]) &#123;</span><br><span class="line">                dist[v.to] = now.td + v.w;</span><br><span class="line">                <span class="built_in">list</span>.push(&#123;v.to,dist[v.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> u,v,iw;</span><br><span class="line">    <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="comment">//Init</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        dcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            dist[i] = INF;</span><br><span class="line">            head[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dinic.init(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;iw);</span><br><span class="line">            DaddEdge(v,u,iw); <span class="comment">//!!!注意是有向边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t);</span><br><span class="line">        <span class="comment">//================跑最短路===================</span></span><br><span class="line">        dijkstra(s);</span><br><span class="line">        <span class="keyword">if</span>(dist[t] == INF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//================最短路建图===================</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; j!=<span class="number">-1</span>; j=de[j].nxt) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[de[j].to] == dist[i]+de[j].w) dinic.AddEdge(i,de[j].to,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dinic.Maxflow(s,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>HDUOJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>HDUOJ</tag>
        <tag>最大流</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3081 Marriage Match II</title>
    <url>/2019/12/04/HDU3081/</url>
    <content><![CDATA[<p><code>题意比较难理解</code>，<strong>并查集 + 匈牙利算法</strong></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/HDU-3081" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个<strong>女孩</strong>和<strong>男孩</strong>在玩游戏，游戏规则是<strong>一个女孩找一个男孩当她男朋友</strong>玩过家家。当<strong>每个女孩都找到男朋友</strong>后一轮<strong>进行下一轮</strong>游戏，在之后的游戏中<strong>女孩的男朋友不能与之前的男朋友相同</strong>，如果有<strong>女孩子找不到男朋友则游戏结束</strong>。</p>
<p>女孩寻找男孩满足如下<strong>两个要求:</strong></p>
<ul>
<li>如果男孩$b$和女孩$g$<strong>没有吵架过</strong>，那么女孩$g$会选男孩$b$做男朋友。</li>
<li>如果女孩$og$和女孩$g$是朋友(<code>此时的g为上面的g相同</code>),那么女孩$og$也可以选男孩$b$做男朋友。<strong>女孩之间的友谊可以传递。</strong></li>
</ul>
<p><strong>问:</strong> 游戏<strong>最多能玩几轮</strong>?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>先输入一个$t$代表有$t$组案例。<br><strong>对于每组案例:</strong></p>
<ol>
<li>先输入$n,m,f$代表$n$个男孩，女孩，$m$个女孩和男孩的关系，$f$个女孩之间的朋友关系。</li>
<li>之后的$m$内每行输入两个整数$g，b$代表女孩$g$和男孩$b$没有吵架过( 即$g$可以选$b$做男朋友)。</li>
<li>之后的$f$内每行输入两个整数$g1，g2$代表女孩$g1$和女孩$g2$是朋友关系。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>		<span class="comment">//只有一组案例</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span>		<span class="comment">//n m f</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span>		<span class="comment">//g b 先输入女孩，再输入男孩</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span>		<span class="comment">//g1 g2 是朋友关系</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>	<span class="comment">//表示游戏最多能玩 2 轮</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于发现数据量很小，所以我们可以使用<strong>匈牙利算法</strong>来找<strong>完美匹配</strong>，每次找到<strong>完美匹配就对匹配进行删边</strong>，如果没找到就退出答案。<strong>找到完美匹配的次数</strong>就是答案。</p>
<p>观察女孩子找男朋友的<strong>第二个操作由于要维护的是朋友关系</strong>，所以用<strong>并查集来对女孩之间的关系进行维护</strong>即可。</p>
<p>建图是暴力建图，首先给出的男女关系必为一条边，之后从男生开始，每次找到有边相连的时候，遍历<strong>男生当前相连的女孩子</strong>和<strong>其他女孩子</strong>的关系，用并查集判断是不是朋友，<strong>是就进行连边</strong>。</p>
<p>没算错的话，时间复杂度是 $O(n^3)$ 的<del>优秀</del>算法</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Let boy 1+n-n&lt;&lt;1 gril-1-n</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">230</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f; <span class="comment">//people m-&lt;b,g&gt; f-&lt;g,g&gt;</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn],grp[maxn][maxn],match[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================Unionset===========================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findF</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = u,ans;</span><br><span class="line">    <span class="keyword">while</span>(fa[tmp] != tmp) &#123; tmp = fa[tmp]; &#125;</span><br><span class="line">    ans = tmp;</span><br><span class="line">    <span class="keyword">while</span>(fa[u] != ans) &#123;</span><br><span class="line">        tmp = fa[u];</span><br><span class="line">        fa[u] = ans;</span><br><span class="line">        u = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ra = findF(a);</span><br><span class="line">    <span class="keyword">int</span> rb = findF(b);</span><br><span class="line">    <span class="keyword">if</span>(ra==rb) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> fa[ra] = rb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================Hungary===========================</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=n+<span class="number">1</span>; v&lt;=end; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(grp[u][v] &amp;&amp; !vis[v]) &#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v] || isMatch(match[v])) &#123;</span><br><span class="line">                match[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xyl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//It's necessery to empty during every beginning</span></span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">int</span> check = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        check += isMatch(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(check==n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================Build Graph===========================</span></span><br><span class="line"><span class="comment">//make girl connet to boy</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;=end; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grp[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(findF(j) == findF(k)) &#123;</span><br><span class="line">                        grp[i][k] = grp[k][i] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================Main===========================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(xyl()) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;=(n*<span class="number">2</span>); i++) grp[i][match[i]] = grp[match[i]][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> b,g;</span><br><span class="line">    <span class="keyword">int</span> g1,g2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="comment">//don't forget init</span></span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">        <span class="built_in">memset</span>(grp,<span class="number">0</span>,<span class="keyword">sizeof</span>(grp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=(n&lt;&lt;<span class="number">1</span>); i++) fa[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;g,&amp;b);</span><br><span class="line">            b+=n;						<span class="comment">//由于男，女在输入的时候都是1-n，所以对男生进行了重新标记。</span></span><br><span class="line">            grp[g][b] = grp[b][g] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;f; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;g1,&amp;g2);</span><br><span class="line">            unite(g1,g2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//OK make sure the union set is OK</span></span><br><span class="line">        buildGraph();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,slove());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>HDUOJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>匈牙利算法</tag>
        <tag>并查集</tag>
        <tag>HDUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾话的循环艺术</title>
    <url>/2019/12/01/LJH1/</url>
    <content><![CDATA[<p><strong>无聊的抱怨和垃圾话，真实的单曲循环。</strong></p>
<a id="more"></a>
<p>清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心清理卫生间真的好恶心</p>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
        <tag>吐槽</tag>
        <tag>抱怨</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3338 Kakuro Extension</title>
    <url>/2019/11/30/HDU3338/</url>
    <content><![CDATA[<p>一道<strong>行列建图</strong>的题目。<br><strong>注意点: </strong> 如何<del>优雅</del><strong>暴力</strong>建图。</p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/HDU-3338" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>类似数独，会有<strong>黑色格子</strong>和<strong>白色格子</strong>，<strong>白色格子</strong>用来填空，填的<strong>值的范围</strong>是<strong>1-9</strong>，每个黑色格子可能存在两个量，$a$<strong>\</strong>$b$，$a$表示<strong>向下连续</strong>白色格子的<strong>和</strong>，$b$表示<strong>向右连续</strong>白色格子的<strong>和</strong>，题目要求就一组任意解并且<strong>输出</strong>。</p>
<blockquote>
<p>输入</p>
</blockquote>
<p><code>多组输入</code></p>
<p>针对<strong>每组案例:</strong><br>第一行输入$n$和$m$，代表<strong>格子的大小</strong>是$n*m$<br>接下来输入$n*m$的矩阵，每个元素由7个字符构成，含义分别为</p>
<ul>
<li><code>XXXXXXX</code> 为不做要求格子</li>
<li><code>.......</code> 为白色格子</li>
<li><code>AAA\BBB</code> $AAA$为<strong>向下连续的</strong>白色格子的<strong>和</strong>，$BBB$为<strong>向右连续的</strong>白色格子的和。如果值为<strong>XXX</strong>代表不做要求。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span>							<span class="comment">//6*6的格子</span></span><br><span class="line">XXXXXXX XXXXXXX <span class="number">028</span>\XXX <span class="number">017</span>\XXX <span class="number">028</span>\XXX XXXXXXX		<span class="comment">//输入格子信息</span></span><br><span class="line">XXXXXXX <span class="number">022</span>\<span class="number">022</span> ....... ....... ....... <span class="number">010</span>\XXX</span><br><span class="line">XXX\<span class="number">034</span> ....... ....... ....... ....... .......</span><br><span class="line">XXX\<span class="number">014</span> ....... ....... <span class="number">016</span>\<span class="number">013</span> ....... .......</span><br><span class="line">XXX\<span class="number">022</span> ....... ....... ....... ....... XXXXXXX</span><br><span class="line">XXXXXXX XXX\<span class="number">016</span> ....... ....... XXXXXXX XXXXXXX</span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line">XXXXXXX <span class="number">001</span>\XXX <span class="number">020</span>\XXX <span class="number">027</span>\XXX <span class="number">021</span>\XXX <span class="number">028</span>\XXX <span class="number">014</span>\XXX <span class="number">024</span>\XXX</span><br><span class="line">XXX\<span class="number">035</span> ....... ....... ....... ....... ....... ....... .......</span><br><span class="line">XXXXXXX <span class="number">007</span>\<span class="number">034</span> ....... ....... ....... ....... ....... .......</span><br><span class="line">XXX\<span class="number">043</span> ....... ....... ....... ....... ....... ....... .......</span><br><span class="line">XXX\<span class="number">030</span> ....... ....... ....... ....... ....... ....... XXXXXXX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>对于每组案例输出$n*m$的矩阵代表答案。</p>
<p>其中非白色格子用 <strong><code>_</code></strong> 表示，白色格子内填写数字$ans$ , $ 1 \leq ans \leq 9$，之间空一个空格<code>&lt;space&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_ _ _ _ _ _</span><br><span class="line">_ _ <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> _</span><br><span class="line">_ <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line">_ <span class="number">6</span> <span class="number">8</span> _ <span class="number">7</span> <span class="number">6</span></span><br><span class="line">_ <span class="number">9</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> _</span><br><span class="line">_ _ <span class="number">7</span> <span class="number">9</span> _ _</span><br><span class="line">_ _ _ _ _ _ _ _</span><br><span class="line">_ <span class="number">1</span> <span class="number">9</span> <span class="number">9</span> <span class="number">1</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line">_ _ <span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">1</span> <span class="number">9</span></span><br><span class="line">_ <span class="number">1</span> <span class="number">3</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line">_ <span class="number">6</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">9</span> <span class="number">2</span> _</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于题目保证有一组解，所以容易发现对于黑色来说<strong>所有列的和等于所有行的和</strong>，而这些和都由<strong>白色格子内填入的数字</strong>得到。这样我们就能很有了，一个模型，将白色的点放在列和行之间即可。</p>
<blockquote>
<p>这边可以发现白色点连接行$i$列$j$的具体意义为<strong>白色点的坐标位置</strong>，因此对于<strong>白色边来说不存在一连多</strong>的问题，用最大流可以得到一组解。</p>
</blockquote>
<p>注意由于最大流算法<strong>跑完后</strong>，可能会出现<strong>流量为0的情况</strong>，所以我们要<strong>限制进行预处理</strong>，然后改变白色边的容量为$0 \sim 8$即可。<br>我们假设列限制为$A$类点，行限制为$B$类点，白色格子为$C$类点。</p>
<p><strong>建图方式:</strong></p>
<ul>
<li>$&lt; s, a &gt; , a \in A$ 流量为 每个列目标的和</li>
<li>$&lt; a, c &gt; , a \in A , c \in C$ 流量为 $0 \sim 8$</li>
<li>$&lt; c, b &gt; , c \in C , b \in B$ 流量为 $0 \sim 8$</li>
<li>$&lt; B, t &gt; , b \in B$ 流量为 每个行目标的和</li>
</ul>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) printf(#x <span class="meta-string">"= %d\n"</span>,x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define the const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxCol = <span class="number">120</span>,MaxRow = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span>+<span class="number">100</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 targe for vertial | 1 targe for horizontal</span></span><br><span class="line"><span class="keyword">int</span> grid[MaxCol][MaxRow][<span class="number">2</span>],idx[MaxCol][MaxRow]; </span><br><span class="line"><span class="keyword">bool</span> isWhite[MaxCol][MaxRow];</span><br><span class="line"><span class="keyword">char</span> assit[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        <span class="comment">//Init</span></span><br><span class="line">        <span class="keyword">int</span> vCnt=<span class="number">0</span>,hCnt=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> subs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//It's for array Init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m ;j++) &#123;</span><br><span class="line">                isWhite[i][j] = <span class="number">0</span>;</span><br><span class="line">                idx[i][j] = grid[i][j][<span class="number">0</span>] = grid[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read in</span></span><br><span class="line">        <span class="keyword">int</span> as=<span class="number">0</span>,bs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m ;j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %s"</span>,assit);</span><br><span class="line">                <span class="keyword">if</span>(assit[<span class="number">3</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    idx[i][j] = ++cnt;</span><br><span class="line">                    isWhite[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//Do It For vertial</span></span><br><span class="line">                    isWhite[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(assit[<span class="number">0</span>] != <span class="string">'X'</span>) &#123;</span><br><span class="line">                        grid[i][j][<span class="number">0</span>] = <span class="number">100</span>*(assit[<span class="number">0</span>]-<span class="string">'0'</span>) + <span class="number">10</span>*(assit[<span class="number">1</span>]-<span class="string">'0'</span>) + assit[<span class="number">2</span>]-<span class="string">'0'</span>;</span><br><span class="line">                        vCnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        grid[i][j][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Do It For horizontal</span></span><br><span class="line">                    <span class="keyword">if</span>(assit[<span class="number">4</span>] != <span class="string">'X'</span>) &#123;</span><br><span class="line">                        grid[i][j][<span class="number">1</span>] = <span class="number">100</span>*(assit[<span class="number">4</span>]-<span class="string">'0'</span>) + <span class="number">10</span>*(assit[<span class="number">5</span>]-<span class="string">'0'</span>) + assit[<span class="number">6</span>]-<span class="string">'0'</span>;</span><br><span class="line">                        hCnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        grid[i][j][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set the s and the t;</span></span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        t = vCnt + hCnt + cnt +<span class="number">12</span>;</span><br><span class="line">        dinic.init(t);</span><br><span class="line">        vCnt = hCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//preprocessing with the graph &amp;&amp; build the graph</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// do for the horizontal</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            subs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isWhite[i][j]) subs++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j][<span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    grid[i][j][<span class="number">1</span>] -= subs;</span><br><span class="line">                    subs = <span class="number">0</span>;</span><br><span class="line">                    dinic.AddEdge(s,cnt+(++hCnt),grid[i][j][<span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">//start to build the graph</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;m&amp;&amp;isWhite[i][k]; k++) dinic.AddEdge(cnt+hCnt,idx[i][k],<span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//do for the vertial</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            subs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isWhite[j][i]) subs++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[j][i][<span class="number">0</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">                    grid[j][i][<span class="number">0</span>] -= subs;</span><br><span class="line">                    subs = <span class="number">0</span>;</span><br><span class="line">                    dinic.AddEdge(cnt+hCnt+(++vCnt),t,grid[j][i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="comment">//start to build the graph</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;n&amp;&amp;isWhite[k][i]; k++) dinic.AddEdge(idx[k][i],cnt+hCnt+vCnt,<span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Let's dance~</span></span><br><span class="line">        dinic.Maxflow(s,t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j) <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">if</span>(isWhite[i][j]) &#123;</span><br><span class="line">                    Edge&amp; e2 = dinic.edges[dinic.G[idx[i][j]][<span class="number">1</span>]];</span><br><span class="line">                    <span class="keyword">int</span> ans2 = e2.flow;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans2+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'_'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>HDUOJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>HDUOJ</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2732 Leapin&#39; Lizards</title>
    <url>/2019/11/28/HDU2732/</url>
    <content><![CDATA[<p><strong>本题注意:</strong> 输出时候的<strong>语法单复数</strong>和<strong>d可能为4</strong> <del>数据出了锅?</del></p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/HDU-2732" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个$n*m$的柱子阵列，初始有一些蜥蜴🦎站在<strong>柱子上</strong>，每个蜥蜴的<strong>跳跃距离是d</strong>，这边<strong>判断</strong>蜥蜴是否能跳到另外一个柱子<strong>的条件是</strong>两个两个柱子之间的<strong>曼哈顿距离</strong>。</p>
<ul>
<li>先给出一个$n*m$代表<strong>每个柱子最多承受的起跳次数</strong>，超过柱子便会倒塌。</li>
<li>之后给出一个$n*m$代表<strong>每个蜥蜴🦎所在的初始位置</strong>。</li>
</ul>
<p><strong>尽可能的让阵列中的蜥蜴逃离，跳出阵列即代表逃离成功。</strong></p>
<p><strong>问:</strong> <strong><em>最少无法逃离的蜥蜴个数是多少 ?</em></strong></p>
<blockquote>
<p>输入</p>
</blockquote>
<p>开始输入<strong>一个整数$t$</strong>代表<strong>有$t$组数据</strong>。</p>
<p>之后每第一行输入<strong>$n$和$d$</strong>，之后输入<strong>两个$n*m$的数组</strong>。</p>
<ul>
<li><strong>第一个数组</strong>代表有<strong>每个柱子最多承受的起跳次数</strong><ul>
<li><strong>0 代表柱子不存在</strong></li>
</ul>
</li>
<li><strong>第二个数组</strong>代表有<strong>每个蜥蜴的起始位置</strong></li>
</ul>
<p><em>!!! 注意题目未给出$m$所以$m$要自己来求 !!!</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>	<span class="comment">//t组案例</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span>	<span class="comment">//n d -&gt; 第1组案例</span></span><br><span class="line"><span class="number">1111</span>	<span class="comment">//&lt;===第一个数组</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line">LLLL	<span class="comment">//&lt;===第二个数组</span></span><br><span class="line">LLLL</span><br><span class="line">LLLL</span><br><span class="line"><span class="number">3</span> <span class="number">2</span>	<span class="comment">//n d -&gt; 第2组案例</span></span><br><span class="line"><span class="number">00000</span>	<span class="comment">//....</span></span><br><span class="line"><span class="number">01110</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line">.....</span><br><span class="line">.LLL.</span><br><span class="line">.....</span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"><span class="number">01110</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line">.....</span><br><span class="line">.LLL.</span><br><span class="line">.....</span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">02000000</span></span><br><span class="line"><span class="number">00321100</span></span><br><span class="line"><span class="number">02000000</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">..LLLL..</span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p>按照格式输出，注意<strong>英语语法的单复数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Case #<span class="number">1</span>: <span class="number">2</span> lizards were left behind.</span><br><span class="line">Case #<span class="number">2</span>: no lizard was left behind.</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">3</span> lizards were left behind.</span><br><span class="line">Case #<span class="number">4</span>: <span class="number">1</span> lizard was left behind.</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于柱子有最大的承受起跳次数，这和网络流中的<strong>边的容量</strong>很相似，所以考虑将每个<strong>存在的柱子当为节点</strong>来进行建图。由于有<strong>许多的</strong>蜥蜴需要逃离，看起来像个<strong>多源点的问题</strong>，所以联想到要使用<strong>超级源点/汇点</strong>。由于起跳次数是<strong>对点的限制</strong>，所以要对柱子进行<strong>割点</strong>将之转化为边的限制。</p>
<p><strong>建图步骤</strong>:</p>
<ul>
<li>对柱子进行割点</li>
<li>建立一个<strong>源点s</strong>连接所有蜥蜴出现的地方。</li>
<li>并且<strong>两柱之间距离小于$d$</strong>相互连边。</li>
<li>将每个直接能逃脱的柱子连上<strong>汇点t</strong>。(假设蜥蜴🦎在那个地方)</li>
</ul>
<p><strong>在</strong>建出的<strong>图上</strong>跑出的<strong>最大流</strong>代表<strong>最大能逃脱的蜥蜴🦎数量。</strong></p>
<p>因此答案为<strong>蜥蜴数量 - </strong> $MaxFlow(s,t)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆点+超级源点/汇点+挺麻烦的裸题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PILLER</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    PILLER(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y) &#123;&#125;</span><br><span class="line">    PILLER() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;PILLER&gt; pList;</span><br><span class="line"><span class="keyword">char</span> liz[maxn][maxn],pil[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> idx[maxn][maxn],cap[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="keyword">int</span> T,mini,dis;</span><br><span class="line">    <span class="keyword">int</span> lizCnt;</span><br><span class="line">    <span class="keyword">int</span> s,t,psize;</span><br><span class="line">    <span class="keyword">int</span> n,m,d,cnt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="comment">//INIT</span></span><br><span class="line">        <span class="built_in">memset</span>(liz,<span class="number">0</span>,<span class="keyword">sizeof</span>(liz));</span><br><span class="line">        <span class="built_in">memset</span>(pil,<span class="number">0</span>,<span class="keyword">sizeof</span>(pil));</span><br><span class="line">        <span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span>(idx));</span><br><span class="line">        <span class="built_in">memset</span>(cap,<span class="number">0</span>,<span class="keyword">sizeof</span>(idx));</span><br><span class="line">        pList.clear();</span><br><span class="line">        lizCnt = m = cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="comment">//cin the pillers</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %s"</span>,pil[i]);</span><br><span class="line">            <span class="keyword">if</span>(!m) m = <span class="built_in">strlen</span>(pil[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pil[i][j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    idx[i][j] = ++cnt;</span><br><span class="line">                    cap[i][j] = pil[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                    pList.push_back(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set the s and t &amp;&amp; psize</span></span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        t = (cnt&lt;&lt;<span class="number">1</span>) + <span class="number">100</span>;</span><br><span class="line">        dinic.init(t+<span class="number">1</span>);</span><br><span class="line">        psize = pList.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cin the lizards</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %s"</span>,liz[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(liz[i][j] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                    lizCnt++;</span><br><span class="line">                    dinic.AddEdge(s,idx[i][j],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cut point</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">            PILLER&amp; now = pList[i];</span><br><span class="line">            dinic.AddEdge(idx[now.x][now.y],idx[now.x][now.y]+cnt,cap[now.x][now.y]);</span><br><span class="line">            mini = min(min(now.x+<span class="number">1</span>,n-now.x),min(now.y+<span class="number">1</span>,m-now.y));</span><br><span class="line">            <span class="keyword">if</span>(mini &lt;= d) &#123;</span><br><span class="line">                dinic.AddEdge(idx[now.x][now.y]+cnt,t,INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//make them connect</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">            PILLER&amp; now = pList[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;psize; j++) &#123;</span><br><span class="line">                PILLER&amp; to = pList[j];</span><br><span class="line">                dis = <span class="built_in">abs</span>(now.x-to.x) + <span class="built_in">abs</span>(now.y-to.y);</span><br><span class="line">                <span class="keyword">if</span>(dis &lt;= d) &#123;</span><br><span class="line">                    dinic.AddEdge(idx[now.x][now.y]+cnt,idx[to.x][to.y],INF);</span><br><span class="line">                    dinic.AddEdge(idx[to.x][to.y]+cnt,idx[now.x][now.y],INF);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mflow = dinic.Maxflow(s,t);</span><br><span class="line">        <span class="keyword">int</span> left = lizCnt - mflow;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Case #%d: 1 lizard was left behind.\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left) <span class="built_in">printf</span>(<span class="string">"Case #%d: %d lizards were left behind.\n"</span>,++kase,left);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case #%d: no lizard was left behind.\n"</span>,++kase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>HDUOJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>HDUOJ</tag>
        <tag>最大流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>记 ICPC亚洲区域赛(上海)</title>
    <url>/2019/11/28/19SHUICPC/</url>
    <content><![CDATA[<blockquote>
<p>data: 2019-11-23 ~ 24<br>第44届ICPC亚洲区域赛(上海)<br>记录第一次参加ICPC区域赛以及一些个人思考</p>
</blockquote>
<a id="more"></a>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>其实在ICPC上海站回来以后我一直想对57认认真真道个歉，并且不想被原谅。</strong></p>
<p><strong>我想在我的心里还是有活着一朵花的</strong>，回想了一下去年的大半时光，57对于<strong>*CPC</strong>热爱和努力是毋庸置疑的，而我明明已经承诺却天天摸鱼，<strong>半天打鱼一个月</strong>晒网，个人实力没什么成长，队内属于自己的<strong>专题都没有进度</strong>，到了最后，只留下了57一个人孤零零的和其他高校的那些怪物战斗。此前，对于<strong>伤害挚友所热爱之物和抛弃队友独自享乐</strong>这种行为，一直是我<strong>所不齿</strong>的，不过现在回想起来<strong>我也成了那种我最不齿的人</strong>，其实我也不知道我想说什么，但是<strong>对57的歉意</strong>，和对自己的极度厌恶和不齿是<strong>确确实实实实在在</strong>的，在检讨之后，其实我想说的是，对之前我的行为感到十分的抱歉，并且在之后的日子里<strong>我也会认真参战</strong>，<strong>践行</strong>先前谈论的热爱，最后的最后我还是想对之前的行为做出<strong>认真的道歉</strong>，<strong><em>并且不想被原谅</em></strong>。</p>
<h2 id="参赛记录"><a href="#参赛记录" class="headerlink" title="参赛记录"></a>参赛记录</h2><blockquote>
<p><strong>前言: </strong> 说是记录，不过只是<strong>参赛的流水帐</strong>罢了。</p>
</blockquote>
<h3 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h3><p>关于比赛的行程安排是在<strong>前三个星期</strong>开始的，现在发现从那时开始制定行程已经<strong>太晚了</strong>，行程制定时间最好是提前<strong>一个月半或者两个月前</strong>开始寻找要<strong>住的酒店</strong>并且下单了，提前<strong>一个月</strong>就要确定出行方式并<strong>完成购票</strong>了。</p>
<p>如果距离较远的话，建议<strong>提早一天</strong>过去，以免过于疲惫。</p>
<h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p><strong>热声赛</strong></p>
<ul>
<li>熟悉系统</li>
<li>测试评测机</li>
<li>适应感觉</li>
</ul>
<p><strong>正式赛</strong></p>
<p>整个5个小时一直在想<strong>K题</strong>，但是到最后也没什么结果，<strong>贡献为0</strong>，在公布答案后，只留下了漫漫的后悔与不甘。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>事情过去四天，那时候失落的心情已经忘记的七七八八，<strong>只留下对自己之前所作所为的厌恶</strong>，以及收拾好所有的思绪，<strong>做出认认真真上”战场”的觉悟</strong>。</p>
<p><img src="/img/shu2019.png" alt="2019shu"></p>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#601 题解报告</title>
    <url>/2019/11/21/CodeForceR601/</url>
    <content><![CDATA[<p><strong>C;D; TODO!!!!</strong></p>
<blockquote>
<p>CodeForces-Round#601 | <a href="http://codeforces.com/contest/1255" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Changing-Volume"><a href="#A-Changing-Volume" class="headerlink" title="A. Changing Volume"></a><a href="http://codeforces.com/contest/1255/problem/A" target="_blank" rel="noopener">A. Changing Volume</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一组数列 <strong>{-5,-2,-1,+1,+2,+5}</strong></p>
<p>给出两个数字$x,y$，<strong>最少</strong> $x$ 需要加<strong>几次</strong>数列中的元素(<strong>元素可以被多次选择</strong>)，能变成$y$?</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，假设两者相差 $\geq$ <strong>5</strong>，就先减去 <strong>5</strong>，以此类推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    While(n--) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        a = <span class="built_in">abs</span>(a-b);</span><br><span class="line">        ans += a/<span class="number">5</span>;</span><br><span class="line">        a%=<span class="number">5</span>;</span><br><span class="line">        ans += a/<span class="number">2</span>;</span><br><span class="line">        a%=<span class="number">2</span>;</span><br><span class="line">        ans += a/<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Fridge-Lockers"><a href="#B-Fridge-Lockers" class="headerlink" title="B. Fridge Lockers"></a><a href="http://codeforces.com/contest/1255/problem/B" target="_blank" rel="noopener">B. Fridge Lockers</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有$n$个柜子，相互的柜子之间有锁链🔗相互连接，$i-th$柜子属于$i-th$个人，每个人之有<strong>一个柜子</strong>，并且每个人知道连接所有柜子的锁链的密码。</p>
<p>一开始所有柜子之间没有锁链🔗相连，你可以锻造$m$个锁链(<strong>必须锻造$m$个锁链</strong>，$n \geq m$)，需要花费<strong>最小的价格</strong>来锻造锁链连接柜子来<strong>保证柜子的安全</strong>。</p>
<p><strong>柜子的安全定义: </strong>除了自己以外至少要两个人一起才能解开柜子。</p>
<p>给出一个数组$a$，锻造连接 $ &lt; i , j &gt; $ 的<strong>花费</strong>是 $a_i + a_j$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p><strong>!!<code>这边要特殊注意之有2个柜的情况</code>!!</strong></p>
<p>当$n=2$的时候，无论如何都无法保证柜子的安全。</p>
<p>由于题目保证了$m \leq n$，所以只有 $n=m$ 的时候有解，其余情况均无法让柜子安全。</p>
<p>当$n=m$ 的时候，只能是环满足条件。<del>然后好像题面的最小就没有意义re…</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(NODE&amp; a,NODE &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].num);</span><br><span class="line">            a[i].pos = i+<span class="number">1</span>;</span><br><span class="line">            ans += a[i].num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n || n==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=n) </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-League-of-Leesins"><a href="#C-League-of-Leesins" class="headerlink" title="C. League of Leesins"></a><a href="http://codeforces.com/contest/1255/problem/C" target="_blank" rel="noopener">C. League of Leesins</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        a[x].push_back(y);a[x].push_back(z);</span><br><span class="line">        a[y].push_back(x);a[y].push_back(z);</span><br><span class="line">        a[z].push_back(x);a[z].push_back(y);</span><br><span class="line">        cnt[x]++;cnt[y]++;cnt[z]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]==<span class="number">1</span>) 	x = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[x][<span class="number">0</span>]] == <span class="number">2</span>)  y=a[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> y=a[x][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,x,y);</span><br><span class="line">    vis[x] = vis[y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a[x].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[x][j]]) z = a[x][j];</span><br><span class="line">        &#125;</span><br><span class="line">        vis[z] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,z);</span><br><span class="line">        x = y;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Feeding-Chicken"><a href="#D-Feeding-Chicken" class="headerlink" title="D. Feeding Chicken"></a><a href="http://codeforces.com/contest/1255/problem/D" target="_blank" rel="noopener">D. Feeding Chicken</a></h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接🐍型走位构造即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> rices,mk,bt,tp;</span><br><span class="line"><span class="built_in">string</span> str  = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line"><span class="keyword">char</span> fr[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> out[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> r,c,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= (mk*(bt+<span class="number">1</span>))) <span class="keyword">return</span> (num<span class="number">-1</span>)/(bt+<span class="number">1</span>);</span><br><span class="line">    num -= mk*(bt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (mk + (num<span class="number">-1</span>)/bt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,num;</span><br><span class="line">    <span class="keyword">int</span> nn,idx;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        idx = nn = num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;r,&amp;c,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %s"</span>,fr[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fr[i][j] == <span class="string">'R'</span>) num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bt = num/k; mk = num%k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fr[i][j]==<span class="string">'R'</span>) &#123;</span><br><span class="line">                        nn++;</span><br><span class="line">                        idx = getIdx(nn);</span><br><span class="line">                    &#125;</span><br><span class="line">                    out[i][j] = str[idx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=c<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fr[i][j]==<span class="string">'R'</span>) &#123;</span><br><span class="line">                        nn++;</span><br><span class="line">                        idx = getIdx(nn);</span><br><span class="line">                    &#125;</span><br><span class="line">                    out[i][j] = str[idx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;c; j++) <span class="built_in">putchar</span>(out[i][j]);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-EducationRound#76 题解报告</title>
    <url>/2019/11/18/CodeForceER76/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-EducationalRound#76 | <a href="http://codeforces.com/contest/1257" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Two-Rival-Students"><a href="#A-Two-Rival-Students" class="headerlink" title="A.Two Rival Students"></a>A.<a href="http://codeforces.com/contest/1257/problem/A" target="_blank" rel="noopener"><strong>Two Rival Students</strong></a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个序列由<strong>1到</strong>$n$个元素组成，起始升序，你能交换$x$次，只能<strong>相邻交换</strong>，给出元素$a,b$。</p>
<p><strong>问:</strong> $x$次交换后的<strong>最大距离</strong>为多少?</p>
<blockquote>
<p>距离极为坐标相减</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>容易发现$x$就是两者初始距离的增加量，由于距离一定小于<strong>数列的最大长度</strong>，最后的最大距离一定为$min(|a-b|+x,n-1)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,a,b;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(n<span class="number">-1</span>,<span class="built_in">abs</span>(a-b)+x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Magic-Stick"><a href="#B-Magic-Stick" class="headerlink" title="B.Magic Stick"></a>B.<a href="http://codeforces.com/contest/1257/problem/B" target="_blank" rel="noopener"><strong>Magic Stick</strong></a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个数$num$，你可以对$num$进行两种操作</p>
<ul>
<li>$num_{new} = \dfrac{num_{old}*3}{2}$ ，$num =  偶数 $</li>
<li>$num_{new} = num_{old} - 1$</li>
</ul>
<p>题目为多组输入，每组输入有两个数$x$和$y$。</p>
<p><strong>问:</strong> $y$可否由$x$操作得到?</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>此题第一眼很像<strong>搜索题</strong>，但是仔细分析发现，<strong>当</strong> $x$大于$3$的时候，必定能得到所有的$y$，只要乘到$&gt; y$然后一直步骤2即可，那这题只要特判$x \in [1,3]$ <strong>和</strong> $y=0$的情况即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span> &amp;&amp; y!=<span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//特判1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">2</span> &amp;&amp; x &lt;=<span class="number">3</span> &amp;&amp; y&gt;<span class="number">3</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//特判2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Dominated-Subarray"><a href="#C-Dominated-Subarray" class="headerlink" title="C.Dominated Subarray"></a>C.<a href="http://codeforces.com/contest/1257/problem/C" target="_blank" rel="noopener"><strong>Dominated Subarray</strong></a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>规定在一个<strong>区间合法</strong>为，在区间中有一个数的出现次数<strong>严格大于</strong>其他所有的数字。类似[1,2,2,2,3]，[1,1,4,5,1,4]……，否则即为<strong>区间不合法</strong>，如[1,1,2,2]，[1,2,3,4,5]……</p>
<p>给出一个序列$s$。</p>
<p><strong>问:</strong> 合法子序列的<strong>最短长度</strong>？如果不存在就输出 <strong>-1</strong>。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>显然<strong>最短合法子序列</strong>中最大出现次数为<strong>两次</strong>，所以对于<strong>每个元素</strong>来说只要选择与<strong>最近的他相同的元素</strong>并选择<strong>最小的</strong>即可，<strong>假设</strong>此时选择的区间<strong>不合法</strong>，所以在<strong>当前区间内</strong>肯定能找到<strong>更小的合法区间</strong>，按照思路<strong>一定能</strong>在接下来的寻找中将原来的答案<strong>更新</strong>，所以<strong>算法正确</strong>。</p>
<ul>
<li>可以使用 map 来存储位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,tmp;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; per;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span>(per[tmp]) ans = min(ans,i-per[tmp]+<span class="number">1</span>);</span><br><span class="line">        per[tmp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INT_MAX) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Yet-Another-Monster-Killing-Problem"><a href="#D-Yet-Another-Monster-Killing-Problem" class="headerlink" title="D.Yet Another Monster Killing Problem"></a>D.<a href="http://codeforces.com/contest/1257/problem/D" target="_blank" rel="noopener"><strong>Yet Another Monster Killing Problem</strong></a></h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>有$n$个怪兽，你有$m$个勇者，每天只能能使用<strong>一个勇者</strong>，并且要按照<strong>怪物顺序</strong>依次消灭。</p>
<p>第$i$个怪物的防御力为$a_i$，第$i$个勇者的<strong>攻击力</strong>$p_i$和<strong>耐力</strong>$s_i$，每消灭一个怪物以后<strong>耐力-1</strong>，耐力会在第二天恢复。</p>
<p>勇者的撤退条件为</p>
<ul>
<li>耐力归零</li>
<li>勇者的攻击力 <strong>&lt;=</strong> 怪物的防御力</li>
</ul>
<p><strong>问:</strong> 消灭所有怪物的<strong>最短天数</strong>是多少?</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>我们可以使用一个$bst$<strong>数组</strong>表示<strong>当前耐力所能拥有的最大攻击力</strong>。</p>
<p><strong>分析：</strong> 当 $p_{t1} &gt; p_{t2}$ &amp;&amp;  $s_{t1} \ge s_{t2}$ 时，$bst[s_{t_2}] = p_{t_1}$ 即选择最佳英雄。</p>
<p>我们按照分析<strong>预处理</strong>$bst$数组，<strong>显然</strong>处理完的$bst$数组必定是<strong>降序的</strong>。</p>
<p>之后我们只要<strong>按照顺序</strong>开始攻略怪兽即可，每次选择$bst[t]$，$t$表示当前攻略到了<strong>当天</strong>开始的第$t$个怪兽，选择最佳的攻击力去攻击。由于$bst$数组是<strong>降序</strong>，可能出现<strong>选择了后面的英雄，消灭不了前面的怪物</strong>，所以需要判断<strong>是否可以消灭</strong>，使用的是当前的<strong>最大的</strong>$a_i$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> moster[maxN],s[maxN],p[maxN];</span><br><span class="line"><span class="keyword">int</span> bst[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(bst,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,moster+i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,p+i,s+i);</span><br><span class="line">            bst[s[i]] = max(p[i],bst[s[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) bst[i] = max(bst[i],bst[i+<span class="number">1</span>]);	<span class="comment">//bst为耐力为i的最大攻击力</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            day++;</span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> npos = pos;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                m = max(m,moster[npos]); 		<span class="comment">//最大的a[i]</span></span><br><span class="line">                <span class="keyword">if</span>(m &gt; bst[npos - pos + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                npos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(npos == pos) &#123;</span><br><span class="line">                ok = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = npos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ok) day = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-The-Contest"><a href="#E-The-Contest" class="headerlink" title="E.The Contest"></a>E.<a href="http://codeforces.com/contest/1257/problem/E" target="_blank" rel="noopener"><strong>The Contest</strong></a></h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有一个数列，被分成了三个部分，<strong>A部分</strong>为数列的<strong>前缀</strong>，<strong>C部分</strong>为数列的<strong>后缀</strong>，<strong>B部分</strong>为剩余，但是不巧<strong>分错了</strong>，分成了<strong>三个部分</strong>，现在你每次操作只能移动一个元素的位置。</p>
<p><strong>问:</strong> 最少需要几次操作才能把分错的部分改正常分配 ?</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>原来的序列是有序的，现在要进行操作将现在的序列改为有序，那么最长的有序数列肯定不能操作，但树剩余的元素都能经过一步操作到目标的位置，所以答案即为<strong>元素的个数 - 这个序列的最大递增子序列个数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn],lis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,i,end;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    end = a+b+c;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,arr+i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr,arr+a);</span><br><span class="line">    sort(arr+a,arr+a+b);</span><br><span class="line">    sort(arr+a+b,arr+a+b+c);</span><br><span class="line">    <span class="built_in">memset</span>(lis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(a+b+c));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    lis[ans] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; lis[ans]) lis[++ans] = arr[i];</span><br><span class="line">        <span class="keyword">else</span> *(lower_bound(lis+<span class="number">1</span>,lis+<span class="number">1</span>+ans,arr[i])) = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,end - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Rated for Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树学习笔记 - 扫描线算法</title>
    <url>/2019/11/17/SMX/</url>
    <content><![CDATA[<p><strong>扫描线算法</strong>一般用来解决一些图形的<strong>周长，体积和面积</strong>问题。可以使用<strong>线段树</strong>实现。</p>
<blockquote>
<p>前置知识: </p>
</blockquote>
<ul>
<li><strong>线段树</strong></li>
<li><strong>离散化</strong></li>
</ul>
<a id="more"></a>
<h2 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h2><p><strong>扫描线算法</strong>顾名思义，就是用一根<strong>假想的扫描线</strong>从下向上对图形进行扫描，然后在每次扫描到边的时候，进行答案的计算。相当于对图形进行分层，然后计算每个区域的答案，最后进行汇总到总答案中。</p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>在二维直角坐标系中有n个矩形，每个矩的边必定平行于$x$轴或$y$轴，<strong>问</strong>这n个矩形覆盖的面积是多少?</p>
<h3 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h3><p>由于这题计算的是<strong>图形的并</strong>的面积，所以我们只要记录<strong>之前获得的边的长度</strong>乘上<strong>扫描线之间的差值</strong>，加入到<strong>总答案</strong>中即可。</p>
<p><strong>扫描过程</strong>如下:</p>
<blockquote>
<p>每次计算的面积颜色不同。</p>
</blockquote>
<p><img src="/img/SMX.png" alt="SMX"></p>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><blockquote>
<p>由于扫描方向的不同，每条边标记也不同。此处是从下往上进行扫描。</p>
</blockquote>
<p>明白了大致思路以后，现在的问题就变成了，如何计算<strong>每次扫描线扫到的边的长度呢?</strong></p>
<p>这边使用了一个技巧，我们对每个矩形的上下边进行标记，将<strong>下面的边</strong>标记为<strong>1</strong>，将<strong>上面的边</strong>标记为<strong>-1</strong>。</p>
<p>所以我们每次扫过的时候只要将<strong>标记</strong>加入到$x$轴上，然后计算在$x$轴上<strong>标记 &gt; 0</strong>的范围即可，<strong>范围的大小</strong>就是<strong>扫描线扫描到的边的长度。</strong></p>
<p>在数据范围很小的时候我们可以对此进行暴力计算，<del>一般来说数据量都会很大，</del>但是如果数据量很大的情况下我们就要使用<strong>线段树</strong>进行维护<strong>标记</strong>和<strong>长度</strong>，从而避免TLE。</p>
<p>一般我们需要对线段树<strong>维护的区间</strong>进行离散化处理。</p>
<p><strong>注意</strong></p>
<ul>
<li>这里的线段树我们维护的是<strong>线段的长度</strong>而不是点的值，所以我们要对线段树进行更改，即<strong>左孩子的右值</strong> = <strong>右孩子的左值</strong>，这样才能使维护<strong>不出现缝隙</strong>。</li>
<li><strong>离散化</strong>很重要。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p><strong>题目原型</strong> | <a href="https://vjudge.net/problem/HDU-1542" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<p><em>注意点:</em></p>
<ul>
<li><strong>修改后的线段树</strong></li>
<li><strong>离散化</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prt(x) printf(#x <span class="meta-string">" = %.2lf\n"</span>,x);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sgy[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RECTANGLE</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y1,y2;</span><br><span class="line">    <span class="keyword">int</span> flag;			<span class="comment">//标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b1,<span class="keyword">double</span> b2,<span class="keyword">int</span> flag1)</span> </span>&#123; x = a; y1 = b1; y2 = b2; flag = flag1;&#125;</span><br><span class="line">&#125; rec[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREENODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> l,r,sum;		<span class="comment">//维护范围</span></span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    TREENODE() &#123;lazy=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> l1,<span class="keyword">double</span> r1,<span class="keyword">double</span> sum1,<span class="keyword">int</span> lazy1)</span> </span>&#123; l=l1; r=r1; sum=sum1; lazy=lazy1; &#125;</span><br><span class="line">&#125; tn[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(RECTANGLE a,RECTANGLE b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过更改的线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l &gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tn[idx].init(sgy[l],sgy[r],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        buildTree(l,mid,lc(idx));</span><br><span class="line">        buildTree(mid,r,rc(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tn[idx].init(sgy[l],sgy[r],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    TREENODE&amp; now = tn[idx];</span><br><span class="line">    <span class="keyword">if</span>(now.lazy &gt; <span class="number">0</span>) now.sum = now.r - now.l;</span><br><span class="line">    <span class="keyword">else</span> now.sum = tn[lc(idx)].sum + tn[rc(idx)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> tarL,<span class="keyword">double</span> tarR,<span class="keyword">int</span> idx,<span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    TREENODE&amp; now = tn[idx];</span><br><span class="line">    <span class="keyword">if</span>(now.l == tarL &amp;&amp; now.r == tarR) &#123;</span><br><span class="line">        now.lazy += add;</span><br><span class="line">        pushUp(idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(tn[lc(idx)].r &gt; tarL) update(tarL,min(tn[lc(idx)].r,tarR),lc(idx),add);</span><br><span class="line">    <span class="keyword">if</span>(tn[rc(idx)].l &lt; tarR) update(max(tn[rc(idx)].l,tarL),tarR,rc(idx),add);</span><br><span class="line">    pushUp(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,size,temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x1,x2,y1,y2,res;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">        <span class="built_in">memset</span>(rec,<span class="number">0</span>,<span class="keyword">sizeof</span>(rec));</span><br><span class="line">        <span class="built_in">memset</span>(tn,<span class="number">0</span>,<span class="keyword">sizeof</span>(tn));</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            rec[i].init(x1,y1,y2,<span class="number">1</span>);</span><br><span class="line">            rec[i+n].init(x2,y1,y2,<span class="number">-1</span>);</span><br><span class="line">            sgy[i] = y1;</span><br><span class="line">            sgy[i+n] = y2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        sort(sgy,sgy+n*<span class="number">2</span>);</span><br><span class="line">        size = unique(sgy,sgy+n*<span class="number">2</span>) - sgy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建树</span></span><br><span class="line">        buildTree(<span class="number">0</span>,size<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描线算法求解</span></span><br><span class="line">        sort(rec,rec+<span class="number">2</span>*n,cmp);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">2</span>*n;</span><br><span class="line">        <span class="keyword">double</span> perX = rec[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;end; i++) &#123;</span><br><span class="line">            RECTANGLE&amp; now = rec[i];</span><br><span class="line">            <span class="keyword">if</span>(i) res += (now.x-perX)*tn[<span class="number">1</span>].sum; <span class="comment">//计算面积</span></span><br><span class="line">            update(now.y1,now.y2,<span class="number">1</span>,now.flag);</span><br><span class="line">            perX = now.x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,++temp,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://oi-wiki.org/geometry/scanning/" target="_blank" rel="noopener"><strong>OIWiki-扫描线</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>由一道代码填空题目引发的小思考</title>
    <url>/2019/11/11/ThinkAfterDSTest1/</url>
    <content><![CDATA[<p><code>由数据结构的一道期中考题的引发的思考</code></p>
<p>其实在<strong>有限的时空内</strong>思考别人的思考方式<strong>并实现</strong>，是个有十分有意思的事情，并且也是<strong>代码能力的一种体现</strong>。</p>
<p><strong>如有发现证明出错，务必指出，谢谢！</strong></p>
<a id="more"></a>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>要求在<code>/*===i===*/</code>中<strong>补全代码</strong>实现<strong>链表排序</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Programming Language: cpp</span></span><br><span class="line"><span class="comment">    已知节点类的定义如下:</span></span><br><span class="line"><span class="comment">    struct NODE &#123;</span></span><br><span class="line"><span class="comment">        int val;</span></span><br><span class="line"><span class="comment">        struct NODE* next;</span></span><br><span class="line"><span class="comment">        NODE() &#123;&#125;</span></span><br><span class="line"><span class="comment">        NODE(int val,NODE* next):val(val),next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    typedef NODE* LinkList;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LinkList p,q,r,u;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="comment">/*===1===*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*===2===*/</span>) &#123;</span><br><span class="line">        r = L;</span><br><span class="line">        q = L-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( <span class="comment">/*===3===*/</span> &amp;&amp; q-&gt;data &lt;= p-&gt;data ) &#123;</span><br><span class="line">            r = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        u = p-&gt;next;</span><br><span class="line">        <span class="comment">/*===4===*/</span></span><br><span class="line">        <span class="comment">/*===5===*/</span></span><br><span class="line">        p = u;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p>首先思考标准答案的正确性，标准答案如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置</th>
<th style="text-align:center">语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/*==1==*/</td>
<td style="text-align:center">L = nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==2==*/</td>
<td style="text-align:center">p != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==3==*/</td>
<td style="text-align:center">q != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==4==*/</td>
<td style="text-align:center">r-&gt;next = p;</td>
</tr>
<tr>
<td style="text-align:center">/*==5==*/</td>
<td style="text-align:center">p-&gt;next = q;</td>
</tr>
</tbody>
</table>
</div>
<p>毫无疑问，这是正确的。这段代码的含义是，普通的链表<strong>插入排序法</strong>。</p>
<hr/>

<p><strong>插入排序思想</strong>如下:</p>
<ol>
<li>需要新构造<strong>一个空表</strong></li>
<li>将每次选择原表中的第一个元素(q)，删除(q)在原链表中的位置(头删)</li>
<li>按照顺序将元素(u)插入到新的空表中。</li>
<li>重复<strong>(2)-(3)</strong>直到原表为空，即是排序完毕，排序的结果就是空表。</li>
</ol>
<hr/>

<p><strong>L</strong>就是上述中的空表，所以初始<strong>为空</strong>(就是位置1操作)，而<strong>u</strong>是<strong>原表的第一个元素位置</strong>。</p>
<blockquote>
<p>由于原来的链表无头节点，所以在阅读上，会有些许不适。</p>
</blockquote>
<h3 id="引发的小思考"><a href="#引发的小思考" class="headerlink" title="引发的小思考"></a>引发的小思考</h3><p>关于 <strong>L=nullptr</strong> 是否必要的小思考，假设我们去除<strong>L=nullptr</strong>，我们就是在原来的表中进行<strong>插入</strong>和<strong>删除</strong>操作，由于选择元素是不断向后的，我们只要保证<strong>现在将要插入的元素插入到它之前的位置是正确的即可</strong>。</p>
<p>可能上面的说法有点绕，<strong>直观解释</strong>如图:</p>
<p><img src="/img/Tsk1.jpg" alt="Tsk1"></p>
<blockquote>
<p>1</p>
</blockquote>
<p>即，只要保证<strong>data4</strong>插入到<strong>红色区域时</strong>不会影响<strong>红色区域的正确性</strong>即可，假设<strong>红色区域为有序</strong>，这个是显然的，因为假设<strong>红色区域有序</strong>，这就是<strong>链表的插入排序</strong>。 </p>
<blockquote>
<p>2</p>
</blockquote>
<p>因此只要证明<strong>红色区域有序</strong>即可。</p>
<ul>
<li>由于第一步操作不会影响正确性，故略去。</li>
<li>从第二步开始思考<ul>
<li>假设第第二个节点(u)<strong>被移动</strong>，此<strong>u</strong>必定会被<strong>移动到后面</strong>，即图中的<strong>灰色区域</strong> (即<em>待排序区域</em>)，不会影响正确性。</li>
<li>假设未被移动，即正常排序，由于只有一个元素，所以<strong>排序之后必定有序</strong> </li>
</ul>
</li>
</ul>
<p><em>由于寻找中要求了严格小于，所以避免了p,q相等的情况,但是这边也有个小陷阱</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p>因此，由[1][2]和<strong>数学归纳法</strong>可得，去掉L=nullptr<strong>不影响正确性</strong>。</p>
<h3 id="一个小陷阱"><a href="#一个小陷阱" class="headerlink" title="一个小陷阱"></a>一个小陷阱</h3><p>陷阱是出现在不写<strong>L=nullptr</strong>的情况下的。</p>
<p>这边就有个疑问了，那是不是题面中的<strong>(4)，(5)的顺序</strong>是不是可以乱填了呢？</p>
<p>当然是不能的!</p>
<p>假设</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置</th>
<th style="text-align:center">语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">/*==4==*/</td>
<td style="text-align:center">p-&gt;next = q;</td>
</tr>
<tr>
<td style="text-align:center">/*==5==*/</td>
<td style="text-align:center">r-&gt;next = p;</td>
</tr>
</tbody>
</table>
</div>
<p>由于代码只保证了<strong>p</strong>和<strong>q</strong>不相等，并没有保证<strong>p</strong>和<strong>r</strong>不相等，所以当出现<strong>p = r</strong>的时候，按照上面的写法会在 <strong>(5)执行结束后</strong>在 <strong>p</strong> 处 <strong>形成自环</strong>，代码错误。</p>
<p>而<strong>原来的写法</strong>，就相等于覆盖了<strong>自环的赋值</strong>，所以避免了形成自环，<strong>代码正确</strong>。</p>
<h3 id="对于答案的思考"><a href="#对于答案的思考" class="headerlink" title="对于答案的思考"></a>对于答案的思考</h3><p>答案一： </p>
<blockquote>
<p>4,5位置可以互换</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置</th>
<th style="text-align:center">语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/*==1==*/</td>
<td style="text-align:center">L = nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==2==*/</td>
<td style="text-align:center">p != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==3==*/</td>
<td style="text-align:center">q != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==4==*/</td>
<td style="text-align:center">r-&gt;next = p;</td>
</tr>
<tr>
<td style="text-align:center">/*==5==*/</td>
<td style="text-align:center">p-&gt;next = q;</td>
</tr>
</tbody>
</table>
</div>
<p>答案二： </p>
<blockquote>
<p>4,5位置不可以互换</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">位置</th>
<th style="text-align:center">语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/*==1==*/</td>
<td style="text-align:center">随意</td>
</tr>
<tr>
<td style="text-align:center">/*==2==*/</td>
<td style="text-align:center">p != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==3==*/</td>
<td style="text-align:center">q != nullptr;</td>
</tr>
<tr>
<td style="text-align:center">/*==4==*/</td>
<td style="text-align:center">r-&gt;next = p;</td>
</tr>
<tr>
<td style="text-align:center">/*==5==*/</td>
<td style="text-align:center">p-&gt;next = q;</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然证明了乱填第一空，也可以使代码正确。<strong>但是</strong>，在本着代码编写是<strong>首先是给人看的</strong>，<strong>其次</strong>才是<strong>运行正确</strong>，所以<strong>在实际编写中</strong>，<strong>不推荐</strong>第二种写法。<br><del>我第二种,进入思维盲区，发现r=p找了一下午，真的笋干爆炸</del></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>Datastructures</tag>
        <tag>基础</tag>
        <tag>Exam</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2195 Going Home</title>
    <url>/2019/11/10/POJ2195/</url>
    <content><![CDATA[<p><strong>最小费用流</strong>的裸题</p>
<ul>
<li>曼哈顿距离</li>
<li>拆点</li>
</ul>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-2195" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个$n*m$的字符串，其中$m$代表是人，$H$代表的房子，<strong>.</strong> 代表立足地，每个人只能<strong>上/下/左/右</strong>移动。移动一步的花费是<strong>1</strong>。</p>
<p><strong>问：</strong> 让所有人移动到房子(<strong>每个房子里面只能容纳一个人</strong>)里面的最小花费是多少?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p><em>多组输入</em>，以<strong>0 0</strong>为结束标志</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span>         <span class="comment">//n m</span></span><br><span class="line">.m</span><br><span class="line">H.</span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">HH..m</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">mm..H</span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line">...H....</span><br><span class="line">...H....</span><br><span class="line">...H....</span><br><span class="line">mmmHmmmm</span><br><span class="line">...H....</span><br><span class="line">...H....</span><br><span class="line">...H....</span><br><span class="line"><span class="number">0</span> <span class="number">0</span>         <span class="comment">//退出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr/>

<p><strong>曼哈顿距离：</strong> $dist(1,2) = |x_1-x_2| + |y_1 - y_2|$</p>
<hr/>

<p>我们发现这题的移动方式为<strong>上下左右</strong>，由于要求的是<strong>最小花费</strong>，所以每个人到每个房子的距离必定是<strong>曼哈顿距离</strong>，那么我们枚举到<strong>每个房子的距离</strong>将<strong>曼哈顿距离</strong>作为<strong>费用</strong>，<strong>容量为1</strong>，然后建图跑<strong>最小费用最大流</strong>即可，由于每个房子最多只能放一个人，所以我们对<strong>房子拆点</strong>即可。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ND</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    ND()&#123;&#125;</span><br><span class="line">    ND(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> l[<span class="number">120</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ND&gt; man,house;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tmplate_Use</span></span><br><span class="line"><span class="comment">//mcmf(s, t) return MaxFlow</span></span><br><span class="line"><span class="comment">//ret means MinCost</span></span><br><span class="line"><span class="comment">//addedge(u, v, w, c)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot = <span class="number">1</span>, lnk[N], cur[N], ter[M], nxt[M], cap[M], cost[M], dis[N], ret;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, cap[tot] = w, cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123; add(u, v, w, c), add(v, u, <span class="number">0</span>, -c); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, lnk, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ter[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[v] &gt; dis[u] + cost[i]) &#123;</span><br><span class="line">                dis[v] = dis[u] + cost[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.push(v), vis[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &amp;&amp; ans &lt; flow; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = ter[i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v] &amp;&amp; cap[i] &amp;&amp; dis[v] == dis[u] + cost[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, t, <span class="built_in">std</span>::min(cap[i], flow - ans));</span><br><span class="line">            <span class="keyword">if</span> (x) ret += x * cost[i], cap[i] -= x, cap[i ^ <span class="number">1</span>] += x, ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> ((x = dfs(s, t, INF))) ans += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h,w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; h &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span>(!(h||w)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//Init</span></span><br><span class="line">        man.clear(); house.clear();</span><br><span class="line">        <span class="built_in">memset</span>(lnk,<span class="number">0</span>,<span class="keyword">sizeof</span>(lnk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;h; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;w; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l[i][j]==<span class="string">'m'</span>) man.push_back(ND(i,j));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l[i][j]==<span class="string">'H'</span>) house.push_back(ND(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> msize = man.size(),hsize = house.size();</span><br><span class="line">        <span class="keyword">int</span> s = (msize+hsize)*<span class="number">2</span>+<span class="number">8</span>,t = (msize+hsize)*<span class="number">2</span>+<span class="number">9</span>;</span><br><span class="line">        <span class="comment">//s -&gt; man</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;msize; i++) addedge(s,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;hsize; i++) &#123;</span><br><span class="line">            addedge(msize+i,msize+hsize+i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            addedge(msize+hsize+i,t,INF,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//link</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;msize; i++) &#123;</span><br><span class="line">            ND&amp; mm = man[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;hsize; j++) &#123;</span><br><span class="line">                ND&amp; hh = house[j];</span><br><span class="line">                <span class="keyword">int</span> cost = <span class="built_in">abs</span>(mm.x - hh.x) + <span class="built_in">abs</span>(mm.y - hh.y);</span><br><span class="line">                addedge(i,j+msize,<span class="number">1</span>,cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        mcmf(s,t);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>拆点</tag>
        <tag>POJ</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记-最小费用最大流</title>
    <url>/2019/11/07/MCMF/</url>
    <content><![CDATA[<p><strong>最小花费</strong>的最大流被称为<strong>最小费用最大流</strong>。</p>
<blockquote>
<p>模板题地址 | <a href="https://www.luogu.org/problem/P3381" target="_blank" rel="noopener"><strong>Here</strong></a><br>最小费用最大流模板 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Template</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h2><p>我们定义一条边的费用为$cost(u,v) = flow(u,v) * w(u,v)$。<strong>其中:</strong></p>
<ul>
<li>$w(u,v)$代表流过边$\langle u,v \rangle$的<strong>单位费用</strong></li>
<li>$flow(u,v)$代表流过边$\langle u,v \rangle$的<strong>流量</strong></li>
<li>$cost(u,v)$代表流过边$\langle u,v \rangle$的<strong>费用</strong></li>
</ul>
<blockquote>
<p>$w$也满足反对称性，<strong>即 &gt; </strong> $w(u,v) == -w(v,u)$</p>
</blockquote>
<p>网络中一个可行流的总费用为$\sum_{}{(f(u,v)*w(u,v))}$。</p>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>最小费用最大流是在<strong>最大流</strong>中<strong>总费用</strong>最小的流。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>求解最小费用最大流可以采用<strong>贪心的思想</strong>，即每一次找一条从源点到汇点的增广路，同时保证这条增广路是目前所有增广路中运输单位物品费用最小的。由于对于一个确定的容量网络，它的<strong>最大流是有限</strong>且确定的，所以一定存在某一时刻无法再在当前残量网络中找到增广路，这时算法结束，总流量等于最大流，由于<strong>单次费用</strong>计算为$f(s,t) * \sum_{}{w(u,v)}$，<strong>并且</strong>保证了每次的$\sum_{}{w(u,v)}$为<strong>最小</strong>，所以总花费，<strong>即 &gt; </strong> $\sum_{i=0}^{n}{[f_i{(s,t)} * \sum{w(u,v)}]}$ 也必定是所有方案中最少的。</p>
<p>可见，求解这类问题的关键是每一次找到一条目前所有增广路中运输单位物品费用最小的增广路。如果将费用看作两点之间的距离，那么这就转换为了一个<strong>最短路问题</strong>。 </p>
<h3 id="MCFC-模板"><a href="#MCFC-模板" class="headerlink" title="MCFC 模板"></a>MCFC 模板</h3><h4 id="EK模板"><a href="#EK模板" class="headerlink" title="EK模板"></a>EK模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用：while(spfa())update();</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qxx</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nex, t, v, c;</span><br><span class="line">&#125;;</span><br><span class="line">qxx e[M];</span><br><span class="line"><span class="keyword">int</span> h[N], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_path</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (qxx)&#123;h[f], t, v, c&#125;, h[f] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_flow</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    add_path(f, t, v, c);</span><br><span class="line">    add_path(t, f, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N], pre[N], incf[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, incf[s] = INF, incf[t] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i; i = e[i].nex) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;v = e[i].t, &amp;w = e[i].v, &amp;c = e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!w || dis[v] &lt;= dis[u] + c) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = dis[u] + c, incf[v] = min(w, incf[u]), pre[v] = i;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) q.push(v), vis[v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxflow += incf[t];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = e[pre[u] ^ <span class="number">1</span>].t) &#123;</span><br><span class="line">        e[pre[u]].v -= incf[t], e[pre[u] ^ <span class="number">1</span>].v += incf[t];</span><br><span class="line">        mincost += incf[t] * e[pre[u]].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类Dinic模板"><a href="#类Dinic模板" class="headerlink" title="类Dinic模板"></a>类Dinic模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tmplate_Use</span></span><br><span class="line"><span class="comment">//mcmf(s, t) return MaxFlow</span></span><br><span class="line"><span class="comment">//ret means MinCost</span></span><br><span class="line"><span class="comment">//addedge(u, v, w, c)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot = <span class="number">1</span>, lnk[N], cur[N], ter[M], nxt[M], cap[M], cost[M], dis[N], ret;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, cap[tot] = w, cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123; add(u, v, w, c), add(v, u, <span class="number">0</span>, -c); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, lnk, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ter[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[v] &gt; dis[u] + cost[i]) &#123;</span><br><span class="line">                dis[v] = dis[u] + cost[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.push(v), vis[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &amp;&amp; ans &lt; flow; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = ter[i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v] &amp;&amp; cap[i] &amp;&amp; dis[v] == dis[u] + cost[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, t, <span class="built_in">std</span>::min(cap[i], flow - ans));</span><br><span class="line">            <span class="keyword">if</span> (x) ret += x * cost[i], cap[i] -= x, cap[i ^ <span class="number">1</span>] += x, ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> ((x = dfs(s, t, INF))) ans += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98" target="_blank" rel="noopener"><strong>最小费用最大流-Wikipedia</strong></a><br><a href="https://oi-wiki.org/graph/flow/min-cost/" target="_blank" rel="noopener"><strong>最小费用最大流-OIWiki</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4292 Food</title>
    <url>/2019/11/04/HDU4292/</url>
    <content><![CDATA[<p>这题主要问题是如何将<strong>点的限制</strong>转化为对<strong>边的容量限制?</strong><br>对于<strong>点的限制</strong>，一般<strong>常用</strong>的方法是进行<strong>拆点</strong>。</p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/HDU-4292#author=0" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个人，$f$种食物和$d$种饮料，每种<strong>饮料和食物</strong>的个数已知，假设一个人拿到<strong>一个</strong>自己喜欢的<strong>食物</strong>或<strong>饮料</strong>，那个人就会感到满足。</p>
<p><del>显然每个人都有自己喜欢的<strong>饮料和食物</strong>，和不喜欢的。这个条件由题目给出。</del></p>
<p><strong>问: </strong>最大能让几个人满足?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p><strong>!!多组输入!!</strong></p>
<p><strong>第1行</strong>输入<strong>人数</strong>$n$，<strong>食物的种类</strong>$f$，<strong>饮料的种类</strong>$d$<br><strong>第2行</strong>输入人数$f$个数字，第$i-th$个数，代表第$i$种<strong>食物的个数</strong>。<br><strong>第3行</strong>输入人数$d$个数字，第$i-th$个数，代表第$i$种<strong>饮料的个数</strong>。<br><strong>接下来n行</strong>，每行有个长度为$f$的字符串。</p>
<ul>
<li>字符串第$j-th$字符<strong>表示</strong>第$i-th$行的人对$j-th$种食物的<strong>喜爱情况</strong>。$Y$喜欢，$N$不喜欢。</li>
</ul>
<p><strong>接下来n行</strong>，是对饮料的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">YYN</span><br><span class="line">NYY</span><br><span class="line">YNY</span><br><span class="line">YNY</span><br><span class="line">YNY</span><br><span class="line">YYN</span><br><span class="line">YYN</span><br><span class="line">NNY</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于题目要求<strong>求最大满足人数</strong>，所以我们只需每个人<strong>给一个</strong>喜欢的饮料<strong>或</strong>食物即可。也就是说，对于每个<strong>人的节点</strong>，<strong>容量限制为1</strong>。<br><strong>但是</strong>，由于最大流算法中没有对点进行限制(即每个点的容量为$inf$)，所以直接建图是肯定是<strong>不合适</strong>的，<code>因为直接建图无法体现点的限制</code>，所以我们想办法将<strong>点的限制</strong>转为<strong>边的容量</strong>，这时候，我们可以使用<strong>拆点思想</strong>，<strong>拆点思想</strong>是将点<strong>一分为二</strong>，然后在中间<strong>新建一条边</strong>，设置<strong>新建立的边的容量</strong>为<strong>点的限制</strong>，从而实现<strong>点的限制</strong>与<strong>边的限制</strong>的转换。</p>
<blockquote>
<p>拆点操作如下图示例。</p>
</blockquote>
<p><img src="/img/chaidian.png" alt="chaidian"></p>
<p>之后我们参照<strong>拆点思想</strong>，如下建图，这样就将<strong>点的限制</strong>转化为了<strong>边的限制</strong>(即边的容量)，之后然后跑一遍$s$-&gt;$t$的$dinic$之后出来的就是正确答案了。</p>
<p><img src="/img/HDU4292.png" alt="buildGraph"></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>使用的是紫书的模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> &amp;n,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> &amp;d)</span> </span>&#123;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="keyword">int</span> v,tmp,cc;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,t = <span class="number">1e3</span>+<span class="number">600</span>;</span><br><span class="line">    <span class="comment">//food n+1 to n+f</span></span><br><span class="line">    <span class="comment">//drink n+f+1 to n+f+d</span></span><br><span class="line">    <span class="comment">//people = 1 to n</span></span><br><span class="line">    cc = n+f+d;</span><br><span class="line">    <span class="comment">//cut</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dinic.AddEdge(i,i+cc,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//s-&gt;food</span></span><br><span class="line">    tmp = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=f; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">        dinic.AddEdge(s,tmp+i,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//drink-&gt;t</span></span><br><span class="line">    tmp = n+f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">        dinic.AddEdge(tmp+i,t,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//food-&gt;to people</span></span><br><span class="line">    tmp = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s"</span>,str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;f; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">'Y'</span>) dinic.AddEdge(tmp+j+<span class="number">1</span>,i,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//to-&gt;drink people</span></span><br><span class="line">    tmp = n+f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s"</span>,str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">'Y'</span>) dinic.AddEdge(i+cc,tmp+j+<span class="number">1</span>,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dinic.Maxflow(s,t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,f,d;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;f,&amp;d)) slove(n,f,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>HDUOJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>HDUOJ</tag>
        <tag>最大流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2253 Frogger</title>
    <url>/2019/11/03/POJ2253/</url>
    <content><![CDATA[<p><strong>松弛操作</strong>的深度理解和使用，并且题的<strong>输出精度</strong>有点变态</p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-2253" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有两只情侣蛙，那就叫他们$a$蛙和$b$蛙好了，河塘上有有$n$个立足点，以至蛙$a$在<strong>点1</strong>，蛙$b$在<strong>点2</strong>，问从<strong>点1</strong>到<strong>点2</strong>的最小跳跃距离是多少？</p>
<p>这边<strong>跳跃距离</strong>指的是两个立足点之间的距离，每个立足点用坐标给出$&lt; x_i , y_i &gt;$</p>
<blockquote>
<p>输入</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>		<span class="comment">//表示点的个数</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span>		<span class="comment">//表示点的坐标&lt;xi,yi&gt;</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span>		</span><br><span class="line"><span class="number">17</span> <span class="number">4</span></span><br><span class="line"><span class="number">19</span> <span class="number">4</span></span><br><span class="line"><span class="number">18</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span>		<span class="comment">//表示退出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<p><strong>注意每组输出完还需要输出换行。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Scenario #<span class="number">1</span></span><br><span class="line">Frog Distance = <span class="number">5.000</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line">Frog Distance = <span class="number">1.414</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>!!注意点!!</strong></p>
<ul>
<li>这题的编译器要选择<code>c++</code></li>
<li>输出语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>,++cnt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3f\n\n"</span>,gph[<span class="number">1</span>][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>我们可以很轻松的发现，显然每个解的跳跃距离，就是那个解的边中的最大边，由于问题求的是<strong>最小距离</strong>，所以求是求所有解中的<strong>最长边的最小值</strong>。<br>由于松弛操作寻找的是长度最短的路径，由于我们现在要寻找的是<strong>最长边的最小值</strong>，那么我们只要将<strong>原来松弛</strong>操作变为$d[to] = min(d[to],max(d[now],w[now][to]))$，这边$d[x]$代表到$x$的最长边，$[a][b]$代表$a$-&gt;$b$的边的长度。</p>
<blockquote>
<p>? 松弛类似于对所有连接节点进行试探，并找到符合条件的解。原来的松弛操作在试探点，这个松弛操作在试探最小的最大边。<del>我口胡乱说的，不知道对不对。</del></p>
</blockquote>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>在这里用的是<strong>Floyd</strong>算法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="keyword">double</span> gph[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                gph[i][j] = min(gph[i][j],max(gph[i][k],gph[k][j]));	<span class="comment">//松弛</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,x+i,y+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) </span><br><span class="line">                gph[i][j] = gph[j][i] = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="number">1.0</span>*(x[i]-x[j]),<span class="number">2</span>) + <span class="built_in">pow</span>(<span class="number">1.0</span>*(y[i]-y[j]),<span class="number">2</span>));</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>,++cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3f\n\n"</span>,gph[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>最短路</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2387 Til the Cows Come Home</title>
    <url>/2019/11/03/POJ2387/</url>
    <content><![CDATA[<p>这是一道<strong>最短路</strong>的<strong>模板题</strong>。</p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-2387" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道模板题，虽然要注意可能会有重边，但是SPFA和Dijkstra都支持重边。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>用的是<strong>SPFA</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Vmaxn = <span class="number">2e3</span>+<span class="number">100</span>,Emaxn = <span class="number">4e3</span>+<span class="number">100</span>,inf = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,w;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">def</span><span class="params">(<span class="keyword">int</span> &amp;to, <span class="keyword">int</span> &amp;next,<span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; to = to;</span><br><span class="line">        <span class="keyword">this</span>-&gt; next = next;</span><br><span class="line">        <span class="keyword">this</span>-&gt; w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPFA</span> &#123;</span></span><br><span class="line">    EDGE edge[Emaxn];</span><br><span class="line">    <span class="keyword">int</span> head[Vmaxn],d[Vmaxn],cnt;</span><br><span class="line">    <span class="keyword">bool</span> vis[Vmaxn];</span><br><span class="line">    SPFA() &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        edge[cnt].def(b,head[a],w);</span><br><span class="line">        head[a] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runSpfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) d[i] = inf;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span>.push(s);</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">            now = <span class="built_in">list</span>.front();</span><br><span class="line">            <span class="built_in">list</span>.pop();</span><br><span class="line">            vis[now] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now]; i!=<span class="number">-1</span>; i=edge[i].next) &#123;</span><br><span class="line">                EDGE&amp; e = edge[i];</span><br><span class="line">                <span class="keyword">if</span>(d[e.to] &gt; d[now] + e.w) &#123;</span><br><span class="line">                    d[e.to] = d[now] + e.w;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[e.to]) &#123;</span><br><span class="line">                        vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">list</span>.push(e.to);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    SPFA spfa;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;		<span class="comment">//边数，和点数</span></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w; <span class="comment">//双向边</span></span><br><span class="line">        spfa.AddEdge(a,b,w);</span><br><span class="line">        spfa.AddEdge(b,a,w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa.runSpfa(n,n); <span class="comment">//由于题目要求从终点开始跑</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; spfa.d[<span class="number">1</span>]; <span class="comment">//最短路</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>最短路</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法-SPFA</title>
    <url>/2019/11/03/SPFA/</url>
    <content><![CDATA[<p><strong>SPFA</strong>是一种求<strong>最短路</strong>的算法。国际上一般认为是队列优化的<strong>贝尔曼-福特算法</strong>，用来解<strong>DAG</strong>中的最短路问题。</p>
<blockquote>
<p>模板题地址 | <a href="https://www.luogu.org/problem/P3371" target="_blank" rel="noopener"><strong>Here</strong></a><br><strong>SPFA</strong>模板 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Template</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>最短路问题是，在一张图中，求从一个<strong>源点</strong>$s$到<strong>其他点的最小距离</strong>。对于下面的图，设<strong>点1</strong>是<strong>源点s</strong>。</p>
<p><img src="/img/SPFA-1.png" alt="inc"></p>
<blockquote>
<p>最小距离为 (a-&gt;b表示a到b的最小距离)</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表示</th>
<th style="text-align:center">距离</th>
<th style="text-align:center">表示</th>
<th style="text-align:center">距离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1-&gt;1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1-&gt;2</td>
<td style="text-align:center">22</td>
</tr>
<tr>
<td style="text-align:center">1-&gt;3</td>
<td style="text-align:center">12</td>
<td style="text-align:center">1-&gt;4</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">1-&gt;5</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1-&gt;6</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><blockquote>
<p>支持负权，但是不支持负环</p>
</blockquote>
<h3 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h3><p><strong>松弛</strong>是Bellman-Ford算法中一个十分<strong>重要的概念</strong>，Bellman-Ford算法就是基于松弛的。<br>假设对点$u$和$v$的<strong>松弛的操作</strong>为$d[v] = min(d[v],d[u] + w[u][v])$，在着个操作中，$d[x]$代表从源点$s$到点$x$的距离，$w[x][y]$代表从$x$-&gt;$y$的花费。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>就是对整个图的所有边进行松弛操作，直到<strong>无法松弛为止</strong>。这边的无法松弛含义是<strong>松弛结果不变</strong>。</p>
<h4 id="口胡Bellman-Ford正确性理解"><a href="#口胡Bellman-Ford正确性理解" class="headerlink" title="口胡Bellman-Ford正确性理解"></a>口胡<code>Bellman-Ford</code>正确性理解</h4><blockquote>
<p>不存在负环 <code>假设点的个数为n</code></p>
</blockquote>
<ol>
<li>假设在图中不存在负环，由于对当前点进行松弛后，得到一个新的值$a$，由于<strong>不存在负环</strong>，所以无论如何，再一次通过环回到这一点的时候必定为$a+w$，其中$w$必定<strong>大于</strong>0,通过环回来后松弛<strong>不会继续进行</strong>。并且由于无法松弛，所以肯定保证了所求<strong>路径最短</strong>。</li>
<li>由于最短路存在，因此松弛的次数最多为$n-1$次。<del>还未理解，所以我也不造未啥…</del></li>
</ol>
<blockquote>
<p>存在负环 <code>假设点的个数为n</code></p>
</blockquote>
<ol>
<li>假设存在负环，那么会造成上述证明中$ (a+w) \leq a $ 会导致松弛在这个<strong>负环上持续进行</strong>，程序陷入死循环。</li>
<li>我们可以用这个性质来判断是否存在负环，因为只要松弛次数到达n就表示，图中存在负环。</li>
</ol>
<h3 id="Bellman-Ford实现"><a href="#Bellman-Ford实现" class="headerlink" title="Bellman-Ford实现"></a>Bellman-Ford实现</h3><blockquote>
<p>来源 <a href="https://oi-wiki.org/graph/shortest-path/#_5" target="_blank" rel="noopener"><strong>OI-Wiki</strong></a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">relax(u, v) &#123;</span><br><span class="line">    dist[v] = min(dist[v], dist[u] + edge_len(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dist[i] = edge_len(S, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> each <span class="title">edge</span><span class="params">(u, v)</span> </span>&#123;</span><br><span class="line">        relax(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p><strong>SPFA算法</strong>是一种对<strong>Bellman-Ford算法</strong>的<strong>队列优化</strong>。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote>
<p>摘自<a href="https://oi-wiki.org/graph/shortest-path/#_5" target="_blank" rel="noopener"><strong>OI-Wiki</strong></a></p>
</blockquote>
<p>很多时候我们并不需要那么多<strong>无用的松弛</strong>操作。<br>很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。<br>那么只要用队列来维护“哪些结点可能会引起松弛操作”，就可以了。</p>
<h3 id="SPFA模板"><a href="#SPFA模板" class="headerlink" title="SPFA模板"></a>SPFA模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Vmaxn = <span class="number">1e4</span>+<span class="number">100</span>,Emaxn = <span class="number">5e5</span>+<span class="number">100</span>,inf = <span class="number">2147483647</span>; <span class="comment">//Vmaxn点的最大，Emaxn边的最大。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPFA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[Vmaxn],d[Vmaxn],cnt,n;</span><br><span class="line">    <span class="keyword">bool</span> vis[Vmaxn];</span><br><span class="line">    EDGE edge[Emaxn];</span><br><span class="line"></span><br><span class="line">    SPFA() &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        n = n;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge[++cnt].to = b;</span><br><span class="line">        edge[cnt].next = head[a];</span><br><span class="line">        edge[cnt].w = w;</span><br><span class="line">        head[a] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runSpfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) d[i] = inf; <span class="comment">//Re_Reason: n is error to m</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">list</span>.push(s);</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">list</span>.empty()) &#123;</span><br><span class="line">            now = <span class="built_in">list</span>.front();</span><br><span class="line">            <span class="built_in">list</span>.pop();</span><br><span class="line">            vis[now] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now]; i!=<span class="number">-1</span>; i=edge[i].next) &#123;</span><br><span class="line">                EDGE &amp;e = edge[i];</span><br><span class="line">                <span class="keyword">if</span>(d[e.to] &gt; d[now] + e.w) &#123;</span><br><span class="line">                    d[e.to]  = d[now] + e.w;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[e.to]) &#123;</span><br><span class="line">                        vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">list</span>.push(e.to);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="noopener"><strong>Wikipedia-贝尔曼-福特算法</strong></a><br><a href="https://oi-wiki.org/graph/shortest-path/#_5" target="_blank" rel="noopener"><strong>OIWiki-最短路</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>莫名失落期的心灵慰藉</title>
    <url>/2019/11/03/Relax1/</url>
    <content><![CDATA[<blockquote>
<p>date: 2019-11-03 00:03:32<br>坦言，我也不知道为何，就是觉得失落，想找人聊天，却感觉又渐行渐远了。</p>
</blockquote>
<a id="more"></a>
<p>“左眼跳财，右眼跳灾”，我始终保留对这句言语坚定不移的认同，不过最近莫名奇妙的失落又总是让人无法把持，以至于，总是默默的坠入失望的深渊，或者苦苦祈求救赎，却迷茫在了朝圣的路上，时光回溯到了，一年前，那时候，还大抵高考已经考完了罢，成长慢慢的在父母的一声叹息中迈开了脚步，那声叹息十分的微不可闻，仔细回想，也许叹息从头就不存在吧，不过那段时光，着实是十分放松的，以至于现在回想起来，仿佛做了一个很长很长的梦，仿佛醒来的开始，就是最后的英语考试结束时候的铃声。既没有雄狮的睁眼，也没有个人自我认知的觉醒，只是感觉真的睡了好久好久，醒来的时候还带着睡着时候的傻气，呆呆的望着这个新的世界，毕竟从那以后，再也没有了，没有了每天都能见面的同学，没有了一起上下学的朋友，没有了期望着的朦胧的爱恋，没有了每天会出现再你周围的前后桌，当然还有好的不可开交的同桌，以及固定时间都能见到的老师，真的，总觉得，还来不及叛逆，我的梦就草草的结束了。</p>
<p>时光接着往前走走，我记得那次，《你的名字》刚好上映，我是一个人默默的去看的，那次没有骗家里人，坦率的说了是自己一个人，或者，当时就只是一个人想去了，便去了。那时候还以为自己早就习惯了孤独，但是看着身边的情侣还是，会有些许的妒忌，也不知道是为什么。之后的《声之形》也是一个人，这些故事，都不曾讨论孤独，不过倒是统一的描绘了后悔和补救的物语。就像要英语默写的前一晚一样，我也幻想也有这样的能力，去补救之前犯下的过错。不过这都是幻想，理所当然的，发下来的”重默”宣告了，现实的判决。和他人的关系也是一样，每一个不同的选择都会走向不同的分支，最后导致不同的维护方式，我是十分讨厌维护关系的，年少时，曾幻想，只要足够强，那么这种东西不要也无所谓吧。不过毕竟人是社会性的动物，为了维持家教还是其他什么杂七杂八的形象，还是学习了一些待人处世的方式，虽然不是我的领悟，但是拿来用应该也会是足够了，用着用着，有时候也会开始迷茫，我到底是在哪里？还是我只不过是个没有思想的浮萍，靠着模仿他人来持续生活？从未找到过答案，最后在《超凡2》格缊的演讲中，马虎的找到了答案。</p>
<p>差不多了，于是回到了现在，不知道为何，将思绪编织成了文字，心情也慢慢的好了一点，这也许着就是写作的乐趣之一吧。仔细回想，在晚上突然失落的原因，还是追溯到了《天气之子》上面，慢慢的也理解了，失落是一种什么样的感觉。也许失望更多的是对自己的迷茫，和终于醒来的恐惧吧。</p>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记-最小割</title>
    <url>/2019/11/02/MINCUT/</url>
    <content><![CDATA[<p>关于割的定义，和最大流最小割定理的笔记。</p>
<blockquote>
<p>题目地址 | <a href="https://www.luogu.org/problem/P1361" target="_blank" rel="noopener"><strong>1. 小M的礼物</strong></a> | <a href="https://www.luogu.org/problem/P2057" target="_blank" rel="noopener"><strong>2. 善意的投票</strong></a> | <a href="https://www.luogu.org/problem/P1344" target="_blank" rel="noopener"><strong>3. Pollutant Control</strong></a> | <a href="https://www.luogu.org/problem/P1345" target="_blank" rel="noopener"><strong>4. Telecowmunication</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>对于一个点集$V$，<strong>割</strong>将点集划分成$S$和$T$，其中源点$s \in S$，汇点$t \in T$，我们将这样一种划分点的方式称为<strong>割</strong>，用符号来$[S,T]$来表示，割将点集划分为$S$和$T$ ( $T = V - S$ )。</p>
<h3 id="割的容量"><a href="#割的容量" class="headerlink" title="割的容量"></a>割的容量</h3><p>我们用$c(S,T)$来表示割的容量，割的容量定义为 $c(S,T) = \sum_{u \in S, v \in T}{c(u,v)}$，一般记作$c[S,T]$</p>
<h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><p>$c(S,T)$ 最小的割被称为最小割。</p>
<h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对于一个网络流，从源点$s$到汇点$t$的最大流量<strong>等于</strong>割$c[S,T]$的最小值，即$MAX(|f|) = MIN(c[S,T])$。</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>在一个流网络$G(V,E)$中设任意一个流为$f$,任意一个割为$[S,T]$，必然有$|f| \leq c[S,T]$，因此网络的最小割必然不超过最大流。并且由<strong>流量平衡</strong>可知，最大流跑出的残量网络必为一种最小割。</p>
<p><strong>证明:</strong></p>
<script type="math/tex; mode=display">
|f| = f(S,T) = \sum_{u \in S}\sum_{v \in T}{f(u,v)} \leq \sum_{u \in S}\sum_{v \in T}{c(u,v)}  = C[S,T]</script><h2 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h2><blockquote>
<p>记录做题中遇到的建图问题模型，还在积累ing</p>
</blockquote>
<h3 id="两者取一式问题"><a href="#两者取一式问题" class="headerlink" title="两者取一式问题"></a>两者取一式问题</h3><h4 id="Exp1"><a href="#Exp1" class="headerlink" title="Exp1"></a>Exp1</h4><p>有$n$个物品，要放入$A$和$B$<strong>两个集合</strong>中，<strong>每个只能放入一个集合</strong>中，对于物品$i$放入$A$集合中会花费$a_i$，对于物品$i$放入$B$集合中会花费$b_i$，并且物品$i_1$和$i_2$分开会花费$w$。<br><strong>问:</strong> <strong>最小</strong>的花费是多少。</p>
<p><strong>解决</strong>:</p>
<p>我们设置一个$s$和$t$，$\langle s,i \rangle$代表$a_i$，$\langle i,t \rangle$代表$b_i$，建立$\langle i_1,i_2 \rangle$和$\langle i_2,i_1 \rangle$代表$w$由于<strong>损失是双向</strong>的所以要建立<strong>双向边</strong>。</p>
<p>之后跑出的最大流，就是最小损失。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="求最小割容量"><a href="#求最小割容量" class="headerlink" title="求最小割容量"></a>求最小割容量</h3><blockquote>
<p>详见<a href="http://mirasire.xyz/2019/10/20/MAXFLOW/">网络流笔记-最大流</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与最大流模板相同</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="求S集合"><a href="#求S集合" class="headerlink" title="求S集合"></a>求S集合</h3><p><strong>注意</strong>这边必须使用<strong>DFS</strong>，不能靠满流边来判断点属于的集合，因为满流边不一定为被割的边。</p>
<p>下面<strong>是伪代码</strong><del>因为我没尝试编译过</del>。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pseudo-code</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>;					<span class="comment">//vis标记是否访问过</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u]; i; i = nxt[i]) &#123;		<span class="comment">//遍历点u连接的边</span></span><br><span class="line">      <span class="keyword">int</span> v = ter[i];</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; val[i]) &#123;			<span class="comment">//val 代表残量</span></span><br><span class="line">        <span class="built_in">list</span>.insert(v);</span><br><span class="line">        dfs(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="求割边的数目"><a href="#求割边的数目" class="headerlink" title="求割边的数目"></a>求割边的数目</h3><p>可以用求的$S$的集合，然后根据定义来求得边的数目。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><strong>《最小割模型在信息学中的应用》</strong>—胡伯涛<br><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"><strong>Wikipedia-最大流最小割定理</strong></a><br><a href="https://oi-wiki.org/graph/flow/min-cut/" target="_blank" rel="noopener"><strong>OIWiki-最小割</strong></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>P1361 小M的作物</title>
    <url>/2019/10/30/P1361/</url>
    <content><![CDATA[<p>这是一道<strong>两者取一式问题</strong>，通常可以用<strong>最小割</strong>解决。</p>
<blockquote>
<p>题目链接 | <a href="https://www.luogu.org/problem/P1361" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有两块菜园$A，B$，你要种$n$种种子(每种只有一粒)，每颗种子自能种在一个菜园中。<br>每个种子在不同的菜园种有不同的收益，一些种子组合种在一个菜园有<strong>额外</strong>的收益。</p>
<p><strong>问:</strong> 收益最大化是多少?</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>先输入$n$代表有$n$种种子，接下来两行每行包含$n$个的数字。<br>第一行表示 $i-th$ 种子种在 $A$ 中的收益<br>第二行表示 $i-th$ 种子种在 $B$ 中的收益<br>然后输入$k$，代表一共有$k$种组合。<br>之后每行输入 $m$ $c_1$ $c_2$ 和 $m$个数<br>$m$个数代表这个组合包含的种子，$c_1$代表这个组合种在$A$中的额外收益，$c_2$代表这个组合种在$A$中的额外收益，</p>
<p>只有一组数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>		<span class="comment">//n</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">1</span>		<span class="comment">//in A</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span>		<span class="comment">//in B</span></span><br><span class="line"><span class="number">1</span>		<span class="comment">//k</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>	<span class="comment">//m c1 c2 p[m]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
<p>11 //最大收益是11</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有$n$个东西，需要将这$n$个东西放入两个地方，每个东西放入的地方不同，会有不同的变化(收益或者支出)，要求最后结果符合题意(收益最大或是支出最小)。</p>
<p>这样一类问题被称为<strong>两者取一式问题</strong>，在题目中的特征是将点集分成两份，通常这类题可以用<strong>最小割</strong>来解决。因为通过最小割我们将这堆物品<strong>一分为二</strong>了。</p>
<hr/>

<p>对于此题，我们先不考虑组合带来的收益建立下图,</p>
<p><img src="/img/P1361—1.png" alt="normal"></p>
<p>对于上图我们定义$\langle s,i \rangle$为种在$A$菜园的收益，$\langle i,t \rangle$为种在$B$菜园的收益，那么求<strong>最大收益</strong>，换言之也就是求<strong>损失最小</strong>，等价于求割掉以后的容量和最小，显然用<strong>最大流最小割</strong>定理，可得<strong>损失的最小容量</strong>和为<strong>最大流的流量</strong>，即答案为<strong>所有的收益 - 最小割</strong>。</p>
<p>由于这题还有一个组合收益，我们通过观察发现每个组合最多只有三种状态: </p>
<ul>
<li>全种在$A$，这就对$A$贡献了额外收益</li>
<li>全种在$B$，这就对$B$贡献了额外收益</li>
<li>被分开了，这对$A$，$B$都没有贡献收益</li>
</ul>
<p>于是由于我们定义的$\langle s,v \rangle$代表对于$A$的收益，所以我们构造一个<strong>点5</strong>连接$A$用来表示<strong>1，2组合</strong>对于$A$的额外收益，并且<strong>点5</strong>与<strong>1，2</strong>的连接代表这是一个组合。<br><strong>点5连接1，2的边</strong>无法被割掉（因为这代表这是一种组合），所以将我们构造的<strong>点5</strong>和<strong>1，2</strong>的连接边设为$inf$。对于$B$的建边同理，由此我们如下建图，跑一遍最大流，用上面的公式即可。</p>
<p><img src="/img/P1361—2.png" alt="plus"></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>用的是紫书的模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    ll n,cnt = <span class="number">0</span>,sum=<span class="number">0</span>,k,m;</span><br><span class="line">    ll s = <span class="number">0</span>,t = maxn<span class="number">-20</span>,tmp;</span><br><span class="line">    ll c1,c2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="comment">//s-&gt;node</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">        sum += tmp;</span><br><span class="line">        dinic.AddEdge(s,i,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//node-&gt;t</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">        sum += tmp;</span><br><span class="line">        dinic.AddEdge(i,t,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=n+<span class="number">1</span>; i&lt;=k; i++,j+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//j,j+1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;m,&amp;c1,&amp;c2);</span><br><span class="line">        sum += c1;</span><br><span class="line">        sum += c2;</span><br><span class="line">        dinic.AddEdge(s,j,c1);</span><br><span class="line">        dinic.AddEdge(j+<span class="number">1</span>,t,c2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;m; k++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">            dinic.AddEdge(j,tmp,INF);</span><br><span class="line">            dinic.AddEdge(tmp,j+<span class="number">1</span>,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum - dinic.Maxflow(s,t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>LuoGu</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>LuoGu</tag>
        <tag>最小割</tag>
        <tag>两者取一式问题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1087 A Plug for UNIX</title>
    <url>/2019/10/30/POJ1087/</url>
    <content><![CDATA[<p>这题是一个普通的添加超级源点和汇点的题，但是题目意思比较难理解。</p>
<blockquote>
<p>题目链接 | <a href="https://vjudge.net/problem/POJ-1087" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个插座，$m$个插头，$k$种转接器，转接器的个数是<strong>无限</strong>的。<br>知道$n$个插座的型号，$m$个插头的型号，和$k$种转接器转接的插座类型和插头类型。</p>
<p>每个插座的型号用一个<strong>&lt;=24</strong>个字母的字符串表示。<br>转接器可以叠加使用，也就是说你有<strong>X-&gt;B</strong>和<strong>B-&gt;C</strong>的转接器，你就相当等于拥有<strong>X-&gt;C</strong>的转接器。</p>
<p><strong>问:</strong> 最后剩余插不上的插头个数最小是多少？</p>
<blockquote>
<p>输入</p>
</blockquote>
<p>只有<strong>一组</strong>案例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>				<span class="comment">//插座个数</span></span><br><span class="line">A </span><br><span class="line">B </span><br><span class="line">C </span><br><span class="line">D </span><br><span class="line"><span class="number">5</span>				<span class="comment">//插头个数 </span></span><br><span class="line">laptop B			<span class="comment">//名字(其实没用)  插头型号</span></span><br><span class="line">phone C </span><br><span class="line">pager B </span><br><span class="line">clock B </span><br><span class="line">comb X </span><br><span class="line"><span class="number">3</span>				<span class="comment">//转化器种类 </span></span><br><span class="line">B X				<span class="comment">//可以从 B -&gt; X</span></span><br><span class="line">X A </span><br><span class="line">X D</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>				<span class="comment">//只有一个插头没地方插</span></span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于目的是让插头插上操作，转化器的个数无限，所以很容易想到用转化器关系来进行建图。<br>之后发现所要求的<strong>最小未插数 == 总插头个数 - 最大插入数</strong>，于是就向最大流方向思考，之后不难发现这就是一道添加<strong>超级源点/汇点</strong>的题目。</p>
<p><strong>建图方式:</strong> </p>
<ul>
<li>源点-&gt;插头 ——&gt; 容量为每个种类插座的个数 </li>
<li>插座关系建图 —&gt; 容量为<strong>INF</strong> (因为转化器数量无限)</li>
<li>插头-&gt;插座 ——&gt; 容量为<strong>1</strong> 默认一种类型的插座只有一个口 <del>这边有点坑</del></li>
</ul>
<p><strong>小细节: </strong>由于每个插座种类是用<strong>&lt;=24</strong>个字符的字符串表示，所以需要考虑编码的问题。</p>
<p>我的<strong>解决办法</strong>是直接用<strong>map</strong>来进行<strong>重新映射</strong>，每次不同的就赋予那个型号一个新的编号，这样就回避了编码问题。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>最大流为紫书模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> p1[<span class="number">120</span>]=&#123;<span class="number">0</span>&#125;,p2[<span class="number">120</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> tmp,tmp2;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">210</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        p1[tmp-<span class="string">'A'</span>+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">120</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(p1[i]) dinic.AddEdge(i,t,p1[i]);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; tmp;</span><br><span class="line">        p2[tmp-<span class="string">'A'</span>+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">120</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(p2[i]) dinic.AddEdge(s,i,p2[i]);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; tmp2;</span><br><span class="line">        dinic.AddEdge(tmp-<span class="string">'A'</span>+<span class="number">1</span>,tmp2-<span class="string">'A'</span>+<span class="number">1</span>,INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dinic.Maxflow(s,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>POJ</tag>
        <tag>超级源点/汇点</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础知识</title>
    <url>/2019/10/29/DataStruct/</url>
    <content><![CDATA[<p>用来学习<strong>最最最</strong>基本的数据结构，目前还在更新ing。</p>
<a id="more"></a>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>什么是<strong>数据</strong>? </p>
<ul>
<li>数据指能<strong>输入</strong>到计算机中并能被计算机<strong>识别</strong>和<strong>处理</strong>的符号。</li>
</ul>
<p>数据的<strong>基本单位</strong>?</p>
<ul>
<li>数据的<strong>基本单位</strong>是<strong>数据元素</strong>。</li>
</ul>
<blockquote>
<p>数据元素在不同的场合也称为，记录，节点…..</p>
</blockquote>
<p>构成数据元素的<strong>最小单位</strong>是？</p>
<ul>
<li>构成<strong>数据元素</strong>的最小单位是<strong>数据项</strong></li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构</strong>指相互之间存在一定关系的<strong>数据元素</strong>的集合，一般分为逻辑结构和存储结构。</p>
<blockquote>
<p>Tips: <strong>随机存储</strong>结构: 计算任意一个元素的地址花费的时间相同。</p>
</blockquote>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑结构只涉及数据元素之间的<strong>逻辑关系</strong>，不负责具体数据在计算机中的存储。</p>
<p>一共有<del>四</del><strong>三种</strong>基本类型:</p>
<ul>
<li><del>集合结构</del></li>
<li>线性结构</li>
<li>树型结构</li>
<li>图结构</li>
</ul>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><blockquote>
<p>存储结构又叫物理结构</p>
</blockquote>
<p>存储结构是将逻辑结构存入计算机中的一种存储方式。具体的描述了，数据如何存储到计算机中。</p>
<p><strong>通常</strong>有<strong>两</strong>种:</p>
<ul>
<li>顺序存储 （同一段的地址必定连续)</li>
<li>链式存储 （同一段的地址可能连续也可能不连续)</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法?"></a>什么是算法?</h4><p>烧菜有<strong>菜谱</strong>，下棋有<strong>棋谱</strong>，那么解决问题就有一套解决问题的方法，那种方法就交错<strong>算法</strong>。</p>
<p><strong>算法</strong>有<strong>三个特性和</strong>四种描述方式**见下表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">特性</th>
<th style="text-align:center">序号</th>
<th style="text-align:center">描述方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">有穷性(不然死循环了)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">自然语言描述</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">确定性(不能有二义性)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">流程图</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">可行性(要能用程序设计语言书写)</td>
<td style="text-align:center">3</td>
<td style="text-align:center">伪代码(Pseudo-code)</td>
</tr>
<tr>
<td style="text-align:center"><strong>none</strong></td>
<td style="text-align:center"><strong>none</strong></td>
<td style="text-align:center">4</td>
<td style="text-align:center">程序设计语言</td>
</tr>
</tbody>
</table>
</div>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>衡量</strong>算法的效率。一般有两种估计的方法:</p>
<ul>
<li>事后统计 —&gt; 就是跑跑程序，测测数据。</li>
<li>事前估计 —&gt; 分析估算求复杂度。</li>
</ul>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>一般只对<strong>时间复杂度</strong>进行分析。</p>
<p>时间复杂度用$O(n)$来表示。具体求法请看书。</p>
<p>常见时间复杂度:</p>
<script type="math/tex; mode=display">
O(\log_2{n}) < O(n) < O(n\log_2{n}) < O(n^2) < O(n^3) < .... < O(2^n) < O(n!)</script><h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a>抽象数据类型(ADT)</h2><p>抽象数据类型(ADT)代表一系列操作的集合，没有考虑具体的实现。就类似于Interface，这是一种美妙的抽象，因为你可以用<strong>ADT+存储结构+具体设计</strong>来实现不同的数据类型。<br>简单的说就是，表<strong>ADT</strong>定义表<del>或者说线性表</del>的所有行为，然后你就用不同的存储方式实现了<strong>顺序表</strong>，<strong>单向链表</strong>，<strong>双向链表</strong>…..</p>
<blockquote>
<p>对于每种ADT，都可以进行自己的设计与实现，这边只提供参考。</p>
</blockquote>
<h3 id="表ADT"><a href="#表ADT" class="headerlink" title="表ADT"></a>表ADT</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">List ADT</span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line">	每个元素要求具有相同类型，相邻元素有前驱和后继</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line">	 Init</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 表的初始化</span><br><span class="line">		输出: 一个空表</span><br><span class="line">	 Creat </span><br><span class="line">		输入: 元素个数为n的数组arr</span><br><span class="line">		功能: 表的初始化，初始化为n个元素，每个元素都按顺序来自数组arr</span><br><span class="line">		输出: 无</span><br><span class="line">	 Destory</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 销毁线性表</span><br><span class="line">		输出: 无</span><br><span class="line">	 IsEmpty</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 判断表是否为空</span><br><span class="line">		输出: 表若为空返回<span class="literal">false</span>，否则返回<span class="literal">true</span></span><br><span class="line">	 GetSize</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 求表长</span><br><span class="line">		输出: 返回表中的元素个数</span><br><span class="line">	 Insert</span><br><span class="line">		输入: 位置n，要插入的元素add</span><br><span class="line">		功能: 将元素add插入到位置n处</span><br><span class="line">		输出: 插入成功返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">	 DeleteByPosition(<span class="keyword">const</span> <span class="keyword">int</span>&amp; );</span><br><span class="line">		输入: 位置n</span><br><span class="line">		功能: 删除n处的元素</span><br><span class="line">		输出: 删除成功返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">	 DeleteByValue</span><br><span class="line">		输入: 值del</span><br><span class="line">		功能: 删除第一次出现的del</span><br><span class="line">		输出: 删除成功返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">	 FindByPosition</span><br><span class="line">		输入: 位置n</span><br><span class="line">		功能: 找到并返回处在位置n的元素</span><br><span class="line">		输出: 位置n的元素</span><br><span class="line">	 FindByValue</span><br><span class="line">		输入: 元素ele</span><br><span class="line">		功能: 寻找元素第一次出现的位置n</span><br><span class="line">		输出: 如果找到返回n，否则返回<span class="number">-1</span></span><br><span class="line">	 DisplayAllElement</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 按照顺序打印所有元素</span><br><span class="line">		输出: 无</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题外话: 栈和队列一个共同点是只能<strong>对线性表的两端</strong>进行数据操作，类似<strong>阉割版的线性表</strong>，但是依旧被广泛使用….</p>
</blockquote>
<h3 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h3><h4 id="基础结构介绍"><a href="#基础结构介绍" class="headerlink" title="基础结构介绍"></a>基础结构介绍</h4><p>类似<strong>汉罗塔</strong>单个<strong>柱子</strong>的玩法，遵循先入后出原则(<strong>FILO</strong>)</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack ADT</span><br><span class="line">//数据</span><br><span class="line">	元素数据类型一致</span><br><span class="line">//操作</span><br><span class="line">	Init</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 初始化栈</span><br><span class="line">		输出: 无</span><br><span class="line">	Destory</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 删除栈</span><br><span class="line">		输出: 无</span><br><span class="line">	Push</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 将元素塞入栈内</span><br><span class="line">		输出: 成功塞入返回true，否则返回false</span><br><span class="line">	Pop</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 弹出栈顶元素</span><br><span class="line">		输出: 如果栈顶元素被成功弹出返回true，否则返回false</span><br><span class="line">	IsEmpty</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 判断栈是否为空</span><br><span class="line">		输出: 如果栈为空返回true，否则返回false;</span><br><span class="line">	GetTop</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 获得栈顶的值</span><br><span class="line">		输出: 栈顶存在返回true，否则返回false</span><br></pre></td></tr></table></figure>
<h3 id="队列ADT"><a href="#队列ADT" class="headerlink" title="队列ADT"></a>队列ADT</h3><h4 id="基础结构介绍-1"><a href="#基础结构介绍-1" class="headerlink" title="基础结构介绍"></a>基础结构介绍</h4><p>特性很像排队买汉堡，遵循先进先出原则(<strong>FIFO</strong>)</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue ADT</span><br><span class="line">//数据</span><br><span class="line">	元素数据类型一致</span><br><span class="line">//操作</span><br><span class="line">	Init</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 初始化队列</span><br><span class="line">		输出: 无</span><br><span class="line">	Destory</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 删除队列</span><br><span class="line">		输出: 无</span><br><span class="line">	Push</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 将元素塞入队列</span><br><span class="line">		输出: 成功塞入返回true，否则返回false</span><br><span class="line">	Pop</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 弹出队头元素</span><br><span class="line">		输出: 如果队头元素被成功弹出返回true，否则返回false</span><br><span class="line">	IsEmpty</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 判断队列是否为空</span><br><span class="line">		输出: 如果队列为空返回true，否则返回false</span><br><span class="line">	GetFront</span><br><span class="line">		输入: 无</span><br><span class="line">		功能: 获得队头的值</span><br><span class="line">		输出: 队头存在返回true，否则返回false</span><br></pre></td></tr></table></figure>
<h3 id="对上述ADT的实现"><a href="#对上述ADT的实现" class="headerlink" title="对上述ADT的实现"></a><del>对上述ADT的实现</del></h3><p><del>还在写ing</del></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串主要介绍它的<strong>基本定义</strong>和<strong>模式匹配算法</strong>。</p>
<h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>子串</strong>: 字符串中任意连续的字符组成的字符序列。<br><strong>主串</strong>: 包含子串的串。<br><strong>位置</strong>: 子串的第一个字符再主串中出现的<strong>位置</strong>。</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>在主串$S$中寻找$T$的过程称为<strong>模式匹配</strong>，$T$称为模式。</p>
<ul>
<li>成功 —-&gt; 返回第一次出现的位置。</li>
<li>失败 —-&gt; 返回0。</li>
</ul>
<h4 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h4><p>最朴素的<strong>暴力算法</strong></p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>推荐博客<a href="https://subetter.com/algorithm/kmp-algorithm.html" target="_blank" rel="noopener">KMP算法（1）：如何理解KMP - 刘毅</a></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="数组到底是什么"><a href="#数组到底是什么" class="headerlink" title="数组到底是什么?"></a>数组到底是什么?</h3><p>看书….</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>特殊矩阵 [分类]<ul>
<li>对称矩阵  </li>
<li>三角矩阵  </li>
<li>对角矩阵  </li>
</ul>
</li>
<li>稀疏矩阵 [具体方法]<ul>
<li>三元组</li>
<li>十字链表</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>数据结构与算法分析—C语言描述（原书第二版）</strong> [Mark Allen Weiss<em>著</em> 冯舜玺<em>译</em>]<br><strong>数据结构—从概念到C++实现（第三版）</strong> [王红梅 王慧 王新颖<em>编著</em>]</p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>Datastructures</tag>
        <tag>Learn</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Emacs Day1</title>
    <url>/2019/10/28/EmacsL1/</url>
    <content><![CDATA[<h2 id="为什么我要学Emacs"><a href="#为什么我要学Emacs" class="headerlink" title="为什么我要学Emacs?"></a>为什么我要学Emacs?</h2><p>一个平常的下午，我的GUI失效了，我想起了Emacs是个操作系统的言论，不仅感叹，”如果会Emacs该有多好啊”，自从那个念头开始诞生，我就知道，Emacs是不学不行了。</p>
<a id="more"></a>
<h2 id="初识Emacs-Tutorial"><a href="#初识Emacs-Tutorial" class="headerlink" title="初识Emacs Tutorial"></a>初识Emacs Tutorial</h2><blockquote>
<p>文章中的简写<br><code>C-x</code> = 按下 Ctrl和x，<code>M-x</code> = 按下 Alt和x</p>
</blockquote>
<p>打开Emacs后按照<code>C-h t</code>打开Emacs-TUTORIAL，学习基本的操作快捷键。</p>
<h3 id="基本移动操作"><a href="#基本移动操作" class="headerlink" title="基本移动操作"></a>基本移动操作</h3><pre><code>                 上一行 C-p
                      :
                      :
向左移 C-b .... 目前光标位置 .... 向右移 C-f
                      :
                      :
                 下一行 C-n
</code></pre><blockquote>
<p>解释: p n f b代表四个单词<code>previous</code>，<code>next</code>，<code>forward</code>，<code>backward</code>。</p>
</blockquote>
<h3 id="基础编辑操作"><a href="#基础编辑操作" class="headerlink" title="基础编辑操作"></a>基础编辑操作</h3><blockquote>
<p>..代表同上，…代表略</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M-v</td>
<td style="text-align:center">向上翻页</td>
<td style="text-align:center">C-v</td>
<td style="text-align:center">向下翻页</td>
</tr>
<tr>
<td style="text-align:center">M-a</td>
<td style="text-align:center">移动到句首</td>
<td style="text-align:center">C-a</td>
<td style="text-align:center">移动到行首</td>
</tr>
<tr>
<td style="text-align:center">M-e</td>
<td style="text-align:center">移动到句尾</td>
<td style="text-align:center">C-e</td>
<td style="text-align:center">移动到行尾</td>
</tr>
<tr>
<td style="text-align:center">M-f</td>
<td style="text-align:center">向右移动一个词</td>
<td style="text-align:center">C-f</td>
<td style="text-align:center">向右移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">M-b</td>
<td style="text-align:center">向左移动一个词</td>
<td style="text-align:center">C-b</td>
<td style="text-align:center">向左移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">M-&gt;</td>
<td style="text-align:center">跳到文章最开始</td>
<td style="text-align:center">C-g</td>
<td style="text-align:center">终止命令执行</td>
</tr>
<tr>
<td style="text-align:center">M-&lt;</td>
<td style="text-align:center">跳到文章最末尾</td>
<td style="text-align:center">C-l</td>
<td style="text-align:center">改变光标所在行的位置(上/中/下)</td>
</tr>
<tr>
<td style="text-align:center">M-d</td>
<td style="text-align:center">删除光标后一个词</td>
<td style="text-align:center">C-k</td>
<td style="text-align:center">删除光标后一个子符</td>
</tr>
<tr>
<td style="text-align:center">M-k</td>
<td style="text-align:center">移除光标到句尾的字符</td>
<td style="text-align:center">C-k</td>
<td style="text-align:center">移除光标到行尾的字符</td>
</tr>
<tr>
<td style="text-align:center">M-y</td>
<td style="text-align:center">详见手册</td>
<td style="text-align:center">C-y</td>
<td style="text-align:center">召回上一次移除</td>
</tr>
<tr>
<td style="text-align:center">C-/</td>
<td style="text-align:center">撤销</td>
<td style="text-align:center">C-s</td>
<td style="text-align:center">向下搜索字符</td>
</tr>
<tr>
<td style="text-align:center">C-r</td>
<td style="text-align:center">向上搜索字符</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><blockquote>
<p>M-x 可以用 <code>Tab</code> 来进行补全命令操作</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">Exp</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-x 字符/组合键</td>
<td style="text-align:center">字符扩展</td>
<td style="text-align:center">C-x C-s</td>
<td style="text-align:center">保存文件</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x C-b</td>
<td style="text-align:center">列出缓冲区</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x C-f</td>
<td style="text-align:center">寻找文件</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x C-c</td>
<td style="text-align:center">关闭Emacs</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x 1</td>
<td style="text-align:center">只保留光标在的一个窗口</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x o</td>
<td style="text-align:center">最大化当窗口</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">C-x u</td>
<td style="text-align:center">撤销</td>
</tr>
<tr>
<td style="text-align:center">M-x 命令名</td>
<td style="text-align:center">命令名扩展</td>
<td style="text-align:center">M-x org-mode</td>
<td style="text-align:center">启用org模式编辑文字</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">M-x text-mode</td>
<td style="text-align:center">启用text模式编辑文字</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">M-x fundamental-mode</td>
<td style="text-align:center">启用fundamental模式编辑文字</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">M-x make-frame</td>
<td style="text-align:center">新打开一个Emacs</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">..</td>
<td style="text-align:center">M-x delete-frame</td>
<td style="text-align:center">关闭当前Emacs</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Esc</td>
<td style="text-align:center">离开(M-x命令就可以用Esc Esc Esc离开)</td>
</tr>
<tr>
<td style="text-align:center">C-h c C-p</td>
<td style="text-align:center">获取C-p的简要说明</td>
</tr>
<tr>
<td style="text-align:center">C-h k C-p</td>
<td style="text-align:center">Emacs会新打开一个窗口显示C-p的详细说明</td>
</tr>
<tr>
<td style="text-align:center">C-h k</td>
<td style="text-align:center">查看快捷键文档[要输入快捷键]</td>
</tr>
<tr>
<td style="text-align:center">C-h v</td>
<td style="text-align:center">查看变量文档[要输入变量名]</td>
</tr>
<tr>
<td style="text-align:center">C-h f</td>
<td style="text-align:center">查看一个函数[要输入函数名]</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Easter-egg"><a href="#Easter-egg" class="headerlink" title="Easter egg"></a>Easter egg</h2><p>Write By Vim</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><strong>Emacs Tutorial</strong><br><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org#%E4%B8%80%E5%B9%B4%E6%88%90%E4%B8%BAemacs%E9%AB%98%E6%89%8B-%E5%83%8F%E7%A5%9E%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8" target="_blank" rel="noopener"><strong>一年成为Emacs高手 (像神一样使用编辑器)-陈斌</strong></a><br><a href="http://book.emacs-china.org/" target="_blank" rel="noopener"><strong>子龙山人-21天学会Emacs</strong></a></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
        <tag>学习历程</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#594 题解报告</title>
    <url>/2019/10/26/CodeForceR594/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-Round#594 | <a href="http://codeforces.com/contest/1248" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="A-Integer-Points"><a href="#A-Integer-Points" class="headerlink" title="A. Integer Points"></a>A. Integer Points</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>DLS和JLS在二维坐标系中画一次函数，想知道DLS和JLS画出的所有交点中有几个是整数点($x,y$都是整数的点)？<br>DLS的函数是 $y = x+pi$，JLS的函数是 $y = -x+pi$</p>
<p><strong>输入</strong></p>
<p>$n$ 组案例，$n$个DLS的$pi$，DLS的$pi$，n个JLS的$pi$，JSL的$pi$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于要求是整数$ x + Dpi = -x + Jpj \Rightarrow 0 = (Dpi+Jpj) \pmod{2}$<br>所以Dpi和Jpj只能同奇或同偶。</p>
<h2 id="B-Grow-The-Tree"><a href="#B-Grow-The-Tree" class="headerlink" title="B. Grow The Tree"></a>B. Grow The Tree</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你n根棍子和每根棍子的长度，让你将棍子两头连接(连接角度固定为90)，问如何连接能让两端距离最远？</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><script type="math/tex; mode=display">
\begin{aligned}
        &x + y = t \\
        &x^2 + y ^2 = t^2 - 2xy \\
\end{aligned}</script><p>因为要尽量让$x*y$相乘尽量小，所以，只要最大化一个边就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,size;</span><br><span class="line">    ll sum1 = <span class="number">0</span>,sum2 = <span class="number">0</span>,sum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,arr+i);</span><br><span class="line">    size = n/<span class="number">2</span>;</span><br><span class="line">    sort(arr,arr+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) sum1 += arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size; i&lt;n; i++) sum2 += arr[i];</span><br><span class="line">    sum = sum1*sum1 + sum2*sum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Ivan-the-Fool-and-the-Probability-Theory"><a href="#C-Ivan-the-Fool-and-the-Probability-Theory" class="headerlink" title="C. Ivan the Fool and the Probability Theory"></a>C. Ivan the Fool and the Probability Theory</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个$n*m$的格子，再上面进行黑白染色，但是遵守以下原则:</p>
<ul>
<li>不出现相邻的三个格子颜色相同<br>求出总染色方案数并且 %1e9+7 输出</li>
</ul>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先我们知道:</p>
<ul>
<li>假设这一行有格子连续，下一行必定会隔开摆放。</li>
<li>没有相邻染色的情况只有两种。</li>
</ul>
<p>我们先考虑第一行:</p>
<ul>
<li>假设第一行有两个连续的，那么之后格子摆放就确定了。此时每一列必定是黑白黑….，或者白黑白…这样</li>
<li>假设第一行是间隔的，那么我们把这个旋转90度以后，这就是上面一种情况。</li>
</ul>
<blockquote>
<p>$F_m$ 第一行的方案数，$F_n$代表第一列的方案数</p>
</blockquote>
<p>这样就发现了所有总方案数为$F_m + F_n - 2$ 这边的2是重复考虑相邻染色的情况，所以要剪去。</p>
<p>而$F_{i}$的方案数为$F_{i-1}$加上一个与结尾颜色不同的格子和上上行$F_{i-2}$加上两个颜色相同但是和结尾颜色不同的格子。</p>
<p>所以算一层所有方案数的公式为 $F_{m} = F_{m-1} + F_{m-2}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">100</span>,MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span>,dp[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=max(n,m); i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        dp[i] %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (dp[n] + dp[m] - <span class="number">2</span>)%MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D1-The-World-Is-Just-a-Programming-Task-Easy-Version"><a href="#D1-The-World-Is-Just-a-Programming-Task-Easy-Version" class="headerlink" title="D1. The World Is Just a Programming Task (Easy Version)"></a>D1. The World Is Just a Programming Task (Easy Version)</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个长度为$n$的字符串$s$字符串中只包含 ‘(‘ 和 ‘)’ ，可以循环移动字符串。<br>交换两个字符使得最后的合法字符串个数最大。</p>
<p>例子: </p>
<p>假设$s$=”) ( ( ) ( ( ) ( ) ) ( )”，交换<strong>第5个</strong>和<strong>第8个</strong> $s$ = “ ) ( ( ) ) ( ) ( ) ( ( )” 循环移动后$s$ = “( ( ) ) ( ) ( ) ( ( ) )” </p>
<p>因此合法字符串分别为”( ( ) )”，”( )”, “( )”，”( ( ) )” 四个。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>易知:</strong> 如果’(‘和’)’<strong>数量相等</strong>,通过循环移动，必定成为<strong>合法字符串</strong>，<strong>不相等</strong>则肯定不<strong>存在</strong>。</p>
<blockquote>
<p>我们将’(‘看为1，’)’看为-1对数组求前缀和。</p>
</blockquote>
<p><strong>这边有个暴力判断的关键:</strong> 就是合法字符串的个数与前缀数组中最小值的出现次数相等。</p>
<p>原因:<br>假设括号一开始就是合法字符串的那么，合法字符串的个数就是前缀和中<strong>0</strong>出现个数,<strong>0</strong>一定是前缀和中的最小值。<br>由于现在的$s$是合法字符串透过平移得到的，平移操作等于对前缀合整体加，或者减，那么前缀和中最小值的必定就是原来的0，其个数也就等于合法字符串的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %s"</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,oi=<span class="number">1</span>,oj=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            swap(str[i],str[j]);</span><br><span class="line">            <span class="keyword">int</span> st = <span class="number">0</span>, c = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">                str[k]==<span class="string">'('</span>? st++ : st-- ;</span><br><span class="line">                <span class="keyword">if</span>(st == now) c++;</span><br><span class="line">                <span class="keyword">if</span>(st &lt; now) c=<span class="number">1</span>,now = st;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!st&amp;&amp;c&gt;res) res=c,oi=i,oj=j;</span><br><span class="line">            swap(str[i],str[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d %d"</span>,res,oi,oj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>其他树学习笔记-字典树</title>
    <url>/2019/10/22/TIRETREE/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字典树是一颗<strong>多叉树</strong>，树上的每一条路径代表一个字符串。</p>
<p>用字符串 “shed”,”she”,”say”,”her”,”is” , 建立字典树。如下图</p>
<a id="more"></a>
<p><img src="/img/Trie1.png" alt="Trie"></p>
<p>我们用 <strong>trie[ u , c ]</strong> 来代表当前节点 <strong>u</strong> 加上字符 c 以后指向的下一个节点，如果没有指向则认为这个节点是结尾</p>
<blockquote>
<p>P.s c的取值与字符集有关。</p>
</blockquote>
<p>我们将字符的结尾打上标记，用于不同需求的查找。</p>
<p>我们一般用字典树来进行<strong>查找字符串</strong>操作。</p>
<h2 id="字典树模板"><a href="#字典树模板" class="headerlink" title="字典树模板"></a>字典树模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NodeSize = <span class="number">1e4</span>+<span class="number">100</span>; <span class="comment">//节点数量范围</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TRIETREE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nxt[NodeSize][<span class="number">26</span>]; <span class="comment">//这边默认是 a-z 的字典树</span></span><br><span class="line">  <span class="keyword">int</span> exits[NodeSize],cnt;</span><br><span class="line">  TRIETREE() &#123;cnt = <span class="number">0</span>; <span class="comment">/*&amp;&amp; init nxt &amp;&amp; exits*/</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insertStr</span><span class="params">(<span class="built_in">string</span> in,<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = <span class="number">0</span>,nc; <span class="comment">//init np = root</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">      nc = in[i]- <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span>(!nxt[np][nc]) nxt[np][nc] = ++cnt; <span class="comment">//代表tire[np,nc] 存在且位于cnt这个节点</span></span><br><span class="line">      np = nxt[np][nc];</span><br><span class="line">    &#125;</span><br><span class="line">    exits[cnt]++; <span class="comment">//代表有n个以之结尾的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">findStr</span><span class="params">(<span class="built_in">string</span> in,<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = <span class="number">0</span>,nc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">      nc = in[i]-<span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span>(!nxt[np][nc]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//没有就是不存在</span></span><br><span class="line">      np = nxt[np][nc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exits[np];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h2><p><a href="https://oi-wiki.org/string/trie/" target="_blank" rel="noopener">字典树-OI-WIKI</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>Datastructures</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Java快速上手-基础篇</title>
    <url>/2019/10/21/FireJAVA/</url>
    <content><![CDATA[<p>本文是一篇<strong>Java快速上手</strong>教程，短时间从cpp语法转到Java语法，并进行程序的编写。</p>
<blockquote>
<p>P.s. 未写类名字的默认放在主类的main函数中，所需要的库都加上了</p>
</blockquote>
<a id="more"></a>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>建立一个文件<strong>HelloWorld.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意这边的HelloWord必须和文件名一致</span></span><br><span class="line"><span class="comment">//并且只能包含一个public class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这个是必写，类似cpp里面的int main(),不过语法更加严格</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HelloWorld.java所在目录下使用以下两个命令</p>
<blockquote>
<p><strong>javac</strong> HelloWorld.java<br>#生成字节码文件<br><strong>java</strong> HelloWorld<br>#在JVM (java虚拟机) 里面解释运行<strong>上一步</strong>生成的字节码文件</p>
</blockquote>
<h2 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>在Java中我们用<strong>Scanner类</strong>来进行<strong>输入</strong>，以输入数字a为例，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   cpp 中:</span></span><br><span class="line"><span class="comment">   int a = 0;</span></span><br><span class="line"><span class="comment">   cin &gt;&gt; a;</span></span><br><span class="line"><span class="comment">   等效于下面。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">a = in.nextInt();</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="comment">//cout &lt;&lt; a;</span></span><br><span class="line">System.out.print(a);</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="字节型"><a href="#字节型" class="headerlink" title="字节型"></a>字节型</h3><p><strong>byte型</strong>占<strong>1</strong>个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> a;</span><br></pre></td></tr></table></figure>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符用的是Unicode编码，所以<strong>1个字符</strong>占<strong>2个字节</strong>。</p>
<h3 id="布尔型的定义"><a href="#布尔型的定义" class="headerlink" title="布尔型的定义"></a>布尔型的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in cpp: bool a;</span></span><br><span class="line"><span class="keyword">boolean</span> a;</span><br></pre></td></tr></table></figure>
<h3 id="浮点数判断"><a href="#浮点数判断" class="headerlink" title="浮点数判断"></a>浮点数判断</h3><p>需要用到Java中的<strong>Math</strong>类，这边只给出<strong>相等判断</strong>，其他类似。</p>
<p>假定$a$,$b$数据类型都是double</p>
<ul>
<li>如果两者相等 —&gt; Math.abs(a-b) &lt; 1e-6</li>
</ul>
<p>其他与cpp中相同。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Tips: 调用后面的函数可以不用在前面声明，其他相同。</p>
<h3 id="顺序结构-amp-amp-判断结构"><a href="#顺序结构-amp-amp-判断结构" class="headerlink" title="顺序结构&amp;&amp;判断结构"></a>顺序结构&amp;&amp;判断结构</h3><p>判断结构语法与cpp一致。</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p><strong>break</strong>和<strong>continue</strong>可以加标签。作用类似cpp的goto语句，详细可以查看Java的API文档作，为坚定的$Dijkstra$崇拜者，不建议使用标签。</p>
<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>在本文中只介绍基本数据类型的数组。</p>
</blockquote>
<p>数组的定义与使用以int为例子</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h4><p>在Java中数组的本质已经改变，与cpp不同。<br>如果说在cpp中数组是一排邻挨的柜子，那么Java将相邻的柜子遮盖起来，而用一位管理员去管理这些柜子。<br>因此理所当然，如果管理员a知道了管理员b的管理的柜子的位置，那么他也就能操作管理员b管理的柜子。</p>
<p>可以通过这份代码来加深理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//管理的柜子不同</span></span><br><span class="line">System.out.println(<span class="string">"Is a equal to b?\nres---&gt; "</span> + (a==b));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"now a[2] = ?\nres---&gt; "</span> + a[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//b[1] 知道 a[2] 管理的柜子以后，去更改a[2]管理的柜子的值</span></span><br><span class="line">b = a;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">13</span>;</span><br><span class="line">System.out.println(<span class="string">"after  b[1] = a[2]; now a[2] = ?\nres---&gt; "</span> + a[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>代码获取地址 | <a href="https://github.com/Mirasire/icpc-train/blob/master/pic/Blog/LearnArr1.java" target="_blank" rel="noopener">CodeLink</a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//in cpp: int a[12];</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//in cpp: int a[12][12];</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//错误定义 int[3] a = &#123;1,2,3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in cpp: int a[12][12];</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//错误定义 int[][] a = new int[][12];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//和cpp中不同的定义，实现每一维的长度可以不等</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++) &#123;</span><br><span class="line">	a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Java数组由一个变量$length$来记录数组的长度。</p>
<blockquote>
<p>听起来蛮像原来cpp里面的length，实际上差不多是一个意思。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">131</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   in cpp;</span></span><br><span class="line"><span class="comment">   for(int num: a) cout &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</span><br><span class="line">	System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Java提供的字符串定义的时候<strong>String首字母要大写</strong>(p.s. 意思是<strong>S</strong>tring的首字母，不是变量的)，说明了String是一个类，详细见Java命名规范。</p>
<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><p>在Java中字符串实质也发生了改变，与cpp不同。</p>
<p>Java中的字符串定义更像是一种引用，字符串本身被隐藏。并且规定被隐藏的字符串无法被更改。<br><del>这边和数组很像哦!!那就是换了引用对象，怪不得Java好慢…</del></p>
<p>详见代码 | <a href="https://github.com/Mirasire/icpc-train/blob/master/pic/Blog/TestString.java" target="_blank" rel="noopener">Here</a></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="comment">//int cpp: string haha;</span></span><br><span class="line">String haha; <span class="comment">//此时为null而不是"\0"</span></span><br><span class="line">String haha = <span class="string">"abc"</span>; <span class="comment">//此时为null而不是"\0"</span></span><br><span class="line">String haha = <span class="keyword">new</span> String(<span class="comment">/*数组名: */</span>str);</span><br><span class="line">String haha = <span class="keyword">new</span> String(<span class="comment">/*数组名: */</span>str,<span class="comment">/*长度: */</span><span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>取消了用 <strong>[ ]</strong> 来取得字符串内元素的操作，改为提供charAt方法。</p>
<p>$str1$和$str2$都是已知字符串。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">str1.length()</td>
<td style="text-align:center">取得$str1$长度</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">str1.equals(str2)</td>
<td style="text-align:center">判断$str1$和$str2$是否相等</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">str1.equalsIgnoreCase(str2)</td>
<td style="text-align:center">同上忽略大小写判断</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">str1.compareTo(str2)</td>
<td style="text-align:center">判断$str1$和$str2$是否相等</td>
<td style="text-align:center">int(&gt; +,&lt; -,== 0)</td>
</tr>
<tr>
<td style="text-align:center">Integer.parseInt(str1)</td>
<td style="text-align:center">将str1转化为整型</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">Integer.parseFloat(str1)</td>
<td style="text-align:center">将str1转化为整型</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">str1.getBytes()</td>
<td style="text-align:center">将一个字符串转化为字节数组</td>
<td style="text-align:center">byte []</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数-amp-amp-生存期"><a href="#函数-amp-amp-生存期" class="headerlink" title="函数&amp;&amp;生存期"></a>函数&amp;&amp;生存期</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>由于是类中的写法，所以前面要加限定符。<br>这边有个<strong>重点:</strong> <strong><em>基本数据</em></strong>只能<strong>值传递</strong>(call by value)。</p>
<h3 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h3><p>基本与cpp一致</p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Programming Language</tag>
        <tag>Java</tag>
        <tag>快速上手</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3436 ACM Computer Factory</title>
    <url>/2019/10/21/POJ3436/</url>
    <content><![CDATA[<p>这题写了两天半，实在是惭愧的要命…，最后是套用紫书的板子过的，<del>我到现在都不知道我写的板子哪里出锅TLE了，极度委屈QWQ</del>，不过变成绿色的那一刻真的好爽，好爽啊啊啊啊啊!</p>
<blockquote>
<p>题目链接 | <a href="http://poj.org/problem?id=3436" target="_blank" rel="noopener">ACM Computer Factory</a></p>
</blockquote>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有工厂要生产一种电脑，这种电脑需要$P$个零件，这个工厂有$N$个流水线。$N$个流水线相互协作。</p>
<p>每条生产线有三个参数<code>单位时间产能</code>，<code>需要的零件</code>，<code>处理后电脑有的零件</code>，这边</p>
<ul>
<li>单位时间产能 —&gt; 每小时可以加工的零件数量</li>
<li>需要的零件 —&gt; 需要的零件情况，用给出$p$个数来表示，数字只有<strong>0</strong>,<strong>1</strong>,<strong>2</strong>，第$k$位表示第$k$个零件时候需要<ul>
<li>1 —&gt; 需要零件</li>
<li>0 —&gt; 严格不需要零件 （这表示你在0处投入零件，生产线也不会启动）</li>
<li>2 —&gt; 无所谓</li>
</ul>
</li>
<li>单位时间产能 —&gt; 每小时可以加工的零件数量，用给出$p$个数来表示，数字只有<strong>0</strong>,<strong>1</strong>，第$k$位表示第$k$和零件是否被产出。<ul>
<li>1 —&gt; 零件被产出</li>
<li>0 —&gt; 零件没被产出</li>
</ul>
</li>
</ul>
<p><strong>问</strong>，该如何分配协作的流水线？使得单位时间产能最大。</p>
<blockquote>
<p><strong>输入</strong></p>
</blockquote>
<p>多组输入，每组输入</p>
<p>$N$,$P$，然后就是每个流水线的三个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">15  0 0 0  0 1 0</span><br><span class="line">10  0 0 0  0 1 1</span><br><span class="line">30  0 1 2  1 1 1</span><br><span class="line">3   0 2 1  1 1 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>输出</strong></p>
</blockquote>
<p>输出<strong>一种</strong>满足最大效率的分配即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25 2</span><br><span class="line">1 3 15</span><br><span class="line">2 3 10</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>!!这题注意是多组输入</strong></p>
<p>这题是一个很经典的建图模型，由于这个是 <strong>工厂流水线模型</strong>，而且又限制是对 <strong>点的限制</strong>。<br>那我们肯定是先 <strong>拆点</strong>，然后添加一个<strong>超级源点$s$</strong> 和一个 <strong>超级汇点$t$</strong> 来进行建图。</p>
<p>这样就有以下几个 <strong>显然</strong> 的结论</p>
<ul>
<li>连在$s$上的每个需求零件必须是0或2</li>
<li>连在$t$上的每个生产出的零件必须是1</li>
<li>满足流水线$a$的输出能作为流水线$b$,可以建边${\langle}a,b{\rangle}$</li>
<li>除了拆点的边有容量限制,其他的边容量均为$INF$</li>
</ul>
<p>依靠上面几个性质我们建图跑一个$Dinic$就好了。<br>至于<strong>路径输出</strong>我们只要遍历一遍图，如果路上有流量就可以算流水线协作，当然反向边还有一些杂七杂八的边不算……</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><blockquote>
<p>这里用的是紫书的模板，我写的那个好像出问题了，挠头.jpg</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">70</span>*<span class="number">70</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">90</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">90</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> out[<span class="number">90</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> res[maxn][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,n;</span><br><span class="line">    Dinic dinic;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;n)) &#123;</span><br><span class="line">        dinic.init(n*<span class="number">2</span>+<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;p; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;p; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;out[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//============建图============</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, t=n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;p; j++)</span><br><span class="line">                <span class="keyword">if</span>(in[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) dinic.AddEdge(s,i,INF);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//============拆点============</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dinic.AddEdge(i,i+n,val[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;p; k++)</span><br><span class="line">                    <span class="keyword">if</span>(out[i][k] != in[j][k] &amp;&amp; in[j][k] != <span class="number">2</span>) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) dinic.AddEdge(i+n,j,INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;p; j++)</span><br><span class="line">                <span class="keyword">if</span>(out[i][j]!=<span class="number">1</span>) &#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) dinic.AddEdge(i+n,t,INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//============建图END============</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//============跑Dinic求最大流============</span></span><br><span class="line">        <span class="keyword">int</span> mff = dinic.Maxflow(s,t);</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//============寻找路径============</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;t; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = dinic.G[i].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;end; j++) &#123;</span><br><span class="line">                Edge e = dinic.edges[dinic.G[i][j]];</span><br><span class="line">                <span class="keyword">if</span>(e.cap &amp;&amp; e.flow &gt; <span class="number">0</span> &amp;&amp; e.to &lt;=n ) &#123;</span><br><span class="line">                    res[tt][<span class="number">2</span>] = e.flow;</span><br><span class="line">                    res[tt][<span class="number">0</span>] = i-n;</span><br><span class="line">                    res[tt++][<span class="number">1</span>] = e.to;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mff,tt);</span><br><span class="line">        <span class="comment">//============路径输出============</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tt; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,res[i][<span class="number">0</span>],res[i][<span class="number">1</span>],res[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>拆点</tag>
        <tag>POJ</tag>
        <tag>路径输出</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记-最大流</title>
    <url>/2019/10/20/MAXFLOW/</url>
    <content><![CDATA[<p><strong>最大流问题</strong>是求在一张网络中从源点 <strong>$s$</strong> 出发到汇点 <strong>$t$</strong> 的最大流量。(不一定非要单路径)</p>
<blockquote>
<p>模板题地址 | <a href="https://www.luogu.org/problem/P3376" target="_blank" rel="noopener"><strong>Here</strong></a><br>最大流模板 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Template</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="FF算法"><a href="#FF算法" class="headerlink" title="FF算法"></a>FF算法</h2><p>我们先给出一张网络每个边上的数字表示<strong>流量/容量</strong></p>
<p><img src="/img/MF1.png" alt="MF1"></p>
<p>首先我们考虑一个<strong>错误操作</strong>，错误操作是<strong>寻找增广路</strong>,<strong>存在</strong>就<strong>进行增广</strong>。</p>
<p>假设我们在这张图上找到的<strong>增广路</strong>为 <strong>$s-&gt;1-&gt;2-&gt;t$</strong>，然后对<strong>找到的增广路</strong>并且进行<strong>增广</strong>，那么会变成下图</p>
<p><img src="/img/MF2.png" alt="MF2"></p>
<p>之后我们发现再也找不到增广路，这样子我们得出<strong>伪-最大流</strong>为<strong>1</strong>,显然这是<strong>不对</strong>的，这张图的<strong>最大流应该是2</strong>。</p>
<p>于是我们将原来的图中的每一条边<strong>添加一条反向边</strong>，因为建立反向边以后，代表你的程序可以<strong>反悔</strong>，也就是新找到的增广路径<strong>经过反向边</strong>来达到<strong>退流</strong>的目的。</p>
<blockquote>
<p><strong>$s-&gt;1$</strong> 添加反向边类似如下图</p>
<p><img src="/img/MF3_2.png" alt="MF3"></p>
</blockquote>
<p>这样一来我们原来<strong>错误操作</strong>就变成<strong>正确的了</strong>,这就是<strong>Ford-Fulkerson 增广路算法</strong></p>
<h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p><strong>EK</strong>算法的想法是用<strong>BFS</strong>寻找增光路，并进行增流。这边有两个关键的问题</p>
<ul>
<li>如何寻找增广路 ?</li>
<li>如何进行增广 ?</li>
</ul>
<p>解决办法就是用<strong>BFS</strong>一直寻找，假设有向边 $e_i = {\langle u,v \rangle}$ 可增广，就记录点 <strong>$v$</strong> 前面的节点为 <strong>$u$</strong> 并且记录<strong>最大残量</strong>，直到遇到 <strong>$源点t$</strong> 或者<strong>最大可增广为0</strong>，退出<strong>BFS</strong>,判断下 <strong>$源点t$</strong> 有没有前面的节点，为了方便姑且叫他 <strong>$pre[t]$</strong>。</p>
<blockquote>
<p>这边我们可以用一个 <strong>$pre[v] = u$</strong>，来记录前面的节点<br>最大残量是 = min(最大残量，目前残量)</p>
</blockquote>
<ul>
<li><p><strong>$pre[t]存在$</strong></p>
<ul>
<li>使用 <strong>$per$数组</strong>和得到的<strong>最大残余流量</strong>进行增广</li>
</ul>
</li>
<li><p>不存在 </p>
<ul>
<li>代表已经完成得到最大流，<strong>退出返回最大流</strong></li>
</ul>
</li>
</ul>
<p>EK算法的时间复杂度是$O(nm^2)$  (n是点数，m是边数) <code>TLE的罪魁祸首</code></p>
<h3 id="EK模板"><a href="#EK模板" class="headerlink" title="EK模板"></a>EK模板</h3><blockquote>
<p>模板来自紫书和OI-WIKI，存图使用邻接表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 250</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">  Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EK</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">  <span class="keyword">int</span> a[maxn];</span><br><span class="line">  <span class="keyword">int</span> p[maxn];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">    edges.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    m = edges.size();</span><br><span class="line">    G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">      <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">      Q.push(s);</span><br><span class="line">      a[s] = INF;</span><br><span class="line">      <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">          Edge&amp; e = edges[G[x][i]];</span><br><span class="line">          <span class="keyword">if</span> (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">            p[e.to] = G[x][i];</span><br><span class="line">            a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">            Q.push(e.to);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[t]) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!a[t]) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">        edges[p[u]].flow += a[t];</span><br><span class="line">        edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">      &#125;</span><br><span class="line">      flow += a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>EK算法的<strong>效率是不高的</strong>，假设我们使用<strong>EK算法</strong>来求解下图中的最大流，我们找到的增广路径是$s-&gt;1-&gt;2-&gt;t$，容易发现，这样我们会在$1-&gt;2$边上<strong>疯狂退流</strong>，这样一来就大大<strong>降低了算法的效率</strong>，所以一般选择使用<strong>Dinic算法</strong>来处理下图。</p>
<p><img src="/img/MF4.png" alt="MF4"></p>
<p>与EK算法不同，<strong>Dinic算法</strong>作出了<strong>两个优化</strong></p>
<ol>
<li>先将用<strong>BFS</strong>网络变成一个层次图，之后每次寻找的边就在<strong>相邻的层</strong>中寻找即可。</li>
<li>再用DFS<strong>在层次图上</strong>进行<strong>多路增广</strong>，这样子可以保证目前这条边的<strong>流量被最大化</strong>，在后续<strong>DFS</strong>中不用重复判断这条边，大大提高了效率。</li>
</ol>
<blockquote>
<p>我们称不用重复判断这条边这一步优化为<strong>当前弧优化</strong></p>
</blockquote>
<p><code>我们先设图的点数为n，边数为m。</code></p>
<p>Dinic算法的时间复杂度是$O(n^2m)$，如果 <strong>边数$m$</strong> 很大的话，Dinic算法的效率就比EK算法高很多。</p>
<blockquote>
<p>P.s. 在求二分图最大匹配时，可证 Dinic 算法的时间复杂度是 $O(m{\sqrt{n}})$</p>
</blockquote>
<h3 id="Dinic模板"><a href="#Dinic模板" class="headerlink" title="Dinic模板"></a>Dinic模板</h3><blockquote>
<p>模板来自紫书和OI-WIKI，存图使用邻接表</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += DFS(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://oi-wiki.org/graph/flow/max-flow/#edmond-karp-ek" target="_blank" rel="noopener"><strong>OIWiki-最大流</strong></a><br><strong>《挑战程序设计竞赛（第二版）》- (白书)</strong><br><strong>《算法竞赛（第二版）》-刘汝佳 (紫书)</strong><br><strong>《算法竞赛入门训练-训练指南》</strong></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>最大流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记-基础介绍</title>
    <url>/2019/10/20/NETFLOWBASIC/</url>
    <content><![CDATA[<p>关于网络流基本术语，和一些前置知识的介绍</p>
<a id="more"></a>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络 指一个有向图 <strong>G = &lt; V , E &gt;</strong> </p>
<blockquote>
<p>其中 V 为点集， E 为边集</p>
</blockquote>
<p>有向图中的每条边包含一个值，代表能流过这条边的最大<strong>流量</strong> (flow) 。这个值 称为 <strong>容量</strong>(capacity) </p>
<blockquote>
<p>没有边的两点的容量 为 0</p>
</blockquote>
<p>网络 和 普通的有向图不同的点是网络包含两个特殊的点，<strong>源点s</strong> 简称 <strong>源s</strong> 和<strong>汇点t</strong> 简称 <strong>汇t</strong></p>
<blockquote>
<p>源点，汇点都在网络的点集中</p>
</blockquote>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>详情见 <a href="https://oi-wiki.org/graph/flow/#_1" target="_blank" rel="noopener">OI-WIKI</a></p>
<h2 id="残留网络"><a href="#残留网络" class="headerlink" title="残留网络"></a>残留网络</h2><p>定义一条边 <strong>&lt; u , v &gt;</strong> 的<strong>残留容量</strong> cf(u,v) = <strong>c(u,v) - f(u,v)</strong></p>
<p>由该网络中的<strong>残留容量</strong>构成的<strong>网络</strong>称为<strong>残留网络</strong></p>
<h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p>在 <strong>残留网络</strong>中 <strong>源s</strong> 到 <strong>汇t</strong> 的路径，并且路径上所有边的的<strong>容量 - 流量</strong> 都 <strong>大于0</strong> 。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>胡伯涛 —《最小割模型在信息学中的应用》</p>
<p><a href="https://oi-wiki.org/graph/flow/#_1" target="_blank" rel="noopener">网络流简介-OIWIKI</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>网络流基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-EducationRound#74 题解报告</title>
    <url>/2019/10/20/CodeForceER74/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-EducationalRound#74 | <a href="https://codeforces.com/contest/1238" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h1 id="A-Prime-Subtraction"><a href="#A-Prime-Subtraction" class="headerlink" title="A. Prime Subtraction"></a>A. <a href="https://codeforces.com/contest/1238/problem/A" target="_blank" rel="noopener">Prime Subtraction</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出数字 <strong>x</strong> 和 <strong>y</strong> ，问 <strong>y</strong> 是否能由 <strong>x</strong> 减去 2，3，4，5，7，11 组成，若是则输出<strong>YES</strong>，否则输出<strong>NO</strong></p>
<!--more-->
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>容易证明这几个数字能组合出，<strong>除了1</strong> 以外的所有数字，换言之只要</p>
<ul>
<li>两者相差 &gt; 1 就输出 YES</li>
<li>否则 就输出 NO</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n,x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span>(x-y &gt; <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Kill-Em-All"><a href="#B-Kill-Em-All" class="headerlink" title="B. Kill Em All"></a>B. <a href="https://codeforces.com/contest/1238/problem/B" target="_blank" rel="noopener">Kill Em All</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>事情发生在一个一维的直线上，一开始有 n 个怪物在坐标轴左侧坐标分别为 X1-Xn (Xi &gt; 0) ，你有个技能k，你可以选择这个 K 释放的位置 <strong>c</strong>，怪物受到的影响有如下规则</p>
<ul>
<li>如果 Xi == c ，怪物死亡</li>
<li>如果 Xi &gt; c ，怪物坐标变为 Xi + c</li>
<li>如果 Xi &lt; c ，怪物坐标变为 Xi - c</li>
</ul>
<p>如果怪物坐标变化为Xi (Xi &lt;= 0) 则会触发地形杀，导致死亡</p>
<p><strong>问</strong> 最少的施法次数是几次。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>最要贪心从最左边开始爆炸就好了，由于输入的为未排序，那就排序后进行模拟即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn],n,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q,size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,x+i);</span><br><span class="line">        sort(x,x+n);</span><br><span class="line">        size = unique(x,x+n) - x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=size<span class="number">-1</span>; j&gt;=<span class="number">0</span>; )&#123;</span><br><span class="line">            <span class="keyword">while</span>(x[j]-cnt*r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">-1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Standard-Free2play"><a href="#C-Standard-Free2play" class="headerlink" title="C. Standard Free2play"></a>C. <a href="https://codeforces.com/contest/1238/problem/C" target="_blank" rel="noopener">Standard Free2play</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>山的高度是<strong>h</strong> ，有高度为 <strong>1</strong>，<strong>2</strong>，<strong>3</strong>，……，<strong>h</strong> 的移动平台在山上 (默认未移出)。初始位置在平台<strong>h</strong>上，目的是下降到<strong>0</strong>位置。</p>
<p>一开始会将 <strong>n</strong> 个平台移出，高度分别为 p1，p2，p3，…，pn。</p>
<p>每个平台有一个按钮，按下按钮，当前平台 ( x ) 会缩回，下面的平台 ( x-2 ) 会改变状态，即缩回的会被推出，原来推出的会被缩回去。</p>
<p>你只能最多从当前平台 ( x ) 坠落到 <strong>x - 2</strong> 以内的平台，不然你会死亡。</p>
<p>幸运的是你可以买一些魔法石，使用一个魔法石可以改变任何一个平台的状态。每颗魔法石只能使用一次。</p>
<p><strong>问</strong>: <strong>最少</strong>需要购买多少魔法石。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>默认目前所站在p[x]+1上<br>只要判断是否 p[x] 和 p[x+1] 是否相邻，如果是就直接到 p[x]上否则 就使用一个魔法石到 p[x+1]+1上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,i;</span><br><span class="line">    <span class="keyword">int</span> n,h,ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;h,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">        p[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==p[i+<span class="number">1</span>]+<span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-AB-string"><a href="#D-AB-string" class="headerlink" title="D. AB-string"></a>D. <a href="https://codeforces.com/contest/1238/problem/D" target="_blank" rel="noopener">AB-string</a></h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>一个字符串仅由 A 和 B 构成，定义一个字符串为好的串，如果字符串的每一个字母在字符串中都有回文子串，问给出的字符串有多少个好的子串。</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>由于只有A，B构成，易知长度 &gt;1的子串个数为 <strong>(n-1)*n/2</strong> ，（ n为字符串长度 ）只要排除类似ABBBB，BAAA，BBBBA，AAAAB，这种类型的子串即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> MAXSIZE = <span class="number">3e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> str[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'B'</span>) sub++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'B'</span>) sub++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'A'</span>) sub++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[j]==<span class="string">'A'</span>) sub++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) </span><br><span class="line">        <span class="keyword">if</span>(str[i] != str[i<span class="number">-1</span>]) sub--; <span class="comment">//...BA..，.......AB.....</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,n*(n<span class="number">-1</span>)/<span class="number">2</span> - sub);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Rated for Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#588 题解报告</title>
    <url>/2019/10/20/CodeForceR588/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-Round#588 | <a href="https://codeforces.com/contest/1230" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="A-Dawid-and-Bags-of-Candies"><a href="#A-Dawid-and-Bags-of-Candies" class="headerlink" title="A. Dawid and Bags of Candies"></a>A. Dawid and Bags of Candies</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有<strong>四个背包</strong>，是否能分成<strong>等质量</strong>的<strong>两堆</strong>，背包不能丢弃。</p>
<!--more-->
<p><strong>输入：</strong> a1，a2，a3，a4<br><strong>输出：</strong> YES，NO</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>从大到小 <strong>排序</strong>判断 <strong>a1+a4 == a2+a3</strong> 或者 <strong>a1+a2+a3 == a4</strong> 是就输出 <strong>YES</strong>，否则就输出<strong>NO</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">3</span>];</span><br><span class="line">    sort(a,a+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]+a[<span class="number">3</span>] == a[<span class="number">1</span>] + a[<span class="number">2</span>]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">3</span>] == a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>])  <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Ania-and-Minimizing"><a href="#B-Ania-and-Minimizing" class="headerlink" title="B. Ania and Minimizing"></a>B. Ania and Minimizing</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你一串数字，并且给你更改的<strong>次数</strong>，每次只能更改<strong>一个数字</strong>并且不能改变<strong>位数</strong>（即如果多个数字前面第一位不能为0），要求输出改完后最小的数字。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>显然如果是 <strong>一位数字</strong> 就改成 <strong>0</strong>，其他情况就改称 <strong>100….</strong> 这样的类型，这边注意如果与目标要改的一样，可以跳过这个字符，节省次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; str;</span><br><span class="line">    k = min(n,k);</span><br><span class="line">    <span class="keyword">if</span>(n==k &amp;&amp; k==<span class="number">1</span>) <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n&amp;&amp;k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">                <span class="keyword">if</span>(str[i] != <span class="string">'1'</span>) k--;  <span class="comment">//相等状况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(str[i] != <span class="string">'0'</span>) k--;  <span class="comment">//同上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Anadi-and-Domino"><a href="#C-Anadi-and-Domino" class="headerlink" title="C. Anadi and Domino"></a>C. Anadi and Domino</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p><a href="https://codeforces.com/contest/1230/problem/C" target="_blank" rel="noopener">题目连接</a></p>
<p>给出一个无向图，没有自环，<strong>点集</strong>大小是<strong>( 1 - 7 )</strong>，Anadi 有一套多米诺骨牌，牌数是<strong>21</strong>张。牌子由两部分组成，每个部分由点数组成 ( 详情请看题目连接 ) 。</p>
<p>每个牌子可以用来表示一条边，但是注意 每个指向<strong>同一节点</strong>的多米诺骨牌的点数需要<strong>相等</strong>，问<strong>最多</strong>可以放入多少块多米诺骨牌。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>我们可以很轻松的分析出，如果<strong>节点个数小于6</strong>，那一定是可以放满的。那么问题就变成了，当<strong>节点个数为7</strong>的我们该怎么放置骨牌。</p>
<p>容易发现在<strong>节点个数为7</strong>的时候我们<strong>一定</strong>会对一个节点<strong>使用</strong>多米诺骨牌中左右两边<strong>一样的牌</strong>。如果两个点的节点数字一样同时这两个点连接在同一条边上，那么这两条边中必定有<strong>一条边无法放置</strong>多米诺骨牌。</p>
<p>那么只要找出<strong>最少的</strong>重复边，然后用<strong>输入边数减去它</strong>就是最大能够摆放的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,tmp1,tmp2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;tmp1,&amp;tmp2);</span><br><span class="line">        mp[tmp1][tmp2] = mp[tmp2][tmp1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">56</span>; <span class="comment">//因为最大的最小重复边为6，所以初始化为56</span></span><br><span class="line">    <span class="comment">//寻找最小重复边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=<span class="number">7</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">7</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][k]&amp;&amp;mp[j][k]) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = min(res,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出答案</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,m-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Marcin-and-Training-Camp"><a href="#D-Marcin-and-Training-Camp" class="headerlink" title="D. Marcin and Training Camp"></a>D. Marcin and Training Camp</h2><blockquote>
<p>看不起可能翻译的不大好，就是b决定比a棒棒的意思。</p>
</blockquote>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>想要选一堆人 ( 人数 &gt;= 2 ) 来相互合作，每个人会多种技能，技能<strong>总数</strong>为<strong>60种</strong>技能 （ 编号从 0 - 59 ），每个人有个参数 <strong>a</strong> 和 <strong>b</strong></p>
<ul>
<li><strong>a</strong> 表示那个人所会的技能，假设会编号为 j 的技能，那么 <strong>a</strong> 的二进制的第 j 位就为 1 ，不然为0</li>
<li><strong>b</strong>表示那个人的技能等级</li>
</ul>
<p>假设a有个技能b不会，那么a看不起b。选一堆人的要求是 没有一个人能看不起所有人。</p>
<p><strong>输入：</strong> n ，n 个 ai，n 个 bi<br><strong>输出：</strong> 最大的技能等级和</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>易知</strong>重复出现的肯定可以选择。之后就是选择<strong>重复出现的看不起的</strong>并且不能相互看不起。</p>
<p>这边判断<strong>j</strong>是否看不起<strong>i</strong>有个小技巧<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( a[i] &lt; a[j] &amp;&amp; (a[i] | a[j]) == a[j]) a[j] 看不起 a[i]</span><br><span class="line"><span class="keyword">else</span> 互相看不起 或者 a[i] 看不起 a[j]</span><br></pre></td></tr></table></figure><br><del>这样就变成一道大水题</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt; cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">7100</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a,b,ans;</span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">        cnt[tmp]++;</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">        b.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(cnt[a[i]] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            ans.push_back(a[i]);</span><br><span class="line">            res+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = ans.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;end; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &lt; ans[j] &amp;&amp; (a[i] | ans[j]) == ans[j]) &#123;</span><br><span class="line">                    ans.push_back(a[i]);</span><br><span class="line">                    res += b[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-Round#586 题解报告</title>
    <url>/2019/10/20/CodeForceR586/</url>
    <content><![CDATA[<blockquote>
<p>CodeForces-Round#588 | <a href="https://codeforces.com/contest/1220" target="_blank" rel="noopener"><strong>Here</strong></a><br>题解代码 | <a href="https://github.com/Mirasire/icpc-train" target="_blank" rel="noopener"><strong>Here</strong></a></p>
</blockquote>
<a id="more"></a>
<h2 id="A-Cards"><a href="#A-Cards" class="headerlink" title="A. Cards"></a>A. Cards</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>原来有一字符串由多个one,zero组成，可能没有one,或者zero,将字符串打乱给你，问原来的字符串是怎样的，从one开始输出。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>one 和 zero</strong> 个数，就是 <strong>n 和 z</strong> 的个数。</p>
<!--more-->
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">string</span> add1 = <span class="string">" 1"</span>,add2 = <span class="string">" 0"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//zero</span></span><br><span class="line"><span class="comment">//one</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    mp[<span class="string">'z'</span>] = <span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'e'</span>] = <span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'r'</span>] = <span class="number">3</span>;</span><br><span class="line">    mp[<span class="string">'o'</span>] = <span class="number">4</span>;</span><br><span class="line">    mp[<span class="string">'n'</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">string</span> out;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) &#123;</span><br><span class="line">        n[mp[str[i]]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n[<span class="number">5</span>]; i++) </span><br><span class="line">        <span class="keyword">if</span>(out.empty()) &#123;</span><br><span class="line">            out = <span class="string">"1"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> out += add1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n[<span class="number">1</span>]; i++) </span><br><span class="line">        <span class="keyword">if</span>(out.empty()) &#123;</span><br><span class="line">            out = <span class="string">"0"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> out += add2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; out;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Multiplication-Table"><a href="#B-Multiplication-Table" class="headerlink" title="B - Multiplication Table"></a>B - Multiplication Table</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出如下表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">M</th>
<th style="text-align:center">a1</th>
<th style="text-align:center">a2</th>
<th style="text-align:center">a3</th>
<th style="text-align:center">…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">a1&times;a2</td>
<td style="text-align:center">a1&times;a3</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">a2</td>
<td style="text-align:center">a2&times;a1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">a2&times;a3</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">a3</td>
<td style="text-align:center">a3&times;a1</td>
<td style="text-align:center">a3&times;a2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>求<strong>a1到an</strong>的数,题目保证n&gt;=3</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><script type="math/tex; mode=display">
\begin{aligned}
x_1 &= a_1 * a_2  \\
x_2 &= a_1 * a_3  \\
x_3 &= a_2 * a_3  \\

a_1 &= \sqrt{\frac {x_1 \times x_2 } {x_3}} \\


\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line">ll el[M][M];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">getSqrt</span><span class="params">(ll a,ll bsc)</span> </span>&#123;</span><br><span class="line">    ll end = bsc + <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=max(bsc<span class="number">-1000</span>,<span class="number">1l</span>l); i&lt;end; i++) </span><br><span class="line">        <span class="keyword">if</span>(i*i == a) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;el[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a = (el[<span class="number">2</span>][<span class="number">1</span>]*el[<span class="number">1</span>][<span class="number">3</span>])/el[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    ll mid = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(mid*mid != a) mid = getSqrt(a,mid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,mid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %lld"</span>,el[<span class="number">1</span>][i]/mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Substring-Game-in-the-Lesson"><a href="#C-Substring-Game-in-the-Lesson" class="headerlink" title="C - Substring Game in the Lesson"></a>C - Substring Game in the Lesson</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p><strong>Ann</strong> 和 <strong>Mike</strong> 在完游戏, 游戏规则如下:</p>
<ul>
<li>给出一段长度为s的字符串，<strong>先手</strong>是Ann。</li>
<li>当前玩家选择一串<strong>连续</strong>的字符串 (s2) ，s2<strong>包含前面</strong>的字符c且和前面的字符串(s1) <strong>不相同</strong>，并且s1 &lt; s2 (字典序) 。</li>
<li>起始字符串是第k位字符, 无法选择时当前玩家输掉。</li>
</ul>
<p>要求输出<strong>k</strong>从 <strong>0</strong> -&gt; <strong>s-1</strong> 的胜利玩家</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>思考了以下 <strong>Ann</strong> 的胜利条件，只要不开局开局爆死,即<strong>开局字符k是 0-k 中字符串最小的</strong>, 都是<strong>Ann</strong> 胜利，剩下就是Mike胜利。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> lletter[<span class="number">39</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; toFind;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> end = s.size();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> mi = s[<span class="number">0</span>];</span><br><span class="line">    toFind.insert(mi);</span><br><span class="line">    <span class="comment">//记录是否是到目前最小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; mi) &#123;</span><br><span class="line">            mi = s[i];</span><br><span class="line">            mid = i;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == mi)&#123;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Mike\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Ann\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Alex-and-Julian"><a href="#D-Alex-and-Julian" class="headerlink" title="D. Alex and Julian"></a>D. Alex and Julian</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>B是一个题目给出的集合，要求<strong>删去B</strong>的一个<strong>最小子集</strong>，使得题目要求的构成一个<strong>二分图</strong>，图的构成规则如下。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&i \And j \in V \quad(i \And j \in Z)\\
&if \quad |i-j| = b_i\quad (b_i \in B,{i}\And{j} \in Z) \quad then <i,j> \in E
\end{aligned}</script><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>如果要<strong>构成二分图</strong>，那么图内必定<strong>不存在奇环</strong>。</p>
<blockquote>
<p>奇环指的是环的边数个数之和为奇数<del>还是看他人题解明白的QWQ!!</del></p>
</blockquote>
<p>那么我们考虑如何会构成奇数环。</p>
<ol>
<li>显然，假设我们选择了k，那么k的偶数倍数我们都不能选择。</li>
<li>假设集合中有<strong>1奇1偶(odd1 &amp; even)</strong>，那么必定存在一个 k = odd*even ，由于 奇数+偶数 = 奇数，所以在目标集合中必定不存在一个奇一偶数偶数。</li>
<li>假设集合中<strong>全是奇数</strong>,显然成立。</li>
<li>假设集合中<strong>全是偶数</strong>，由于<strong>偶数都是2的倍数</strong>，那就可以都 <strong>/2</strong> 之后后按照奇数来进行判断，这样我们就能避免排除第一个状况了。</li>
</ol>
<p>但是组合有<strong>这么多</strong>我们如何排除呢？</p>
<p>普通的找到所有的奇数是十分简单的，但是如何将偶数变成奇数以后进行归纳呢? 这边<strong>显然</strong>的一点就是我们不能将 <strong>/2一次</strong> 变成奇数的和 <strong>/2两次</strong>变成奇数归在同一个集合中，如果知道这个那么做法就很明显了。由于最多不超过64个集合<del>因为是long long int</del>。那么我们就每次记录偶数位于那个集合，然后塞入即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这边使用vector实现的，没有用set，因为觉得set遍历输出好麻烦...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll num[maxn],x;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a[<span class="number">90</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="comment">//这边是分段塞入操作。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;num[i]);</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        x = num[i];</span><br><span class="line">        <span class="keyword">while</span>(x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            x/=<span class="number">2</span>;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最小的集合</span></span><br><span class="line">    m = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">-1</span> || a[m].size() &lt; a[i].size()) m=i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-a[m].size());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a[i].size(); j++) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>,num[a[i][j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>CodeForces</tag>
        <tag>Div.2</tag>
      </tags>
  </entry>
  <entry>
    <title>DEBUG-快速使用</title>
    <url>/2019/10/20/HowToUseDebug/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>运用 <strong>DEBUG</strong> 可以用来直观的观察<strong>寄存器</strong> 和 <strong>内存</strong>的值的变化。</p>
<a id="more"></a>
<h2 id="速查"><a href="#速查" class="headerlink" title="速查"></a>速查</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">expression</th>
<th style="text-align:center">example</th>
<th style="text-align:center">effect</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center">查看所有寄存器信息</td>
</tr>
<tr>
<td style="text-align:center"><strong>r</strong> 寄存器名字</td>
<td style="text-align:center"><strong>r ax</strong></td>
<td style="text-align:center">更改<strong>ax</strong>的值</td>
</tr>
<tr>
<td style="text-align:center"><strong>d</strong> 段地址:起始偏移地址 结束偏移地址</td>
<td style="text-align:center"><strong>d 1000:0 1f</strong></td>
<td style="text-align:center">查看<strong>内存</strong>中物理地址为10000 ~ 1001f 的存储单元的值</td>
</tr>
<tr>
<td style="text-align:center"><strong>e</strong> 段地址:偏移地址</td>
<td style="text-align:center"><strong>e 1000:0</strong></td>
<td style="text-align:center">从<strong>物理地址</strong>为10000的存储单元开始，向里面写入值</td>
</tr>
<tr>
<td style="text-align:center"><strong>a</strong> 段地址:偏移地址</td>
<td style="text-align:center"><strong>a 1000:0</strong></td>
<td style="text-align:center">位置同上，直接写入汇编代码</td>
</tr>
<tr>
<td style="text-align:center"><strong>u</strong> 段地址:起始偏移地址 结束偏移地址</td>
<td style="text-align:center"><strong>u 1000:1f</strong></td>
<td style="text-align:center">查看<strong>范围内(同-d命令)</strong>的<strong>汇编代码</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>t</strong></td>
<td style="text-align:center"><strong>t</strong></td>
<td style="text-align:center">逐语句运行</td>
</tr>
</tbody>
</table>
</div>
<h2 id="命令详情介绍"><a href="#命令详情介绍" class="headerlink" title="命令详情介绍"></a>命令详情介绍</h2><h3 id="input-r"><a href="#input-r" class="headerlink" title="[input] -r"></a>[input] <code>-r</code></h3><h4 id="1-查看所有寄存器数值"><a href="#1-查看所有寄存器数值" class="headerlink" title="1.  查看所有寄存器数值"></a>1.  查看所有寄存器数值</h4><p>-<strong>r</strong></p>
<p><img src="/img/r.png" alt="r.png"></p>
<h4 id="2-更改寄存器数值"><a href="#2-更改寄存器数值" class="headerlink" title="2.  更改寄存器数值"></a>2.  更改寄存器数值</h4><p>-<strong>r 寄存器名字</strong></p>
<p><img src="/img/r2.png" alt="r2.png"></p>
<h3 id="input-d"><a href="#input-d" class="headerlink" title="[input] -d"></a>[input] <code>-d</code></h3><h4 id="1-查看内存的值"><a href="#1-查看内存的值" class="headerlink" title="1.  查看内存的值"></a>1.  查看<strong>内存</strong>的值</h4><p>-<strong>d 段地址 : 起始偏移地址 结束偏移地址</strong></p>
<p><img src="/img/d.png" alt="d.png"></p>
<h3 id="input-e"><a href="#input-e" class="headerlink" title="[input] -e"></a>[input] <code>-e</code></h3><h4 id="1-更改内存中的值"><a href="#1-更改内存中的值" class="headerlink" title="1. 更改内存中的值"></a>1. 更改<strong>内存</strong>中的值</h4><p>-<strong>e 段地址 : 偏移地址</strong></p>
<p>Tips: 用 <space\> 结束当前值的输入</p>
<p><img src="/img/e.png" alt="e.png"></p>
<h3 id="input-a"><a href="#input-a" class="headerlink" title="[input] -a"></a>[input] <code>-a</code></h3><h4 id="1-写汇编代码"><a href="#1-写汇编代码" class="headerlink" title="1.  写汇编代码"></a>1.  写汇编代码</h4><p>-<strong>a 段地址 : 偏移地址</strong></p>
<p><img src="/img/a.png" alt="a.png"></p>
<h3 id="input-u"><a href="#input-u" class="headerlink" title="[input] -u"></a>[input] <code>-u</code></h3><h4 id="1-查看命令"><a href="#1-查看命令" class="headerlink" title="1.  查看命令"></a>1.  查看命令</h4><p>-<strong>u 段地址 : 起始偏移地址 结束偏移地址</strong></p>
<p><img src="/img/u.png" alt="u.png"></p>
<h3 id="input-t"><a href="#input-t" class="headerlink" title="[input] -t"></a>[input] <code>-t</code></h3><h4 id="1-逐语句运行"><a href="#1-逐语句运行" class="headerlink" title="1. 逐语句运行"></a>1. 逐语句运行</h4><p>-<strong>t</strong></p>
<p><img src="/img/t.png" alt="t.png"></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github+Next搭建个人博客</title>
    <url>/2019/10/20/HEXO1/</url>
    <content><![CDATA[<p>使用Github和Hexo搭建个人博客，并且用Next主题进行美化。<br>本地环境: Ubuntu 18.04.3 LTS</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>虽然已经有了用<strong>wordPress</strong>搭建了一个<a href="http://meskill.top/" target="_blank" rel="noopener"><strong>博客站点</strong></a>，但是主题和界面说实话，着实有点朴素，然后Ta没了</del>最经在看题解的时候，发现<strong>Github+Hexo+Next</strong>配置出来的网站十分好看，用Hexo+Github搭建了一个<a href="https://mirasire.xyz/"><strong>新的博客</strong></a>。</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><blockquote>
<p>本地环境<br>系统: Ubuntu 18.04.3 LTS<br>Node.js版本: v12.12.0<br>npm版本: 6.11.3</p>
</blockquote>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li><strong>git</strong>和<strong>github</strong>的基本使用</li>
<li>简单的<strong>bash</strong>操作</li>
</ul>
<h3 id="网站预览"><a href="#网站预览" class="headerlink" title="网站预览"></a>网站预览</h3><p><img src="/img/Hexo&amp;github1.png" alt="ForTest"></p>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Hexo 使用的 Node.js，这里建议在<strong>官网下载 Node.js</strong>，下载地址 | <a href="https://nodejs.org/en/download" target="_blank" rel="noopener">Node.js</a>，下载<strong>二进制文件</strong>(Linux Binaries x64)。</p>
<p>移动到下载的位置执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压你下载的文件</span></span><br><span class="line">tar -xvf node-v12.12.0-linux-x64.tar.xz <span class="comment">#最后一个是你下载的二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#移动解压缩后的文件夹</span></span><br><span class="line"><span class="comment">#需要root权限</span></span><br><span class="line">mv node-v12.12.0-linux-x64 /opt/node-v12.12.0-linux-x64</span><br></pre></td></tr></table></figure>
<p>然后是改变系统的环境变量，这步需要<strong>root权限</strong>，打开<code>/etc/profile</code>文件在底部添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SET PATH FOR NODEJS</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/opt/node-v12.12.0-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>重新加载<code>/etc/profile</code>，或者重启电脑使配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>这样我们就安装完成Node.js了，在终端以下命令来检测是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"><span class="comment">#成功会输出版本号</span></span><br><span class="line">npm -v</span><br><span class="line"><span class="comment">#成功会输出版本号</span></span><br></pre></td></tr></table></figure>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>我们使用<strong>这个命令</strong>来安装Hexo，安装时间可能会很长。<del>可以去泡杯茶，看个报纸什么<strong>0.0</strong></del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>安装成功后，我们随便找个地方<strong>建立一个文件夹</strong>，建立完毕后<strong>在文件夹下</strong> 输入以下命令，这个时间可能也会有点长。<del>可以去补个番，看个剧什么233</del></p>
<blockquote>
<p>注: Hexo框架和以后写的文章都在这个文件夹内,教程里面建立文件夹名字是MyWebsite</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>以上都准备完毕后，我们可以<strong>依次</strong>输入<strong>下面3条命令</strong>，然后在浏览器里面打开<a href="http://localhost:4000/" target="_blank" rel="noopener"><strong>localhost:4000</strong></a>，来康康我们的网站<strong>雏形</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清楚缓存和已生成的静态文件</span></span><br><span class="line">hexo clean </span><br><span class="line"><span class="comment">#生成静态文件 是 hexo generate 的简写</span></span><br><span class="line">hexo g </span><br><span class="line"><span class="comment">#启动服务器。是 hexo server 的简写</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><strong>接下来是一些简单的hexo命令介绍</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hexo new “XXX”</td>
<td style="text-align:center">新建 “XXX” 文章</td>
</tr>
<tr>
<td style="text-align:center">hexo clean</td>
<td style="text-align:center">清楚缓存和已生成的静态文件</td>
</tr>
<tr>
<td style="text-align:center">hexo g</td>
<td style="text-align:center">生成静态文件。是 hexo generate 的简写</td>
</tr>
<tr>
<td style="text-align:center">hexo d</td>
<td style="text-align:center">部署网站。是 hexo deploy 的简写</td>
</tr>
<tr>
<td style="text-align:center">hexo s</td>
<td style="text-align:center">启动服务器。是 hexo server 的简写</td>
</tr>
</tbody>
</table>
</div>
<h3 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h3><ol>
<li>新建立一个仓库，并且仓库的名字为 <strong>XXX</strong>.github.io，这边要<strong>强烈注意!!!!</strong> , XXX必须是你Github的用户名，即图中两个箭头指向的地方要相等。</li>
</ol>
<blockquote>
<p> 由于我已经建立，所以Github上会有警告显示。</p>
<p><img src="/img/Hexo&amp;&amp;github2.jpg" alt="xxx.github.io"></p>
</blockquote>
<ol>
<li>移动到刚刚<strong>hexo</strong>建立的文件夹下，打开<code>_config.yml</code>文件，这个文件是站点的配置文件夹。在文件夹下面找到下述文字并更改。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找的文字</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> </span><br><span class="line"><span class="attr">  repo:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#更改为</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/XXX/XXX.github.io.git</span> <span class="comment">#XXX就是你的名字</span></span><br></pre></td></tr></table></figure>
<ol>
<li>然后我们在文件夹下面<strong>依次</strong>输入以下命令，之后输入github的登陆邮箱和密码，就部署完成了。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line"><span class="comment">#输入github的登陆邮箱</span></span><br><span class="line"><span class="comment">#输入github的登陆密码</span></span><br></pre></td></tr></table></figure>
<p>这样我们就能通过<code>你的Github用户名.github.io</code>来访问自己的博客网站了。</p>
<h3 id="设置-next-主题"><a href="#设置-next-主题" class="headerlink" title="设置 next 主题"></a>设置 next 主题</h3><p>在文件夹下面输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>打开<strong>站点的</strong> <code>_config.yml</code> 搜索并且更换</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#寻找的文字</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改为</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p><strong>重新执行</strong> <code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>，来生效。</p>
<h3 id="站点的基本配置"><a href="#站点的基本配置" class="headerlink" title="站点的基本配置"></a>站点的基本配置</h3><p>打开<strong>站点的</strong> <code>_config.yml</code> ,进行更改即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment">#站点的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment">#站点的副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">#关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment">#博客的作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="comment">#语言代码详见文档  中文用zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment">#时间 一般用 Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo中文文档</a><br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程 - 吴润</a><br><a href="https://www.jianshu.com/p/21e42cd362e7" target="_blank" rel="noopener">linux入门-nodejs的安装及配置-MsgSS</a></p>
]]></content>
      <categories>
        <category>胡搞瞎搞💥</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Github</tag>
        <tag>hexo</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章显示</title>
    <url>/2019/10/19/Test/</url>
    <content><![CDATA[<blockquote>
<p>For test<br>用于测试markdown的显示</p>
</blockquote>
<a id="more"></a>
<h1 id="标题测试-一级标题"><a href="#标题测试-一级标题" class="headerlink" title="(标题测试)一级标题"></a>(标题测试)一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="字体设置-表格"><a href="#字体设置-表格" class="headerlink" title="字体设置+表格"></a>字体设置+表格</h1><blockquote>
<p>Hello</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">效果</th>
<th style="text-align:left">书写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>hello</strong></td>
<td style="text-align:left">**hello**</td>
</tr>
<tr>
<td style="text-align:left"><em>hello</em></td>
<td style="text-align:left">*hello*</td>
</tr>
<tr>
<td style="text-align:left"><code>hello</code></td>
<td style="text-align:left">`hello`</td>
</tr>
<tr>
<td style="text-align:left"><del>hello</del></td>
<td style="text-align:left">~~hello~~</td>
</tr>
<tr>
<td style="text-align:left"><strong><em>hello</em></strong></td>
<td style="text-align:left">***hello***</td>
</tr>
</tbody>
</table>
</div>
<h1 id="层级显示"><a href="#层级显示" class="headerlink" title="层级显示"></a>层级显示</h1><p><strong>无序</strong></p>
<ul>
<li>1<ul>
<li>1.1<ul>
<li>1.1.1</li>
</ul>
</li>
</ul>
</li>
<li>1<ul>
<li>1.1</li>
</ul>
</li>
</ul>
<p><strong>有序</strong></p>
<ol>
<li>top<ol>
<li>1</li>
<li>2</li>
</ol>
</li>
<li>seconf</li>
</ol>
<h1 id="公式显示"><a href="#公式显示" class="headerlink" title="公式显示"></a>公式显示</h1><script type="math/tex; mode=display">

1+2+3+\dots+(n-1)+n = \frac{n(n+1)}{2}</script><p>$\textbf{you }are soo cute$</p>
<script type="math/tex; mode=display">

P = \frac
{\sum_{i=1}^n (x_i- x)(y_i- y)}
{\displaystyle \left[
\sum_{i=1}^n (x_i-x)^2
\sum_{i=1}^n (y_i-y)^2
\right]^{1/2} }</script><h1 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; 'Hello World\n';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Learn</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>XUJCOJ 报错排查手册</title>
    <url>/2019/09/19/manXUJCOJ/</url>
    <content><![CDATA[<blockquote>
<p>关于XUJCOJ返回信息的说明</p>
</blockquote>
<a id="more"></a>
<h2 id="AC-Accepted"><a href="#AC-Accepted" class="headerlink" title="AC - Accepted"></a>AC - Accepted</h2><p><strong>恭喜程序通过</strong></p>
<h2 id="WA-Wrong-Answer"><a href="#WA-Wrong-Answer" class="headerlink" title="WA - Wrong Answer"></a>WA - Wrong Answer</h2><p><strong>你程序错了去debug吧！</strong></p>
<h2 id="CE-Compile-Error"><a href="#CE-Compile-Error" class="headerlink" title="CE - Compile Error"></a>CE - Compile Error</h2><blockquote>
<p>由于 OJ所用服务器使用的编译环境不同，你的程序没有通过编译<br>  OJ 的编译环境详情见帮助</p>
</blockquote>
<p><strong>解决：</strong> 点击状态即<code>CompileError</code>，查看具体信息</p>
<h2 id="RE-Runtime-Error"><a href="#RE-Runtime-Error" class="headerlink" title="RE- Runtime Error"></a>RE- Runtime Error</h2><blockquote>
<p>程序运行时候发生错误</p>
</blockquote>
<p><strong>解决：</strong> 是否发生<strong>除0</strong>错误， 或者是否数组访问的下标是否不存在，或者指针问题。</p>
<h2 id="PE-Presentation-Error"><a href="#PE-Presentation-Error" class="headerlink" title="PE - Presentation Error"></a>PE - Presentation Error</h2><blockquote>
<p>格式错误，由于OJ的判题系统十分严格，所以多一个空格或者换行都会造成这种错误。</p>
</blockquote>
<p><strong>解决：</strong> 重新读题看其中的输出要求是什么，并且严格按照要求输出，而不是看表面视觉效果，<del>因为多余的空格和换行看不出来啊，臭DD</del></p>
<h2 id="TLE-Time-Limit-Exceeded"><a href="#TLE-Time-Limit-Exceeded" class="headerlink" title="TLE - Time Limit Exceeded"></a>TLE - Time Limit Exceeded</h2><blockquote>
<p>程序超时 - [注意每题都有规定的判题时间]</p>
<ol>
<li>程序死循环</li>
<li>程序的时间复杂度超了</li>
</ol>
</blockquote>
<p><strong>解决：</strong> 代码问题，考虑是否出现死循环，或者程序是否还能继续优化，或者算法的时间复杂度是否过大。</p>
<h2 id="MLE-Memory-Limit-Exceeded"><a href="#MLE-Memory-Limit-Exceeded" class="headerlink" title="MLE - Memory Limit Exceeded"></a>MLE - Memory Limit Exceeded</h2><blockquote>
<p>程序超内存了 - [注意每题都有规定的内存]</p>
</blockquote>
<p><strong>解决：</strong> 是否是使用STL库造成，或者是自己数组开太大了</p>
<h2 id="OLE-Output-Limit-Exceeded"><a href="#OLE-Output-Limit-Exceeded" class="headerlink" title="OLE - Output Limit Exceeded"></a>OLE - Output Limit Exceeded</h2><blockquote>
<p>你的输出比正确答案长了两倍.</p>
</blockquote>
<p><strong>解决：</strong> debug<del>虽然我从来都是重写2333</del></p>
<h2 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h2><blockquote>
<p>由于网络或者学校服务器原因，系统还在判题</p>
</blockquote>
<p><strong>解决：</strong> 只要疯狂刷新网页就行</p>
<h2 id="Pending-Rejudge"><a href="#Pending-Rejudge" class="headerlink" title="Pending Rejudge"></a>Pending Rejudge</h2><blockquote>
<p>由于不可抗力，系统在进行重判你的代码</p>
</blockquote>
<p><strong>解决：</strong> 只要疯狂刷新网页就行</p>
<h2 id="C语言专题"><a href="#C语言专题" class="headerlink" title="C语言专题"></a>C语言专题</h2><ol>
<li>使用c语言注意转义字符中的’\b’无法使用由于xujcoj是判题是文件输入输出</li>
<li>在 <strong>printf</strong> 打印float/double时候，如果题目没有特殊要求，就要用%g</li>
<li>在<strong>scanf</strong>字符类型的数据WA时候,有时需要 <strong>scanf(“ %c”,c)</strong> 来进行读入</li>
<li>奇技淫巧请自己探索啦</li>
</ol>
]]></content>
      <categories>
        <category>独立思考</category>
      </categories>
      <tags>
        <tag>icpc</tag>
        <tag>杂</tag>
      </tags>
  </entry>
</search>
